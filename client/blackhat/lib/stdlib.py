from typing import Optional, Union

from ..helpers import Result, ResultMessages

computer: Optional["Computer"] = None


def update(comp: "Computer"):
    """
    Store a reference to the games current `Computer` object as a global variable so methods can reference it without
    requiring it as an argument
    
    Args:
        comp (:obj:`Computer`): The games current `Computer` object

    Returns:
        None
    """
    global computer
    computer = comp


def system(command: str, output: bool = True) -> Result:
    """
    Run a command on the current `Computer)

    Args:
        command (str): The command to run
        output (bool): Should output command result or not

    Returns:
        Result: The `Result` object generated by the command
    """
    # Split the command and args
    split_command = command.split(" ")
    return computer.run_command(split_command[0], split_command[1:], not output)


# TODO: Maybe implement `int overwrite` argument?
def setenv(name: str, value: str) -> Result:
    """
    Set an environment variable to the current session

    Args:
        key (str): The env var to set
        value (str): The value of the new var to set

    Returns:
        Result: A `Result` object with the success flag set accordingly
    """
    return computer.set_env(name, value)


def unsetenv(key: str) -> Result:
    """
    Remove an environment variable from the current `Session`

    Args:
        key (str): The env var to remove

    Returns:
        Result: A `Result` object with the success flag set accordingly
    """
    if len(computer.sessions) == 0:
        return Result(success=False, message=ResultMessages.GENERIC)

    if key in computer.sessions[-1].env:
        del computer.sessions[-1].env[key]

    return Result(success=True)


def get_env(key: Optional[str] = None) -> Optional[Union[str, dict]]:
    """
    Get an environment variable from the current `Session`


    Args:
        key (str): The env var to get

    Returns:
        Result: A `Result` object with the success flag set accordingly and the data flag containing the variable data if successful
    """
    if key:
        return computer.get_env(key)

    return computer.sessions[-1].env


def exit(force=False) -> None:
    """
    Exit a session and return to the previous session. If a previous computer exists and no sessions exist,
    return to the previous computer. If no previous computer exists, exit the game.

    Args:
        force (bool): If a prev computer exists, exit to previous computer regardless of previous sessions. If no previous computers exist, exit the game.

    Returns:
        None
    """
    computer.sys_exit(force)
