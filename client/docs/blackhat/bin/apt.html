<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>blackhat.bin.apt API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>blackhat.bin.apt</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">__package__ = &#34;blackhat.bin&#34;

import os
from itertools import chain
from json import loads
from typing import Union
from colorama import Fore

from ..fs import File, Directory
from ..helpers import Result
from ..lib.fcntl import creat
from ..lib.input import ArgParser
from ..lib.netdb import gethostbyname
from ..lib.output import output
from ..lib.sys import socket
from ..lib.sys.stat import stat
from ..lib.unistd import read, write, getuid, execvp

__COMMAND__ = &#34;apt&#34;
__DESCRIPTION__ = &#34;&#34;
__DESCRIPTION_LONG__ = &#34;&#34;
__VERSION__ = &#34;1.0&#34;


def parse_args(args=[], doc=False):
    &#34;&#34;&#34;
    Handle parsing of arguments and flags. Generates docs using help from `ArgParser`

    Args:
        args (list): argv passed to the binary
        doc (bool): If the function should generate and return manpage

    Returns:
        Processed args and a copy of the `ArgParser` object if not `doc` else a `string` containing the generated manpage
    &#34;&#34;&#34;
    parser = ArgParser(prog=__COMMAND__, description=f&#34;{__COMMAND__} - {__DESCRIPTION__}&#34;)
    parser.add_argument(&#34;command&#34;)
    parser.add_argument(&#34;packages&#34;, nargs=&#34;+&#34;)
    parser.add_argument(&#34;--version&#34;, action=&#34;store_true&#34;, help=f&#34;print program version&#34;)

    args = parser.parse_args(args)

    arg_helps_with_dups = parser._actions

    arg_helps = []
    [arg_helps.append(x) for x in arg_helps_with_dups if x not in arg_helps]

    NAME = f&#34;**NAME*/\n\t{__COMMAND__} - {__DESCRIPTION__}&#34;
    SYNOPSIS = f&#34;**SYNOPSIS*/\n\t{__COMMAND__} [OPTION]... &#34;
    DESCRIPTION = f&#34;**DESCRIPTION*/\n\t{__DESCRIPTION_LONG__}\n\n&#34;

    for item in arg_helps:
        # Its a positional argument
        if len(item.option_strings) == 0:
            # If the argument is optional:
            if item.nargs == &#34;?&#34;:
                SYNOPSIS += f&#34;[{item.dest.upper()}] &#34;
            elif item.nargs == &#34;+&#34;:
                SYNOPSIS += f&#34;[{item.dest.upper()}]... &#34;
            else:
                SYNOPSIS += f&#34;{item.dest.upper()} &#34;
        else:
            # Boolean flag
            if item.nargs == 0:
                if len(item.option_strings) == 1:
                    DESCRIPTION += f&#34;\t**{&#39; &#39;.join(item.option_strings)}*/\t{item.help}\n\n&#34;
                else:
                    DESCRIPTION += f&#34;\t**{&#39; &#39;.join(item.option_strings)}*/\n\t\t{item.help}\n\n&#34;
            elif item.nargs == &#34;+&#34;:
                DESCRIPTION += f&#34;\t**{&#39; &#39;.join(item.option_strings)}*/=[{item.dest.upper()}]...\n\t\t{item.help}\n\n&#34;
            else:
                DESCRIPTION += f&#34;\t**{&#39; &#39;.join(item.option_strings)}*/={item.dest.upper()}\n\t\t{item.help}\n\n&#34;

    if doc:
        return f&#34;{NAME}\n\n{SYNOPSIS}\n\n{DESCRIPTION}\n\n&#34;
    else:
        return args, parser


def flatten_list(not_flat_list):
    flat_list = []
    # Iterate through the outer list
    for element in not_flat_list:
        if type(element) is list:
            # If the element is of type list, iterate through the sublist
            for item in element:
                flat_list.append(item)
        else:
            flat_list.append(element)
    return flat_list


def generate_tree(current_directory: Directory, current_path: str = None):
    if not current_path:
        current_path = &#34;/&#34; + current_directory.name
    output_paths = []

    for item_name, item in current_directory.files.items():
        if item.is_directory():
            output_paths.append(generate_tree(item, os.path.join(current_path, item_name)))
        else:
            output_paths.append((os.path.join(current_path, item_name), item))

    return flatten_list(output_paths)


def install_package(package: list[tuple[str, File]]) -&gt; bool:
    for filepath, file in package:
        parent_path = &#34;/&#34;.join(filepath.split(&#34;/&#34;)[:-1])
        # print(f&#34;Installing {file.name} to {parent_path} with mode {str(oct(file.get_perm_octal()).replace(&#39;0o&#39;, &#39;&#39;))}&#34;)
        execvp(&#34;mkdir&#34;, [&#34;-p&#34;, parent_path])
        # Make sure the folder was created
        if not stat(parent_path).success:
            return False

        current_file = creat(filepath, file.get_perm_octal())
        if not current_file.success:
            return False

        result = write(filepath, file.content)
        if not result:
            return False

    return True


def read_installed_packages():
    # Make sure /usr/bin, /var/lib/dpkg and /etc/apt/sources.list exists
    read_usr_lib_dpkg_status = read(&#34;/var/lib/dpkg/status&#34;)
    installed_packages = read_usr_lib_dpkg_status.data.split(&#34;\n&#34;)
    while &#34;&#34; in installed_packages:
        installed_packages.remove(&#34;&#34;)

    return installed_packages


def main(args: list, pipe: bool) -&gt; Result:
    args, parser = parse_args(args)

    if parser.error_message:
        if not args.version:
            return output(f&#34;{__COMMAND__}: {parser.error_message}&#34;, pipe, success=False)

    # If we specific -h/--help, args will be empty, so exit gracefully
    if not args:
        return output(&#34;&#34;, pipe)
    else:
        if getuid() != 0:
            return output(f&#34;{__COMMAND__}: error: you cannot perform this operation unless you are root.&#34;, pipe,
                          success=False)
        # Read the packages.json file to substitute packages with a list of their subpackages (if they have)
        with open(&#34;packages.json&#34;, &#34;r&#34;) as f:
            all_packages = loads(f.read())
        if args.command == &#34;install&#34;:
            # Make sure /usr/bin, /var/lib/dpkg and /etc/apt/sources.list exists
            read_usr_lib_dpkg_status = read(&#34;/var/lib/dpkg/status&#34;)
            read_apt_sources = read(&#34;/etc/apt/sources.list&#34;)
            if not read_usr_lib_dpkg_status.success or not read_apt_sources.success:
                # In reality, a snap error will occur but we don&#39;t have snap so just throw general error
                return output(
                    f&#34;{__COMMAND__}: Failed to install packages, check /usr/bin, /var/lib/dpkg, and /etc/apt/*&#34;,
                    pipe,
                    success=False)

            installed_packages = read_installed_packages()

            # Now we need to contact each server in our sources.list and ask each server if they have the package we&#39;re looking for
            servers = read_apt_sources.data.split(&#34;\n&#34;)

            while &#34;&#34; in servers:
                servers.remove(&#34;&#34;)

            outstanding_packages = args.packages.copy()
            # Remove duplicates
            outstanding_packages = list(dict.fromkeys(outstanding_packages))

            for server in servers:
                split_server = server.split(&#34;:&#34;)
                if len(split_server) == 1:
                    port = 80
                else:
                    port = split_server[1]

                host = split_server[0]

                resolve_hostname = gethostbyname(host)

                sock = socket.Socket(socket.AF_INET, socket.SOCK_STREAM)
                sock_addr = socket.SockAddr(socket.AF_INET, port, resolve_hostname.data.h_addr)
                connection_result = socket.connect(sock, sock_addr)

                if not connection_result.success:
                    print(f&#34;{__COMMAND__}: Unable to connect to {host}&#34;)
                    # return output(f&#34;{__COMMAND__}: Unable to connect to {host}&#34;, pipe, success=False)

                ask_server_result = write(sock, {&#34;packages&#34;: [x for x in outstanding_packages]})

                if ask_server_result.success:
                    for package in ask_server_result.data[&#34;obtained&#34;]:
                        structure = []
                        if package[&#34;name&#34;] in outstanding_packages:
                            if package[&#34;name&#34;] in installed_packages:
                                print(f&#34;{package[&#39;name&#39;]} is already the newest version ({package[&#39;version&#39;]}).&#34;)
                                outstanding_packages.remove(package[&#34;name&#34;])
                                continue  # Skip the rest

                            # Loop through the directory structure and copy the files where they belong
                            for inode_name, inode in package[&#34;data&#34;].files.items():
                                structure += generate_tree(inode)
                            outstanding_packages.remove(package[&#34;name&#34;])
                        # Install the package
                        print(f&#34;Installing {package[&#39;name&#39;]}...&#34;, end=&#34; &#34;)
                        install_result = install_package(structure)
                        if install_result:
                            installed_packages = &#34;\n&#34;.join(installed_packages + [package[&#34;name&#34;]])
                            write(&#34;/var/lib/dpkg/status&#34;, installed_packages)
                            installed_packages = read_installed_packages()
                            print(Fore.GREEN + &#34;success&#34; + Fore.RESET)
                        else:
                            print(Fore.RED + &#34;failed&#34; + Fore.RESET)

                # At the end, if we have packages left over, report them
                for package in outstanding_packages:
                    print(f&#34;{Fore.RED}E:{Fore.RESET} Unable to locate package {package}&#34;)

            return output(&#34;&#34;, pipe=pipe)


        # elif args.command == &#34;remove&#34;:
        #     find_status_file = computer.fs.find(&#34;/var/lib/dpkg/status&#34;)
        #     if not find_status_file.success:
        #         return output(f&#34;{__COMMAND__}: Unable to remove packages&#34;, pipe, success=False)
        #
        #     status_file = find_status_file.data
        #
        #     read_status = status_file.read(computer)
        #
        #     if not read_status.success:
        #         return output(f&#34;{__COMMAND__}: Unable to remove packages&#34;, pipe, success=False)
        #
        #     installed_packages = [x for x in read_status.data.split(&#34;\n&#34;)]
        #
        #     # Make sure all the packages we&#39;re trying to remove are actually installed
        #     for to_remove in args.packages:
        #         if to_remove not in installed_packages:
        #             return output(f&#34;{__COMMAND__}: Package &#39;{to_remove}&#39; is not installed, so not removed&#34;, pipe,
        #                           success=False)
        #
        #     for to_remove in args.packages:
        #         # Check if the package we&#39;re trying to remove has subpackages
        #         subpackages = all_packages.get(to_remove)
        #         if subpackages:
        #             for subpkg in subpackages:
        #                 computer.run_command(&#34;rm&#34;, [f&#34;/usr/bin/{subpkg}&#34;], pipe)
        #         else:
        #             computer.run_command(&#34;rm&#34;, [f&#34;/usr/bin/{to_remove}&#34;], pipe)
        #             computer.run_command(&#34;rm&#34;, [f&#34;/usr/share/man/{to_remove}&#34;], pipe)
        #         installed_packages.remove(to_remove)
        #
        #     # Update the content of /var/lib/dpkg/status
        #     status_file.write(&#34;\n&#34;.join(installed_packages), computer)
        #
        #     return output(f&#34;{__COMMAND__}: Successfully removed packages: {&#39; &#39;.join(args.packages)}&#34;, pipe)

        else:
            return output(f&#34;{__COMMAND__}: invalid operation: {args.command}&#34;, pipe, success=False)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="blackhat.bin.apt.flatten_list"><code class="name flex">
<span>def <span class="ident">flatten_list</span></span>(<span>not_flat_list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flatten_list(not_flat_list):
    flat_list = []
    # Iterate through the outer list
    for element in not_flat_list:
        if type(element) is list:
            # If the element is of type list, iterate through the sublist
            for item in element:
                flat_list.append(item)
        else:
            flat_list.append(element)
    return flat_list</code></pre>
</details>
</dd>
<dt id="blackhat.bin.apt.generate_tree"><code class="name flex">
<span>def <span class="ident">generate_tree</span></span>(<span>current_directory: <a title="blackhat.fs.Directory" href="../fs.html#blackhat.fs.Directory">Directory</a>, current_path: str = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_tree(current_directory: Directory, current_path: str = None):
    if not current_path:
        current_path = &#34;/&#34; + current_directory.name
    output_paths = []

    for item_name, item in current_directory.files.items():
        if item.is_directory():
            output_paths.append(generate_tree(item, os.path.join(current_path, item_name)))
        else:
            output_paths.append((os.path.join(current_path, item_name), item))

    return flatten_list(output_paths)</code></pre>
</details>
</dd>
<dt id="blackhat.bin.apt.install_package"><code class="name flex">
<span>def <span class="ident">install_package</span></span>(<span>package: list[tuple[str, <a title="blackhat.fs.File" href="../fs.html#blackhat.fs.File">File</a>]]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def install_package(package: list[tuple[str, File]]) -&gt; bool:
    for filepath, file in package:
        parent_path = &#34;/&#34;.join(filepath.split(&#34;/&#34;)[:-1])
        # print(f&#34;Installing {file.name} to {parent_path} with mode {str(oct(file.get_perm_octal()).replace(&#39;0o&#39;, &#39;&#39;))}&#34;)
        execvp(&#34;mkdir&#34;, [&#34;-p&#34;, parent_path])
        # Make sure the folder was created
        if not stat(parent_path).success:
            return False

        current_file = creat(filepath, file.get_perm_octal())
        if not current_file.success:
            return False

        result = write(filepath, file.content)
        if not result:
            return False

    return True</code></pre>
</details>
</dd>
<dt id="blackhat.bin.apt.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>args: list, pipe: bool) ‑> <a title="blackhat.helpers.Result" href="../helpers.html#blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(args: list, pipe: bool) -&gt; Result:
    args, parser = parse_args(args)

    if parser.error_message:
        if not args.version:
            return output(f&#34;{__COMMAND__}: {parser.error_message}&#34;, pipe, success=False)

    # If we specific -h/--help, args will be empty, so exit gracefully
    if not args:
        return output(&#34;&#34;, pipe)
    else:
        if getuid() != 0:
            return output(f&#34;{__COMMAND__}: error: you cannot perform this operation unless you are root.&#34;, pipe,
                          success=False)
        # Read the packages.json file to substitute packages with a list of their subpackages (if they have)
        with open(&#34;packages.json&#34;, &#34;r&#34;) as f:
            all_packages = loads(f.read())
        if args.command == &#34;install&#34;:
            # Make sure /usr/bin, /var/lib/dpkg and /etc/apt/sources.list exists
            read_usr_lib_dpkg_status = read(&#34;/var/lib/dpkg/status&#34;)
            read_apt_sources = read(&#34;/etc/apt/sources.list&#34;)
            if not read_usr_lib_dpkg_status.success or not read_apt_sources.success:
                # In reality, a snap error will occur but we don&#39;t have snap so just throw general error
                return output(
                    f&#34;{__COMMAND__}: Failed to install packages, check /usr/bin, /var/lib/dpkg, and /etc/apt/*&#34;,
                    pipe,
                    success=False)

            installed_packages = read_installed_packages()

            # Now we need to contact each server in our sources.list and ask each server if they have the package we&#39;re looking for
            servers = read_apt_sources.data.split(&#34;\n&#34;)

            while &#34;&#34; in servers:
                servers.remove(&#34;&#34;)

            outstanding_packages = args.packages.copy()
            # Remove duplicates
            outstanding_packages = list(dict.fromkeys(outstanding_packages))

            for server in servers:
                split_server = server.split(&#34;:&#34;)
                if len(split_server) == 1:
                    port = 80
                else:
                    port = split_server[1]

                host = split_server[0]

                resolve_hostname = gethostbyname(host)

                sock = socket.Socket(socket.AF_INET, socket.SOCK_STREAM)
                sock_addr = socket.SockAddr(socket.AF_INET, port, resolve_hostname.data.h_addr)
                connection_result = socket.connect(sock, sock_addr)

                if not connection_result.success:
                    print(f&#34;{__COMMAND__}: Unable to connect to {host}&#34;)
                    # return output(f&#34;{__COMMAND__}: Unable to connect to {host}&#34;, pipe, success=False)

                ask_server_result = write(sock, {&#34;packages&#34;: [x for x in outstanding_packages]})

                if ask_server_result.success:
                    for package in ask_server_result.data[&#34;obtained&#34;]:
                        structure = []
                        if package[&#34;name&#34;] in outstanding_packages:
                            if package[&#34;name&#34;] in installed_packages:
                                print(f&#34;{package[&#39;name&#39;]} is already the newest version ({package[&#39;version&#39;]}).&#34;)
                                outstanding_packages.remove(package[&#34;name&#34;])
                                continue  # Skip the rest

                            # Loop through the directory structure and copy the files where they belong
                            for inode_name, inode in package[&#34;data&#34;].files.items():
                                structure += generate_tree(inode)
                            outstanding_packages.remove(package[&#34;name&#34;])
                        # Install the package
                        print(f&#34;Installing {package[&#39;name&#39;]}...&#34;, end=&#34; &#34;)
                        install_result = install_package(structure)
                        if install_result:
                            installed_packages = &#34;\n&#34;.join(installed_packages + [package[&#34;name&#34;]])
                            write(&#34;/var/lib/dpkg/status&#34;, installed_packages)
                            installed_packages = read_installed_packages()
                            print(Fore.GREEN + &#34;success&#34; + Fore.RESET)
                        else:
                            print(Fore.RED + &#34;failed&#34; + Fore.RESET)

                # At the end, if we have packages left over, report them
                for package in outstanding_packages:
                    print(f&#34;{Fore.RED}E:{Fore.RESET} Unable to locate package {package}&#34;)

            return output(&#34;&#34;, pipe=pipe)


        # elif args.command == &#34;remove&#34;:
        #     find_status_file = computer.fs.find(&#34;/var/lib/dpkg/status&#34;)
        #     if not find_status_file.success:
        #         return output(f&#34;{__COMMAND__}: Unable to remove packages&#34;, pipe, success=False)
        #
        #     status_file = find_status_file.data
        #
        #     read_status = status_file.read(computer)
        #
        #     if not read_status.success:
        #         return output(f&#34;{__COMMAND__}: Unable to remove packages&#34;, pipe, success=False)
        #
        #     installed_packages = [x for x in read_status.data.split(&#34;\n&#34;)]
        #
        #     # Make sure all the packages we&#39;re trying to remove are actually installed
        #     for to_remove in args.packages:
        #         if to_remove not in installed_packages:
        #             return output(f&#34;{__COMMAND__}: Package &#39;{to_remove}&#39; is not installed, so not removed&#34;, pipe,
        #                           success=False)
        #
        #     for to_remove in args.packages:
        #         # Check if the package we&#39;re trying to remove has subpackages
        #         subpackages = all_packages.get(to_remove)
        #         if subpackages:
        #             for subpkg in subpackages:
        #                 computer.run_command(&#34;rm&#34;, [f&#34;/usr/bin/{subpkg}&#34;], pipe)
        #         else:
        #             computer.run_command(&#34;rm&#34;, [f&#34;/usr/bin/{to_remove}&#34;], pipe)
        #             computer.run_command(&#34;rm&#34;, [f&#34;/usr/share/man/{to_remove}&#34;], pipe)
        #         installed_packages.remove(to_remove)
        #
        #     # Update the content of /var/lib/dpkg/status
        #     status_file.write(&#34;\n&#34;.join(installed_packages), computer)
        #
        #     return output(f&#34;{__COMMAND__}: Successfully removed packages: {&#39; &#39;.join(args.packages)}&#34;, pipe)

        else:
            return output(f&#34;{__COMMAND__}: invalid operation: {args.command}&#34;, pipe, success=False)</code></pre>
</details>
</dd>
<dt id="blackhat.bin.apt.parse_args"><code class="name flex">
<span>def <span class="ident">parse_args</span></span>(<span>args=[], doc=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle parsing of arguments and flags. Generates docs using help from <code>ArgParser</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong> :&ensp;<code>list</code></dt>
<dd>argv passed to the binary</dd>
<dt><strong><code>doc</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the function should generate and return manpage</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Processed args and a copy of the <code>ArgParser</code> object if not <code>doc</code> else a <code>string</code> containing the generated manpage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_args(args=[], doc=False):
    &#34;&#34;&#34;
    Handle parsing of arguments and flags. Generates docs using help from `ArgParser`

    Args:
        args (list): argv passed to the binary
        doc (bool): If the function should generate and return manpage

    Returns:
        Processed args and a copy of the `ArgParser` object if not `doc` else a `string` containing the generated manpage
    &#34;&#34;&#34;
    parser = ArgParser(prog=__COMMAND__, description=f&#34;{__COMMAND__} - {__DESCRIPTION__}&#34;)
    parser.add_argument(&#34;command&#34;)
    parser.add_argument(&#34;packages&#34;, nargs=&#34;+&#34;)
    parser.add_argument(&#34;--version&#34;, action=&#34;store_true&#34;, help=f&#34;print program version&#34;)

    args = parser.parse_args(args)

    arg_helps_with_dups = parser._actions

    arg_helps = []
    [arg_helps.append(x) for x in arg_helps_with_dups if x not in arg_helps]

    NAME = f&#34;**NAME*/\n\t{__COMMAND__} - {__DESCRIPTION__}&#34;
    SYNOPSIS = f&#34;**SYNOPSIS*/\n\t{__COMMAND__} [OPTION]... &#34;
    DESCRIPTION = f&#34;**DESCRIPTION*/\n\t{__DESCRIPTION_LONG__}\n\n&#34;

    for item in arg_helps:
        # Its a positional argument
        if len(item.option_strings) == 0:
            # If the argument is optional:
            if item.nargs == &#34;?&#34;:
                SYNOPSIS += f&#34;[{item.dest.upper()}] &#34;
            elif item.nargs == &#34;+&#34;:
                SYNOPSIS += f&#34;[{item.dest.upper()}]... &#34;
            else:
                SYNOPSIS += f&#34;{item.dest.upper()} &#34;
        else:
            # Boolean flag
            if item.nargs == 0:
                if len(item.option_strings) == 1:
                    DESCRIPTION += f&#34;\t**{&#39; &#39;.join(item.option_strings)}*/\t{item.help}\n\n&#34;
                else:
                    DESCRIPTION += f&#34;\t**{&#39; &#39;.join(item.option_strings)}*/\n\t\t{item.help}\n\n&#34;
            elif item.nargs == &#34;+&#34;:
                DESCRIPTION += f&#34;\t**{&#39; &#39;.join(item.option_strings)}*/=[{item.dest.upper()}]...\n\t\t{item.help}\n\n&#34;
            else:
                DESCRIPTION += f&#34;\t**{&#39; &#39;.join(item.option_strings)}*/={item.dest.upper()}\n\t\t{item.help}\n\n&#34;

    if doc:
        return f&#34;{NAME}\n\n{SYNOPSIS}\n\n{DESCRIPTION}\n\n&#34;
    else:
        return args, parser</code></pre>
</details>
</dd>
<dt id="blackhat.bin.apt.read_installed_packages"><code class="name flex">
<span>def <span class="ident">read_installed_packages</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_installed_packages():
    # Make sure /usr/bin, /var/lib/dpkg and /etc/apt/sources.list exists
    read_usr_lib_dpkg_status = read(&#34;/var/lib/dpkg/status&#34;)
    installed_packages = read_usr_lib_dpkg_status.data.split(&#34;\n&#34;)
    while &#34;&#34; in installed_packages:
        installed_packages.remove(&#34;&#34;)

    return installed_packages</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="blackhat.bin" href="index.html">blackhat.bin</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="blackhat.bin.apt.flatten_list" href="#blackhat.bin.apt.flatten_list">flatten_list</a></code></li>
<li><code><a title="blackhat.bin.apt.generate_tree" href="#blackhat.bin.apt.generate_tree">generate_tree</a></code></li>
<li><code><a title="blackhat.bin.apt.install_package" href="#blackhat.bin.apt.install_package">install_package</a></code></li>
<li><code><a title="blackhat.bin.apt.main" href="#blackhat.bin.apt.main">main</a></code></li>
<li><code><a title="blackhat.bin.apt.parse_args" href="#blackhat.bin.apt.parse_args">parse_args</a></code></li>
<li><code><a title="blackhat.bin.apt.read_installed_packages" href="#blackhat.bin.apt.read_installed_packages">read_installed_packages</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>