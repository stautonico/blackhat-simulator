<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>client.blackhat.shell API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>client.blackhat.shell</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import readline
from datetime import datetime

from colorama import Fore, Style, Back

from .computer import Computer


class Shell:
    def __init__(self, computer: Computer) -&gt; None:
        &#34;&#34;&#34;
        A temporary class that takes the place of the user&#39;s shell
        This will be removed once the GUI is working

        Args:
            computer (Computer): The `Computer` that the given `Shell` interacts with
        &#34;&#34;&#34;
        self.computer: Computer = computer
        self.ssh_computer = None
        self.prompt: str = self.generate_prompt()

        # Setup tab to auto complete
        readline.parse_and_bind(&#34;tab: complete&#34;)
        readline.set_completer(self.autocomplete)

    def autocomplete(self, text, state):
        bin_dir_result = self.computer.fs.find(&#34;/bin&#34;)

        if bin_dir_result.success:
            commands = list(bin_dir_result.data.files.keys())
        else:
            commands = []

        results = [x for x in commands if x.startswith(text)] + [None]
        return results[state]

    def generate_prompt(self) -&gt; str:
        &#34;&#34;&#34;
        Generate the input prompt for the shell using the Bash PS1 environment variable
        Returns:
            str: The generated/formatted prompt
        &#34;&#34;&#34;
        shell_format = self.computer.sessions[-1].env.get(
            &#34;PS1&#34;) or &#34;\\e[0;31m\\u\\e[0m@\\e[0;32m\\h\\e[0m:\\e[0;34m\\w\\\\e[0m\\$ &#34;
        # Default shell prompt is &lt;USERNAME&gt;@&lt;HOSTNAME&gt;:&lt;WORKING DIR&gt;&lt;$/#&gt;

        # \d   The date, in &#34;Weekday Month Date&#34; format (e.g., &#34;Tue May 26&#34;).
        # \h   The hostname, up to the first .
        # \t   The time, in 24-hour HH:MM:SS format.
        # \T   The time, in 12-hour HH:MM:SS format.
        # \@   The time, in 12-hour am/pm format.
        # \u   The username of the current user.
        # \w   The current working directory.
        # \W   The basename of $PWD.
        # \$   If you are not root, inserts a &#34;$&#34;; if you are root, you get a &#34;#&#34;  (root uid = 0)
        # \e   An escape character (typically a color code).
        # \\   A backslash.

        prompt = shell_format
        prompt = prompt.replace(&#34;\\d&#34;, datetime.now().strftime(&#34;%a %B %d&#34;))
        prompt = prompt.replace(&#34;\\h&#34;, self.computer.hostname)
        prompt = prompt.replace(&#34;\\t&#34;, datetime.now().strftime(&#34;%H:%M:%S&#34;))
        prompt = prompt.replace(&#34;\\T&#34;, datetime.now().strftime(&#34;%I:%M:%S&#34;))
        prompt = prompt.replace(&#34;\\@&#34;, datetime.now().strftime(&#34;%I:%M:%S %p&#34;))
        prompt = prompt.replace(&#34;\\u&#34;, self.computer.lookup_username(self.computer.get_uid()).data)
        prompt = prompt.replace(&#34;\\w&#34;, self.computer.sessions[-1].current_dir.pwd())
        prompt = prompt.replace(&#34;\\W&#34;, self.computer.sessions[-1].current_dir.pwd().split(&#34;/&#34;)[-1] or &#34;/&#34;)
        prompt = prompt.replace(&#34;\\$&#34;, &#34;#&#34; if self.computer.get_uid() == self.computer.users[0] else &#34;$&#34;)
        prompt = prompt.replace(&#34;\\\\&#34;, &#34;\\&#34;)

        prompt = prompt.replace(&#34;\\e[0;31m&#34;, Fore.RED)
        prompt = prompt.replace(&#34;\\e[1;31m&#34;, Fore.LIGHTRED_EX)
        prompt = prompt.replace(&#34;\\e[0;32m&#34;, Fore.GREEN)
        prompt = prompt.replace(&#34;\\e[1;32m&#34;, Fore.LIGHTGREEN_EX)
        prompt = prompt.replace(&#34;\\e[0;33m&#34;, Fore.YELLOW)
        prompt = prompt.replace(&#34;\\e[1;33m&#34;, Fore.LIGHTYELLOW_EX)
        prompt = prompt.replace(&#34;\\e[0;34m&#34;, Fore.BLUE)
        prompt = prompt.replace(&#34;\\e[1;34m&#34;, Fore.LIGHTBLUE_EX)
        prompt = prompt.replace(&#34;\\e[0;35m&#34;, Fore.MAGENTA)
        prompt = prompt.replace(&#34;\\e[1;35m&#34;, Fore.LIGHTMAGENTA_EX)

        prompt = prompt.replace(&#34;\\e[41m&#34;, Back.RED)
        prompt = prompt.replace(&#34;\\e[42m&#34;, Back.GREEN)
        prompt = prompt.replace(&#34;\\e[43m&#34;, Back.YELLOW)
        prompt = prompt.replace(&#34;\\e[44m&#34;, Back.BLUE)
        prompt = prompt.replace(&#34;\\e[45m&#34;, Back.MAGENTA)
        prompt = prompt.replace(&#34;\\e[46m&#34;, Back.LIGHTBLUE_EX)

        # Remove color: \e[0m
        prompt = prompt.replace(&#34;\\e[0m&#34;, Style.RESET_ALL)

        return prompt

    def run_command(self, command: str, args: list, external_binary: bool, pipe: bool):
        &#34;&#34;&#34;
        Determine how to run the given input, then, update the `Shell`&#39;s prompt accordingly

        Args:
            command (str): The name of the command/binary to run
            args (list): The list of arguments passed by the user
            external_binary (bool): Weather or not we&#39;re running a standard system binary or an external binary
            pipe (bool): Weather or not we&#39;re going to pipe the command output to the input of another

        Returns:

        &#34;&#34;&#34;
        if external_binary:
            pass
            # response = self.computer.run_binary(command, args, pipe)
        else:
            response = self.computer.run_command(command, args, pipe)
        self.prompt = self.generate_prompt()
        return response

    def try_run_command(self, command, args, pipe=False):
        external_binary = False
        # Try to flatten the list of args to make one list
        flat_args = []
        flatten = False
        # Only flatten the args if a list exists in the current args
        # TODO: Find a faster way to do this
        for arg in args:
            if type(arg) == list:
                flatten = True
                break

        if flatten:
            for sublist in args:
                for item in sublist:
                    flat_args.append(item)
        else:
            flat_args = args

        # Check if the command is an external binary (external from /bin)
        if command.startswith(&#34;./&#34;):
            # External binaries that are not in the /bin dir
            # Remove the ./ to pass to the computer object
            command = command.replace(&#34;./&#34;, &#34;&#34;)
            external_binary = True

        try:
            result = self.run_command(command, flat_args, external_binary, pipe)
            if result.success:
                return result.data
            else:
                return False
        except IndexError as e:
            print(e)
            print(&#34;error running command&#34;)

    def handle_command(self, command):
        &#34;&#34;&#34;
        Handle the raw input from the user
        Parse out the args and special characters (|, &gt;, &gt;&gt;, etc)
        Determine how to route input and output between commands

        Args:
            command (str): The raw input entered by the user

        Returns:

        &#34;&#34;&#34;
        # Technically, the first element in our command should be the command name
        # And we can keep going through the
        command = command.split()
        # Filter!
        while &#34;&#34; in command:
            command.remove(&#34;&#34;)
        command_name = command[0]
        # Delete the command name from the command list (since we already have it)
        del command[0]

        # Easy cases if there are no special characters
        if &#34;|&#34; not in command and &#34;&gt;&#34; not in command and &#34;&gt;&gt;&#34; not in command:
            # We only pass &#34;command&#34; because we already removed the initial command name (and saved it)
            self.try_run_command(command_name, command, False)
        else:
            prev_command_result = None
            while True:
                for arg in command:
                    # Check if the current arg is | &gt; or &gt;&gt; (because we do something different here)
                    if arg in [&#34;|&#34;, &#34;&gt;&#34;, &#34;&gt;&gt;&#34;]:
                        current_index = command.index(arg)
                        # Find the special character (|/&gt;/&gt;&gt;) and decide what to do with it later
                        special_character = command[current_index]
                        break
                else:
                    # Run the last command and output
                    if len(command) == 0:
                        self.try_run_command(command_name, prev_command_result, False)
                    break

                current_args = command[0:current_index]

                if prev_command_result:
                    if type(prev_command_result) == list:
                        command_result = self.try_run_command(command_name,
                                                              current_args + prev_command_result, True)
                    else:
                        command_result = self.try_run_command(command_name,
                                                              current_args + [prev_command_result], True)
                else:
                    command_result = self.try_run_command(command_name, current_args, True)
                # Remove everything up to the current index (including the special character) (for the next cycle)
                del command[0:current_index + 1]

                # Don&#39;t even bother running if the command failed
                if command_result:
                    # If the special character is &gt; (write output) or &gt;&gt; (append output)
                    # We expect the next character in the command to be the file to write/append to
                    if special_character in [&#34;&gt;&#34;, &#34;&gt;&gt;&#34;]:
                        # We expect the next item after the &gt; to be the file to write/append to
                        filename_to_write_to = command[0]
                        # We need to try to remove extra spaces from the given filename
                        filename_to_write_to = filename_to_write_to.replace(&#34; &#34;, &#34;&#34;)

                        # Find the file that we should write the output to
                        find_response = self.computer.fs.find(filename_to_write_to)
                        if not find_response.success:
                            # This runs if the file doesn&#39;t exist (we need to create it)
                            find_response = self.computer.fs.find(&#34;/&#34;.join(filename_to_write_to.split(&#34;/&#34;)[:-1]))
                            if not find_response.success:
                                print(f&#34;shell: no such file or directory: {filename_to_write_to}&#34;)
                            else:
                                # Create the new file
                                # We&#39;re using a syscall because it handles permissions (so we dont have to)
                                create_file_response = self.run_command(&#34;touch&#34;, [filename_to_write_to], False, True)
                                if not create_file_response.success:
                                    print(f&#34;shell: unable to create file: {filename_to_write_to}&#34;)
                                    continue
                                else:
                                    file_to_write = self.computer.fs.find(filename_to_write_to).data
                        else:
                            file_to_write = find_response

                        message_to_write = command_result
                        if message_to_write.startswith(&#39;&#34;&#39;) and message_to_write.endswith(&#39;&#34;&#39;):
                            message_to_write = message_to_write[1:-1]

                        # Since the rest of the code for the &gt; and &gt;&gt; is the same up until this point
                        # We don&#39;t need to re-write it
                        if special_character == &#34;&gt;&#34;:
                            file_to_write.write(self.computer.get_uid(),
                                                message_to_write)
                        elif special_character == &#34;&gt;&gt;&#34;:
                            file_to_write.append(self.computer.get_uid(),
                                                 message_to_write)

                        prev_command_result = None
                    # Pass the input of the previous command to the current command
                    elif special_character == &#34;|&#34;:
                        prev_command_result = command_result
                        prev_command_result = prev_command_result.split()
                        command_name = command[0]
                        del command[0]

    def main(self):
        &#34;&#34;&#34;
        Run the main input loop

        Returns:
            None
        &#34;&#34;&#34;
        self.prompt = self.generate_prompt()
        while True:
            command = input(self.prompt)

            # We handle commands from left to right and &amp;&amp; doesn&#39;t affect the previous commands, so we can start at &amp;&amp;
            if command:
                for cmd in command.split(&#34;&amp;&amp;&#34;):
                    self.handle_command(cmd)

                self.prompt = self.generate_prompt()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="client.blackhat.shell.Shell"><code class="flex name class">
<span>class <span class="ident">Shell</span></span>
<span>(</span><span>computer: <a title="client.blackhat.computer.Computer" href="computer.html#client.blackhat.computer.Computer">Computer</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A temporary class that takes the place of the user's shell
This will be removed once the GUI is working</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>computer</code></strong> :&ensp;<code>Computer</code></dt>
<dd>The <code>Computer</code> that the given <code><a title="client.blackhat.shell.Shell" href="#client.blackhat.shell.Shell">Shell</a></code> interacts with</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Shell:
    def __init__(self, computer: Computer) -&gt; None:
        &#34;&#34;&#34;
        A temporary class that takes the place of the user&#39;s shell
        This will be removed once the GUI is working

        Args:
            computer (Computer): The `Computer` that the given `Shell` interacts with
        &#34;&#34;&#34;
        self.computer: Computer = computer
        self.ssh_computer = None
        self.prompt: str = self.generate_prompt()

        # Setup tab to auto complete
        readline.parse_and_bind(&#34;tab: complete&#34;)
        readline.set_completer(self.autocomplete)

    def autocomplete(self, text, state):
        bin_dir_result = self.computer.fs.find(&#34;/bin&#34;)

        if bin_dir_result.success:
            commands = list(bin_dir_result.data.files.keys())
        else:
            commands = []

        results = [x for x in commands if x.startswith(text)] + [None]
        return results[state]

    def generate_prompt(self) -&gt; str:
        &#34;&#34;&#34;
        Generate the input prompt for the shell using the Bash PS1 environment variable
        Returns:
            str: The generated/formatted prompt
        &#34;&#34;&#34;
        shell_format = self.computer.sessions[-1].env.get(
            &#34;PS1&#34;) or &#34;\\e[0;31m\\u\\e[0m@\\e[0;32m\\h\\e[0m:\\e[0;34m\\w\\\\e[0m\\$ &#34;
        # Default shell prompt is &lt;USERNAME&gt;@&lt;HOSTNAME&gt;:&lt;WORKING DIR&gt;&lt;$/#&gt;

        # \d   The date, in &#34;Weekday Month Date&#34; format (e.g., &#34;Tue May 26&#34;).
        # \h   The hostname, up to the first .
        # \t   The time, in 24-hour HH:MM:SS format.
        # \T   The time, in 12-hour HH:MM:SS format.
        # \@   The time, in 12-hour am/pm format.
        # \u   The username of the current user.
        # \w   The current working directory.
        # \W   The basename of $PWD.
        # \$   If you are not root, inserts a &#34;$&#34;; if you are root, you get a &#34;#&#34;  (root uid = 0)
        # \e   An escape character (typically a color code).
        # \\   A backslash.

        prompt = shell_format
        prompt = prompt.replace(&#34;\\d&#34;, datetime.now().strftime(&#34;%a %B %d&#34;))
        prompt = prompt.replace(&#34;\\h&#34;, self.computer.hostname)
        prompt = prompt.replace(&#34;\\t&#34;, datetime.now().strftime(&#34;%H:%M:%S&#34;))
        prompt = prompt.replace(&#34;\\T&#34;, datetime.now().strftime(&#34;%I:%M:%S&#34;))
        prompt = prompt.replace(&#34;\\@&#34;, datetime.now().strftime(&#34;%I:%M:%S %p&#34;))
        prompt = prompt.replace(&#34;\\u&#34;, self.computer.lookup_username(self.computer.get_uid()).data)
        prompt = prompt.replace(&#34;\\w&#34;, self.computer.sessions[-1].current_dir.pwd())
        prompt = prompt.replace(&#34;\\W&#34;, self.computer.sessions[-1].current_dir.pwd().split(&#34;/&#34;)[-1] or &#34;/&#34;)
        prompt = prompt.replace(&#34;\\$&#34;, &#34;#&#34; if self.computer.get_uid() == self.computer.users[0] else &#34;$&#34;)
        prompt = prompt.replace(&#34;\\\\&#34;, &#34;\\&#34;)

        prompt = prompt.replace(&#34;\\e[0;31m&#34;, Fore.RED)
        prompt = prompt.replace(&#34;\\e[1;31m&#34;, Fore.LIGHTRED_EX)
        prompt = prompt.replace(&#34;\\e[0;32m&#34;, Fore.GREEN)
        prompt = prompt.replace(&#34;\\e[1;32m&#34;, Fore.LIGHTGREEN_EX)
        prompt = prompt.replace(&#34;\\e[0;33m&#34;, Fore.YELLOW)
        prompt = prompt.replace(&#34;\\e[1;33m&#34;, Fore.LIGHTYELLOW_EX)
        prompt = prompt.replace(&#34;\\e[0;34m&#34;, Fore.BLUE)
        prompt = prompt.replace(&#34;\\e[1;34m&#34;, Fore.LIGHTBLUE_EX)
        prompt = prompt.replace(&#34;\\e[0;35m&#34;, Fore.MAGENTA)
        prompt = prompt.replace(&#34;\\e[1;35m&#34;, Fore.LIGHTMAGENTA_EX)

        prompt = prompt.replace(&#34;\\e[41m&#34;, Back.RED)
        prompt = prompt.replace(&#34;\\e[42m&#34;, Back.GREEN)
        prompt = prompt.replace(&#34;\\e[43m&#34;, Back.YELLOW)
        prompt = prompt.replace(&#34;\\e[44m&#34;, Back.BLUE)
        prompt = prompt.replace(&#34;\\e[45m&#34;, Back.MAGENTA)
        prompt = prompt.replace(&#34;\\e[46m&#34;, Back.LIGHTBLUE_EX)

        # Remove color: \e[0m
        prompt = prompt.replace(&#34;\\e[0m&#34;, Style.RESET_ALL)

        return prompt

    def run_command(self, command: str, args: list, external_binary: bool, pipe: bool):
        &#34;&#34;&#34;
        Determine how to run the given input, then, update the `Shell`&#39;s prompt accordingly

        Args:
            command (str): The name of the command/binary to run
            args (list): The list of arguments passed by the user
            external_binary (bool): Weather or not we&#39;re running a standard system binary or an external binary
            pipe (bool): Weather or not we&#39;re going to pipe the command output to the input of another

        Returns:

        &#34;&#34;&#34;
        if external_binary:
            pass
            # response = self.computer.run_binary(command, args, pipe)
        else:
            response = self.computer.run_command(command, args, pipe)
        self.prompt = self.generate_prompt()
        return response

    def try_run_command(self, command, args, pipe=False):
        external_binary = False
        # Try to flatten the list of args to make one list
        flat_args = []
        flatten = False
        # Only flatten the args if a list exists in the current args
        # TODO: Find a faster way to do this
        for arg in args:
            if type(arg) == list:
                flatten = True
                break

        if flatten:
            for sublist in args:
                for item in sublist:
                    flat_args.append(item)
        else:
            flat_args = args

        # Check if the command is an external binary (external from /bin)
        if command.startswith(&#34;./&#34;):
            # External binaries that are not in the /bin dir
            # Remove the ./ to pass to the computer object
            command = command.replace(&#34;./&#34;, &#34;&#34;)
            external_binary = True

        try:
            result = self.run_command(command, flat_args, external_binary, pipe)
            if result.success:
                return result.data
            else:
                return False
        except IndexError as e:
            print(e)
            print(&#34;error running command&#34;)

    def handle_command(self, command):
        &#34;&#34;&#34;
        Handle the raw input from the user
        Parse out the args and special characters (|, &gt;, &gt;&gt;, etc)
        Determine how to route input and output between commands

        Args:
            command (str): The raw input entered by the user

        Returns:

        &#34;&#34;&#34;
        # Technically, the first element in our command should be the command name
        # And we can keep going through the
        command = command.split()
        # Filter!
        while &#34;&#34; in command:
            command.remove(&#34;&#34;)
        command_name = command[0]
        # Delete the command name from the command list (since we already have it)
        del command[0]

        # Easy cases if there are no special characters
        if &#34;|&#34; not in command and &#34;&gt;&#34; not in command and &#34;&gt;&gt;&#34; not in command:
            # We only pass &#34;command&#34; because we already removed the initial command name (and saved it)
            self.try_run_command(command_name, command, False)
        else:
            prev_command_result = None
            while True:
                for arg in command:
                    # Check if the current arg is | &gt; or &gt;&gt; (because we do something different here)
                    if arg in [&#34;|&#34;, &#34;&gt;&#34;, &#34;&gt;&gt;&#34;]:
                        current_index = command.index(arg)
                        # Find the special character (|/&gt;/&gt;&gt;) and decide what to do with it later
                        special_character = command[current_index]
                        break
                else:
                    # Run the last command and output
                    if len(command) == 0:
                        self.try_run_command(command_name, prev_command_result, False)
                    break

                current_args = command[0:current_index]

                if prev_command_result:
                    if type(prev_command_result) == list:
                        command_result = self.try_run_command(command_name,
                                                              current_args + prev_command_result, True)
                    else:
                        command_result = self.try_run_command(command_name,
                                                              current_args + [prev_command_result], True)
                else:
                    command_result = self.try_run_command(command_name, current_args, True)
                # Remove everything up to the current index (including the special character) (for the next cycle)
                del command[0:current_index + 1]

                # Don&#39;t even bother running if the command failed
                if command_result:
                    # If the special character is &gt; (write output) or &gt;&gt; (append output)
                    # We expect the next character in the command to be the file to write/append to
                    if special_character in [&#34;&gt;&#34;, &#34;&gt;&gt;&#34;]:
                        # We expect the next item after the &gt; to be the file to write/append to
                        filename_to_write_to = command[0]
                        # We need to try to remove extra spaces from the given filename
                        filename_to_write_to = filename_to_write_to.replace(&#34; &#34;, &#34;&#34;)

                        # Find the file that we should write the output to
                        find_response = self.computer.fs.find(filename_to_write_to)
                        if not find_response.success:
                            # This runs if the file doesn&#39;t exist (we need to create it)
                            find_response = self.computer.fs.find(&#34;/&#34;.join(filename_to_write_to.split(&#34;/&#34;)[:-1]))
                            if not find_response.success:
                                print(f&#34;shell: no such file or directory: {filename_to_write_to}&#34;)
                            else:
                                # Create the new file
                                # We&#39;re using a syscall because it handles permissions (so we dont have to)
                                create_file_response = self.run_command(&#34;touch&#34;, [filename_to_write_to], False, True)
                                if not create_file_response.success:
                                    print(f&#34;shell: unable to create file: {filename_to_write_to}&#34;)
                                    continue
                                else:
                                    file_to_write = self.computer.fs.find(filename_to_write_to).data
                        else:
                            file_to_write = find_response

                        message_to_write = command_result
                        if message_to_write.startswith(&#39;&#34;&#39;) and message_to_write.endswith(&#39;&#34;&#39;):
                            message_to_write = message_to_write[1:-1]

                        # Since the rest of the code for the &gt; and &gt;&gt; is the same up until this point
                        # We don&#39;t need to re-write it
                        if special_character == &#34;&gt;&#34;:
                            file_to_write.write(self.computer.get_uid(),
                                                message_to_write)
                        elif special_character == &#34;&gt;&gt;&#34;:
                            file_to_write.append(self.computer.get_uid(),
                                                 message_to_write)

                        prev_command_result = None
                    # Pass the input of the previous command to the current command
                    elif special_character == &#34;|&#34;:
                        prev_command_result = command_result
                        prev_command_result = prev_command_result.split()
                        command_name = command[0]
                        del command[0]

    def main(self):
        &#34;&#34;&#34;
        Run the main input loop

        Returns:
            None
        &#34;&#34;&#34;
        self.prompt = self.generate_prompt()
        while True:
            command = input(self.prompt)

            # We handle commands from left to right and &amp;&amp; doesn&#39;t affect the previous commands, so we can start at &amp;&amp;
            if command:
                for cmd in command.split(&#34;&amp;&amp;&#34;):
                    self.handle_command(cmd)

                self.prompt = self.generate_prompt()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="client.blackhat.shell.Shell.autocomplete"><code class="name flex">
<span>def <span class="ident">autocomplete</span></span>(<span>self, text, state)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def autocomplete(self, text, state):
    bin_dir_result = self.computer.fs.find(&#34;/bin&#34;)

    if bin_dir_result.success:
        commands = list(bin_dir_result.data.files.keys())
    else:
        commands = []

    results = [x for x in commands if x.startswith(text)] + [None]
    return results[state]</code></pre>
</details>
</dd>
<dt id="client.blackhat.shell.Shell.generate_prompt"><code class="name flex">
<span>def <span class="ident">generate_prompt</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the input prompt for the shell using the Bash PS1 environment variable</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The generated/formatted prompt</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_prompt(self) -&gt; str:
    &#34;&#34;&#34;
    Generate the input prompt for the shell using the Bash PS1 environment variable
    Returns:
        str: The generated/formatted prompt
    &#34;&#34;&#34;
    shell_format = self.computer.sessions[-1].env.get(
        &#34;PS1&#34;) or &#34;\\e[0;31m\\u\\e[0m@\\e[0;32m\\h\\e[0m:\\e[0;34m\\w\\\\e[0m\\$ &#34;
    # Default shell prompt is &lt;USERNAME&gt;@&lt;HOSTNAME&gt;:&lt;WORKING DIR&gt;&lt;$/#&gt;

    # \d   The date, in &#34;Weekday Month Date&#34; format (e.g., &#34;Tue May 26&#34;).
    # \h   The hostname, up to the first .
    # \t   The time, in 24-hour HH:MM:SS format.
    # \T   The time, in 12-hour HH:MM:SS format.
    # \@   The time, in 12-hour am/pm format.
    # \u   The username of the current user.
    # \w   The current working directory.
    # \W   The basename of $PWD.
    # \$   If you are not root, inserts a &#34;$&#34;; if you are root, you get a &#34;#&#34;  (root uid = 0)
    # \e   An escape character (typically a color code).
    # \\   A backslash.

    prompt = shell_format
    prompt = prompt.replace(&#34;\\d&#34;, datetime.now().strftime(&#34;%a %B %d&#34;))
    prompt = prompt.replace(&#34;\\h&#34;, self.computer.hostname)
    prompt = prompt.replace(&#34;\\t&#34;, datetime.now().strftime(&#34;%H:%M:%S&#34;))
    prompt = prompt.replace(&#34;\\T&#34;, datetime.now().strftime(&#34;%I:%M:%S&#34;))
    prompt = prompt.replace(&#34;\\@&#34;, datetime.now().strftime(&#34;%I:%M:%S %p&#34;))
    prompt = prompt.replace(&#34;\\u&#34;, self.computer.lookup_username(self.computer.get_uid()).data)
    prompt = prompt.replace(&#34;\\w&#34;, self.computer.sessions[-1].current_dir.pwd())
    prompt = prompt.replace(&#34;\\W&#34;, self.computer.sessions[-1].current_dir.pwd().split(&#34;/&#34;)[-1] or &#34;/&#34;)
    prompt = prompt.replace(&#34;\\$&#34;, &#34;#&#34; if self.computer.get_uid() == self.computer.users[0] else &#34;$&#34;)
    prompt = prompt.replace(&#34;\\\\&#34;, &#34;\\&#34;)

    prompt = prompt.replace(&#34;\\e[0;31m&#34;, Fore.RED)
    prompt = prompt.replace(&#34;\\e[1;31m&#34;, Fore.LIGHTRED_EX)
    prompt = prompt.replace(&#34;\\e[0;32m&#34;, Fore.GREEN)
    prompt = prompt.replace(&#34;\\e[1;32m&#34;, Fore.LIGHTGREEN_EX)
    prompt = prompt.replace(&#34;\\e[0;33m&#34;, Fore.YELLOW)
    prompt = prompt.replace(&#34;\\e[1;33m&#34;, Fore.LIGHTYELLOW_EX)
    prompt = prompt.replace(&#34;\\e[0;34m&#34;, Fore.BLUE)
    prompt = prompt.replace(&#34;\\e[1;34m&#34;, Fore.LIGHTBLUE_EX)
    prompt = prompt.replace(&#34;\\e[0;35m&#34;, Fore.MAGENTA)
    prompt = prompt.replace(&#34;\\e[1;35m&#34;, Fore.LIGHTMAGENTA_EX)

    prompt = prompt.replace(&#34;\\e[41m&#34;, Back.RED)
    prompt = prompt.replace(&#34;\\e[42m&#34;, Back.GREEN)
    prompt = prompt.replace(&#34;\\e[43m&#34;, Back.YELLOW)
    prompt = prompt.replace(&#34;\\e[44m&#34;, Back.BLUE)
    prompt = prompt.replace(&#34;\\e[45m&#34;, Back.MAGENTA)
    prompt = prompt.replace(&#34;\\e[46m&#34;, Back.LIGHTBLUE_EX)

    # Remove color: \e[0m
    prompt = prompt.replace(&#34;\\e[0m&#34;, Style.RESET_ALL)

    return prompt</code></pre>
</details>
</dd>
<dt id="client.blackhat.shell.Shell.handle_command"><code class="name flex">
<span>def <span class="ident">handle_command</span></span>(<span>self, command)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle the raw input from the user
Parse out the args and special characters (|, &gt;, &gt;&gt;, etc)
Determine how to route input and output between commands</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw input entered by the user</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_command(self, command):
    &#34;&#34;&#34;
    Handle the raw input from the user
    Parse out the args and special characters (|, &gt;, &gt;&gt;, etc)
    Determine how to route input and output between commands

    Args:
        command (str): The raw input entered by the user

    Returns:

    &#34;&#34;&#34;
    # Technically, the first element in our command should be the command name
    # And we can keep going through the
    command = command.split()
    # Filter!
    while &#34;&#34; in command:
        command.remove(&#34;&#34;)
    command_name = command[0]
    # Delete the command name from the command list (since we already have it)
    del command[0]

    # Easy cases if there are no special characters
    if &#34;|&#34; not in command and &#34;&gt;&#34; not in command and &#34;&gt;&gt;&#34; not in command:
        # We only pass &#34;command&#34; because we already removed the initial command name (and saved it)
        self.try_run_command(command_name, command, False)
    else:
        prev_command_result = None
        while True:
            for arg in command:
                # Check if the current arg is | &gt; or &gt;&gt; (because we do something different here)
                if arg in [&#34;|&#34;, &#34;&gt;&#34;, &#34;&gt;&gt;&#34;]:
                    current_index = command.index(arg)
                    # Find the special character (|/&gt;/&gt;&gt;) and decide what to do with it later
                    special_character = command[current_index]
                    break
            else:
                # Run the last command and output
                if len(command) == 0:
                    self.try_run_command(command_name, prev_command_result, False)
                break

            current_args = command[0:current_index]

            if prev_command_result:
                if type(prev_command_result) == list:
                    command_result = self.try_run_command(command_name,
                                                          current_args + prev_command_result, True)
                else:
                    command_result = self.try_run_command(command_name,
                                                          current_args + [prev_command_result], True)
            else:
                command_result = self.try_run_command(command_name, current_args, True)
            # Remove everything up to the current index (including the special character) (for the next cycle)
            del command[0:current_index + 1]

            # Don&#39;t even bother running if the command failed
            if command_result:
                # If the special character is &gt; (write output) or &gt;&gt; (append output)
                # We expect the next character in the command to be the file to write/append to
                if special_character in [&#34;&gt;&#34;, &#34;&gt;&gt;&#34;]:
                    # We expect the next item after the &gt; to be the file to write/append to
                    filename_to_write_to = command[0]
                    # We need to try to remove extra spaces from the given filename
                    filename_to_write_to = filename_to_write_to.replace(&#34; &#34;, &#34;&#34;)

                    # Find the file that we should write the output to
                    find_response = self.computer.fs.find(filename_to_write_to)
                    if not find_response.success:
                        # This runs if the file doesn&#39;t exist (we need to create it)
                        find_response = self.computer.fs.find(&#34;/&#34;.join(filename_to_write_to.split(&#34;/&#34;)[:-1]))
                        if not find_response.success:
                            print(f&#34;shell: no such file or directory: {filename_to_write_to}&#34;)
                        else:
                            # Create the new file
                            # We&#39;re using a syscall because it handles permissions (so we dont have to)
                            create_file_response = self.run_command(&#34;touch&#34;, [filename_to_write_to], False, True)
                            if not create_file_response.success:
                                print(f&#34;shell: unable to create file: {filename_to_write_to}&#34;)
                                continue
                            else:
                                file_to_write = self.computer.fs.find(filename_to_write_to).data
                    else:
                        file_to_write = find_response

                    message_to_write = command_result
                    if message_to_write.startswith(&#39;&#34;&#39;) and message_to_write.endswith(&#39;&#34;&#39;):
                        message_to_write = message_to_write[1:-1]

                    # Since the rest of the code for the &gt; and &gt;&gt; is the same up until this point
                    # We don&#39;t need to re-write it
                    if special_character == &#34;&gt;&#34;:
                        file_to_write.write(self.computer.get_uid(),
                                            message_to_write)
                    elif special_character == &#34;&gt;&gt;&#34;:
                        file_to_write.append(self.computer.get_uid(),
                                             message_to_write)

                    prev_command_result = None
                # Pass the input of the previous command to the current command
                elif special_character == &#34;|&#34;:
                    prev_command_result = command_result
                    prev_command_result = prev_command_result.split()
                    command_name = command[0]
                    del command[0]</code></pre>
</details>
</dd>
<dt id="client.blackhat.shell.Shell.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the main input loop</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(self):
    &#34;&#34;&#34;
    Run the main input loop

    Returns:
        None
    &#34;&#34;&#34;
    self.prompt = self.generate_prompt()
    while True:
        command = input(self.prompt)

        # We handle commands from left to right and &amp;&amp; doesn&#39;t affect the previous commands, so we can start at &amp;&amp;
        if command:
            for cmd in command.split(&#34;&amp;&amp;&#34;):
                self.handle_command(cmd)

            self.prompt = self.generate_prompt()</code></pre>
</details>
</dd>
<dt id="client.blackhat.shell.Shell.run_command"><code class="name flex">
<span>def <span class="ident">run_command</span></span>(<span>self, command: str, args: list, external_binary: bool, pipe: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine how to run the given input, then, update the <code><a title="client.blackhat.shell.Shell" href="#client.blackhat.shell.Shell">Shell</a></code>'s prompt accordingly</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the command/binary to run</dd>
<dt><strong><code>args</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of arguments passed by the user</dd>
<dt><strong><code>external_binary</code></strong> :&ensp;<code>bool</code></dt>
<dd>Weather or not we're running a standard system binary or an external binary</dd>
<dt><strong><code>pipe</code></strong> :&ensp;<code>bool</code></dt>
<dd>Weather or not we're going to pipe the command output to the input of another</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_command(self, command: str, args: list, external_binary: bool, pipe: bool):
    &#34;&#34;&#34;
    Determine how to run the given input, then, update the `Shell`&#39;s prompt accordingly

    Args:
        command (str): The name of the command/binary to run
        args (list): The list of arguments passed by the user
        external_binary (bool): Weather or not we&#39;re running a standard system binary or an external binary
        pipe (bool): Weather or not we&#39;re going to pipe the command output to the input of another

    Returns:

    &#34;&#34;&#34;
    if external_binary:
        pass
        # response = self.computer.run_binary(command, args, pipe)
    else:
        response = self.computer.run_command(command, args, pipe)
    self.prompt = self.generate_prompt()
    return response</code></pre>
</details>
</dd>
<dt id="client.blackhat.shell.Shell.try_run_command"><code class="name flex">
<span>def <span class="ident">try_run_command</span></span>(<span>self, command, args, pipe=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_run_command(self, command, args, pipe=False):
    external_binary = False
    # Try to flatten the list of args to make one list
    flat_args = []
    flatten = False
    # Only flatten the args if a list exists in the current args
    # TODO: Find a faster way to do this
    for arg in args:
        if type(arg) == list:
            flatten = True
            break

    if flatten:
        for sublist in args:
            for item in sublist:
                flat_args.append(item)
    else:
        flat_args = args

    # Check if the command is an external binary (external from /bin)
    if command.startswith(&#34;./&#34;):
        # External binaries that are not in the /bin dir
        # Remove the ./ to pass to the computer object
        command = command.replace(&#34;./&#34;, &#34;&#34;)
        external_binary = True

    try:
        result = self.run_command(command, flat_args, external_binary, pipe)
        if result.success:
            return result.data
        else:
            return False
    except IndexError as e:
        print(e)
        print(&#34;error running command&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="client.blackhat" href="index.html">client.blackhat</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="client.blackhat.shell.Shell" href="#client.blackhat.shell.Shell">Shell</a></code></h4>
<ul class="two-column">
<li><code><a title="client.blackhat.shell.Shell.autocomplete" href="#client.blackhat.shell.Shell.autocomplete">autocomplete</a></code></li>
<li><code><a title="client.blackhat.shell.Shell.generate_prompt" href="#client.blackhat.shell.Shell.generate_prompt">generate_prompt</a></code></li>
<li><code><a title="client.blackhat.shell.Shell.handle_command" href="#client.blackhat.shell.Shell.handle_command">handle_command</a></code></li>
<li><code><a title="client.blackhat.shell.Shell.main" href="#client.blackhat.shell.Shell.main">main</a></code></li>
<li><code><a title="client.blackhat.shell.Shell.run_command" href="#client.blackhat.shell.Shell.run_command">run_command</a></code></li>
<li><code><a title="client.blackhat.shell.Shell.try_run_command" href="#client.blackhat.shell.Shell.try_run_command">try_run_command</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>