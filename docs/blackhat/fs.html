<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>blackhat.fs API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>blackhat.fs</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import datetime
import importlib
import os
import sys
from random import choice
from string import ascii_uppercase, digits
from typing import Optional, Dict, List, Literal, Union, Callable

from colorama import Style

from .helpers import Result, ResultMessages

event_types = Literal[&#34;read&#34;, &#34;write&#34;, &#34;move&#34;, &#34;change_perm&#34;, &#34;change_owner&#34;, &#34;delete&#34;]


class FSBaseObject:
    def __init__(self, name: str, parent: Optional[&#34;Directory&#34;], owner: int, group_owner: int) -&gt; None:
        &#34;&#34;&#34;
        The base object that contains info shared between `Directories` and `Files`

        Args:
            name (str): The name of the `File`/`Directory`
            parent (Directory): The `Directory` one level up the tree
            owner (int): The UID of the owner of the `File`/`Directory`
            group_owner (int): The GID of the owner of the `File`/`Directory`
        &#34;&#34;&#34;
        self.name: str = name
        self.permissions: Dict[str, List[Literal[&#34;read&#34;, &#34;write&#34;, &#34;execute&#34;]]] = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;],
                                                                                  &#34;write&#34;: [&#34;owner&#34;],
                                                                                  &#34;execute&#34;: []}
        # TODO: Handle setuid bit on directories
        &#34;&#34;&#34;
        Reference:
        
        27.5 Directories and the Set-User-ID and Set-Group-ID Bits

        On most systems, if a directory’s set-group-ID bit is set, newly created subfiles inherit the same group as the directory, and newly created subdirectories inherit the set-group-ID bit of the parent directory. On a few systems, a directory’s set-user-ID bit has a similar effect on the ownership of new subfiles and the set-user-ID bits of new subdirectories. These mechanisms let users share files more easily, by lessening the need to use chmod or chown to share new files.
        
        (https://www.gnu.org/software/coreutils/manual/html_node/Directory-Setuid-and-Setgid.html)
        &#34;&#34;&#34;
        self.setuid = False
        &#34;&#34;&#34;Permissions for accessing the file. Default permissions; rw-r--r-- (644)&#34;&#34;&#34;
        self.parent: Optional[&#34;Directory&#34;] = parent
        self.owner: int = owner
        self.group_owner: int = group_owner
        self.link_count: int
        self.size: int  # Size in bytes
        self.atime: int  # Last access time (unix time stamp)
        &#34;&#34;&#34;int: Access time; when file was last read from/accessed&#34;&#34;&#34;
        self.mtime: int  # Last modified time (unix time stamp)
        &#34;&#34;&#34;int: Modified time; when the file&#34;s content was last modified&#34;&#34;&#34;
        self.ctime: int  # Last file status change (unix time stamp)
        &#34;&#34;&#34;int: Changed time; when the file&#34;s metadata was last changed (ex. perms)&#34;&#34;&#34;
        self.events: Dict[event_types, Callable] = {}

    def is_directory(self) -&gt; bool:
        &#34;&#34;&#34;
        Determines if a given item is a `Directory`

        Returns:
            bool: `True` if the given item is a `Directory` otherwise `False`
        &#34;&#34;&#34;
        return type(self) == Directory

    def is_file(self) -&gt; bool:
        &#34;&#34;&#34;
        Determines if a given item is a `File`

        Returns:
            bool: `True` if the given item is a `File` otherwise `False`
        &#34;&#34;&#34;
        return type(self) == File

    def check_perm(self, perm: Literal[&#34;read&#34;, &#34;write&#34;, &#34;execute&#34;], computer) -&gt; Result:
        &#34;&#34;&#34;
        Checks if the current user has the given `perm`

        Args:
            perm (str): The permission to check (&#34;read&#34;, &#34;write&#34;, &#34;execute&#34;)
            computer: The current `Computer` instance

        Returns:
            Result: A `Result` object with the `success` flag set accordingly
        &#34;&#34;&#34;
        # If we&#34;re root (UID 0), return True because root has all permissions
        if computer.sys_geteuid() == 0:
            return Result(success=True)
        # If &#34;public&#34;, don&#34;t bother checking anything else
        if &#34;public&#34; in self.permissions[perm]:
            return Result(success=True)

        if &#34;group&#34; in self.permissions[perm]:
            if self.group_owner in computer.get_user_groups(computer.sys_geteuid()).data:
                return Result(success=True)

        if &#34;owner&#34; in self.permissions[perm]:
            if self.owner == computer.sys_geteuid():
                return Result(success=True)

        # No permission
        return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    def check_owner(self, computer) -&gt; Result:
        &#34;&#34;&#34;
        Checks if the given UID or GID is one of the owners (for chmod/chgrp/etc)

        Args:
            computer: The current `Computer` instance

        Returns:
            Result: A `Result` object with the `success` flag set accordingly
        &#34;&#34;&#34;
        # Get the list of user&#39;s groups
        groups = computer.get_user_groups(computer.sys_getuid()).data

        if self.owner == computer.sys_getuid() or self.group_owner in groups:
            return Result(success=True)
        else:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    def change_owner(self, computer, new_user_owner: Optional[int] = None,
                     new_group_owner: Optional[int] = None) -&gt; Result:
        &#34;&#34;&#34;
        Change the owner (user and/or group) of a given `File`/`Directory`, but check if the given UID should be allowed to first

        Args:
            computer: The current `Computer` instance
            new_user_owner (int): The UID of the new owner (user) of the `File`/`Directory`
            new_group_owner (int): The GID of the new owner (group) of the `File`/`Directory`

        Returns:
            Result: A `Result` with the `success` flag set accordingly
        &#34;&#34;&#34;
        caller_groups = computer.get_user_groups(computer.sys_getuid()).data
        # Check if the owner or group owner is correct or if we&#39;re root
        if computer.sys_geteuid() == self.owner or self.group_owner in caller_groups or computer.sys_geteuid() == 0:
            # We need at least one of the two params (uid/gid)
            # Using `if not new_user_owner/not new_group_owner` won&#39;t work because `not 0` (root group) == True (???)
            if new_user_owner is None and new_group_owner is None:
                return Result(success=False, message=ResultMessages.MISSING_ARGUMENT)
            else:
                # Same thing with uid 0
                if new_user_owner is not None:
                    # Confirm that the user exists
                    if computer.get_user(uid=new_user_owner).success:
                        self.owner = new_user_owner
                    else:
                        return Result(success=False, message=ResultMessages.NOT_FOUND)

                # Confirm that the new group exists
                # Same thing with gid 0
                if new_group_owner is not None:
                    # Confirm that the user exists
                    if computer.get_group(gid=new_group_owner).success:
                        self.group_owner = new_group_owner
                    else:
                        return Result(success=False, message=ResultMessages.NOT_FOUND)

                self.handle_event(&#34;change_owner&#34;)
                return Result(success=True)
        else:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    def pwd(self) -&gt; str:
        &#34;&#34;&#34;
        Get the full path of the `File` in the file system

        Returns:
            str: A complete file path starting at / (root)
        &#34;&#34;&#34;
        current_dir = self
        working_dir = []

        while True:
            # Check if we&#39;re at /
            working_dir.append(current_dir.name)
            if not current_dir.parent:
                break
            current_dir = current_dir.parent

        working_dir.reverse()
        working_dir = &#34;/&#34;.join(working_dir)
        # Try to remove double slash
        if working_dir.startswith(&#34;//&#34;):
            working_dir = working_dir[1:]

        return working_dir

    def delete(self, computer) -&gt; Result:
        &#34;&#34;&#34;
        Check if the `caller` has the proper permissions to delete a given file, then remove it

        Args:
            computer: The current computer object

        Returns:
            Result: A `Result` object with the `success` flag set accordingly
        &#34;&#34;&#34;
        if self.parent:
            # In unix, we need read+write permissions to delete
            if self.check_perm(&#34;read&#34;, computer).success and self.check_perm(&#34;write&#34;, computer).success:
                self.handle_event(&#34;delete&#34;)
                del self.parent.files[self.name]
                return Result(success=True)
            else:
                return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    def add_event_listener(self, event: event_types, function: Callable, when: Literal[&#34;before&#34;, &#34;after&#34;] = &#34;after&#34;):
        &#34;&#34;&#34;
        Bind a function to run whenever a given event fires.
        A `FSBaseObject` can only have one function per event type.
        If a function is already bound to the given event type, it will be overwritten.

        Args:
            event: The given event type to bind the given `function` to.
            Valid event types include: `read`, `write`, `move`, `perm`, `delete`
            &lt;ul&gt;
                &lt;li&gt;read - When a file is read from&lt;/li&gt;
                &lt;li&gt;write - When a file is written to&lt;/li&gt;
                &lt;li&gt;move - When a file is moved to a different location AKA: When a file&#39;s parent folder changes&lt;/li&gt;
                &lt;li&gt;perm - When a file&#39;s owner, group owner, or permissions changes&lt;/li&gt;
                &lt;li&gt;delete - Before a file is deleted&lt;/li&gt;
            &lt;/ul&gt;
            function: The function/method to be called when the given `event` is fired
            when (str): When the event is fired (for example, before the read happens, or after)

        Returns:
             Result: A `Result` with the `success` flag set accordingly.
        &#34;&#34;&#34;
        self.events[event] = function
        return Result(success=True)

    def remove_event_listener(self, event: event_types):
        &#34;&#34;&#34;
        Unbinds the current function from the given `event` type

        Args:
            event: The event type to unbind. Valid event types include: `read`, `write`, `move`, `perm`, `delete`

        Returns:
             Result: A `Result` with the `success` flag set accordingly.
        &#34;&#34;&#34;
        try:
            self.events.pop(event)
        except Exception:
            pass

        return Result(success=True)

    def handle_event(self, event: event_types):
        &#34;&#34;&#34;
        Handles executing the function bound to the given `event`

        Args:
            event: The event type to run. Valid event types include: `read`, `write`, `move`, `perm`, `delete`

        Returns:
             Result: A `Result` with the `success` flag set accordingly.
        &#34;&#34;&#34;
        if event in self.events.keys():
            self.events[event](self)

        return Result(success=True)


class File(FSBaseObject):
    def __init__(self, name: str, content: str, parent: &#34;Directory&#34;, owner: int, group_owner: int) -&gt; None:
        &#34;&#34;&#34;
        The class object representing a file in the file system

        Args:
            name (str): The name of the given `File`
            content (str): The content within the given file. May be blank (empty string)
            parent (Directory): The `Directory` one level up the tree
            owner (int): The UID of the owner of the `File`/`Directory`
            group_owner (int): The GID of the owner of the `File`/`Directory
        &#34;&#34;&#34;
        super().__init__(name, parent, owner, group_owner)
        self.content = content
        self.size = sys.getsizeof(self.name + self.content)

        if self.parent:
            self.parent.add_file(self)

    def read(self, computer) -&gt; Result:
        &#34;&#34;&#34;
        Check if the current UID has permission to read the content of the file. Afterwards, return the content if allowed

        Args:
            computer: The current `Computer` instance

        Returns: Result: A `Result` object with the `success` flag set and the `data` flag set with the  file&#39;s content if permitted
        &#34;&#34;&#34;
        if self.check_perm(&#34;read&#34;, computer).success:
            self.handle_event(&#34;read&#34;)
            return Result(success=True, data=self.content)
        else:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    def write(self, data: str, computer) -&gt; Result:
        &#34;&#34;&#34;
        Check if the current UID has permission to write to the file. Update the file&#39;s contents if allowed

        Args:
            data (str): The new content to write to the `File`
            computer: The current `Computer` instance

        Returns:
            Result: A `Result` object with the `success` flag accordingly
        &#34;&#34;&#34;
        if self.check_perm(&#34;write&#34;, computer).success:
            self.content = data
            self.update_size()
            self.handle_event(&#34;write&#34;)
            return Result(success=True)
        else:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    def append(self, data: str, computer) -&gt; Result:
        &#34;&#34;&#34;
        Check if the current UID has permission to write to the file. Append to the file&#39;s contents if allowed

        Args:
            data (str): The content to append to the `File`s current content
            computer: The current `Computer` instance

        Returns:
            Result: A `Result` object with the `success` flag accordingly
        &#34;&#34;&#34;
        # NOTE: This may be unnecessary, we&#34;ll find out later
        if self.check_perm(&#34;write&#34;, computer).success:
            self.content += data
            self.update_size()
            self.handle_event(&#34;write&#34;)
            return Result(success=True)
        else:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    def update_size(self) -&gt; None:
        &#34;&#34;&#34;
        Calculates the size of the `File` and set in the object.
        Also, recursively tells it&#39;s parent to update its size.

        Returns:
            None
        &#34;&#34;&#34;
        self.size = sys.getsizeof(self.name + self.content)

        # First, update our own size
        self.size = sys.getsizeof(self.content + self.name)
        # Now, recursively update our parent&#34;s size
        if self.parent:
            self.parent.update_size()

    def get_perm_octal(self):
        result = 0o000

        # TODO: Find a less shit way to do this
        # Owner
        if &#34;owner&#34; in self.permissions[&#34;read&#34;]:
            result += 0o400

        if &#34;owner&#34; in self.permissions[&#34;write&#34;]:
            result += 0o200

        if &#34;owner&#34; in self.permissions[&#34;execute&#34;]:
            result += 0o100

        # Group
        if &#34;group&#34; in self.permissions[&#34;read&#34;]:
            result += 0o040

        if &#34;group&#34; in self.permissions[&#34;write&#34;]:
            result += 0o020

        if &#34;group&#34; in self.permissions[&#34;execute&#34;]:
            result += 0o010

        # Public
        if &#34;public&#34; in self.permissions[&#34;read&#34;]:
            result += 0o004

        if &#34;public&#34; in self.permissions[&#34;write&#34;]:
            result += 0o002

        if &#34;public&#34; in self.permissions[&#34;execute&#34;]:
            result += 0o001

        return result

    def __str__(self):
        return f&#34;{self.name} - {self.owner}&#34;


class Directory(FSBaseObject):
    def __init__(self, name: str, parent: Optional[&#34;Directory&#34;], owner: int, group_owner: int):
        &#34;&#34;&#34;
        The class object representing a directory within the file system

        Args:
            name (str): The name of the `File`/`Directory`
            parent (Directory): The `Directory` one level up the tree
            owner (int): The UID of the owner of the `File`/`Directory`
            group_owner (int): The GID of the owner of the `File`/`Directory`
        &#34;&#34;&#34;
        super().__init__(name, parent, owner, group_owner)
        self.files = {}
        self.size = None
        # The default perms for directories are different from files
        self.permissions = {
            &#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;],
            &#34;write&#34;: [&#34;owner&#34;],
            &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;],
        }

        if parent:
            parent.add_file(self)

        self.update_size()

    def add_file(self, file: Union[File, &#34;Directory&#34;]) -&gt; Result:
        &#34;&#34;&#34;
        Add a new `File` or `Directory` to self&#39;s internal file map
        Also updates its size and triggers its parent to update their size

        Args:
            file (File/Directory): The `File`/`Directory` to add to self

        Returns:
            Result: A `Result` with the `success` flag set accordingly
        &#34;&#34;&#34;
        if file.name in self.files.keys():
            return Result(success=False, message=ResultMessages.ALREADY_EXISTS)

        self.files[file.name] = file
        self.update_size()

        self.handle_event(&#34;write&#34;)

        return Result(success=True)

    def calculate_size(self) -&gt; int:
        &#34;&#34;&#34;
        Calculate a total size for the given directory and (recursively) all its children (`File`(s)/`Directory`(ies))

        Returns:
            int: The total size (in bytes) of the given directory
        &#34;&#34;&#34;
        total = 0

        for file in self.files.values():
            if file.is_directory():
                # Recursive
                total += file.calculate_size()
            else:
                if file.size:
                    total += file.size

        return total

    def find(self, filename: str) -&gt; Optional[Union[File, &#34;Directory&#34;]]:
        &#34;&#34;&#34;
        Find a `File` or `Directory` in self&#39;s internal file map

        Args:
            filename (str): The name of the `File`/`Directory` to find

        Returns:
            File or Directory or None: The `File` or `Directory` object if found, otherwise, None
        &#34;&#34;&#34;
        return self.files.get(filename, None)

    def update_size(self) -&gt; None:
        &#34;&#34;&#34;
        Update self&#39;s size using `calculate_size()` then, triggers self&#39;s parent to update their size

        Returns:
            None
        &#34;&#34;&#34;
        self.size = self.calculate_size()

        # This does the same as the file update size. Updates its own size
        # Then the parent updates its size, taking into account self&#39;s new size
        # Like a chain until all parent folders have been updated

        if self.parent:
            self.parent.update_size()


class StandardFS:
    def __init__(self, computer) -&gt; None:
        &#34;&#34;&#34;
        The class object representing a file system that belongs to a `Computer`

        Args:
            computer (Computer): The `Computer` that the given file system belongs to
        &#34;&#34;&#34;
        self.computer = computer

        # The filesystem root (/) (owned by root)
        self.files = Directory(&#34;/&#34;, None, 0, 0)
        self.files.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;],
                                  &#34;write&#34;: [&#34;owner&#34;, &#34;group&#34;],
                                  &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}

        self.init()

    def init(self) -&gt; None:
        &#34;&#34;&#34;
        All the functions required to setup a new filesystem

        Returns:
            None
        &#34;&#34;&#34;
        # Setup the directory structure in the file system (Unix FHS)
        for dir in [&#34;bin&#34;, &#34;etc&#34;, &#34;home&#34;, &#34;lib&#34;, &#34;root&#34;, &#34;run&#34;, &#34;proc&#34;, &#34;tmp&#34;, &#34;usr&#34;, &#34;var&#34;]:
            directory = Directory(dir, self.files, 0, 0)
            # Special case for /tmp (read and write by everyone)
            if dir == &#34;tmp&#34;:
                directory.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;],
                                         &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}
            elif dir == &#34;proc&#34;:
                directory.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [],
                                         &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}
            else:
                # TODO: Change this to be more accurate
                # (rwx rw- r--)
                directory.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;, &#34;group&#34;],
                                         &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}

        # TODO: Replace all these with `mkdir -p` commands
        # NOTE: FS doesn&#39;t exist at this point so running commands might not be possible (since some commands need fs)
        # Individually setup each directory in the root
        self.setup_bin()
        self.setup_etc()
        # self.setup_home()
        # self.setup_lib()
        self.setup_proc()
        self.setup_root()
        self.setup_run()
        # self.setup_tmp()
        self.setup_usr()
        self.setup_var()

    def setup_bin(self) -&gt; None:
        &#34;&#34;&#34;
        Read all the files in the `client.blackhat.bin` directory and create a virtual file in the fs.
        All these files represent binaries in the system

        Returns:
            None
        &#34;&#34;&#34;
        bin_dir: Directory = self.files.find(&#34;bin&#34;)

        for file in os.listdir(&#34;./blackhat/bin&#34;):
            # Ignore the __init__.py and __pycache__ because those aren&#39;t bins (auto generated)
            if file not in [&#34;__init__.py&#34;, &#34;__pycache__&#34;, &#34;installable&#34;]:
                with open(os.path.join(&#34;./blackhat/bin&#34;, file), &#34;r&#34;) as f:
                    source_code = f.read()
                current_file = File(file.replace(&#34;.py&#34;, &#34;&#34;), source_code, bin_dir, 0, 0)
                current_file.size = os.path.getsize(os.path.join(&#34;./blackhat/bin&#34;, file))

                current_file.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;],
                                            &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}
                # Add setuid bit to specific binaries
                if file.replace(&#34;.py&#34;, &#34;&#34;) in [&#34;sudo&#34;, &#34;su&#34;, &#34;passwd&#34;]:
                    current_file.setuid = True

    def setup_etc(self) -&gt; None:
        &#34;&#34;&#34;
        Sets up:
        &lt;ul&gt;
            &lt;li&gt;/etc/passwd - Contains the username, hashed password, and UID of all the users in the system&lt;/li&gt;
            &lt;li&gt;/etc/shadow - Contains the username, and hashed password of all users in the system&lt;/li&gt;
            &lt;li&gt;/etc/groups - Contains the list of groups in the systems (name, GID)&lt;/li&gt;
            &lt;li&gt;/etc/hostname - The hostname of the given `Computer`&lt;/li&gt;
            &lt;li&gt;/etc/skel -  A &#34;skeleton&#34; needed to create a users home folder (located in /home/&lt;USERNAME&gt;)&lt;/li&gt;
            &lt;li&gt;/etc/sudoers - The file that contains all of the sudo permissions&lt;/li&gt;
            &lt;li&gt;/etc/apt/sources.list - Contains urls of apt repo servers&lt;/li&gt;
            &lt;li&gt;/etc/resolv.conf - Contains the list of dns servers&lt;/li&gt;
        &lt;/ul&gt;

        Returns:
            None
        &#34;&#34;&#34;

        # EventHandler functions for /etc/passwd, /etc/shadow, and /etc/group
        def update_passwd(file):
            content = file.content.split(&#34;\n&#34;)

            for item in content:
                subitems = item.split(&#34;:&#34;)
                # An item in the list with a length of 1 or less are usually blank lines
                if len(subitems) &gt; 1:
                    username, password, uid, primary_gid = subitems

                    try:
                        uid = int(uid)
                        primary_gid = int(primary_gid)
                    except Exception:
                        return

                    # Now we want to get the user by username
                    user_lookup = self.computer.get_user(username=username)

                    # If we don&#39;t find the user, that means we added a new user
                    if not user_lookup.success:
                        # Make sure no user has the uid
                        if not self.computer.get_user(uid=uid).success:
                            # Add the user
                            self.computer.add_user(username, password, uid, plaintext=False)
                            self.computer.add_group(name=username, gid=primary_gid)
                            self.computer.add_user_to_group(uid, primary_gid, &#34;primary&#34;)
                    else:
                        # We have a user, now lets check if any of the data has changed
                        user = user_lookup.data

                        # If the password is &#39;x&#39;, that password is in the /etc/shadow file and should be ignored here
                        if user.password != password and password != &#34;x&#34;:
                            result = self.computer.change_user_password(user.uid, password, plaintext=False)
                            if result.success:
                                user.password = password

                        if user.uid != uid:
                            result = self.computer.change_user_uid(user.uid, uid)
                            if result.success:
                                user.uid = uid

                        # If the GID changed, we want to:
                        # 1. Make sure the new GID exists
                        # 2. Remove the user&#39;s old primary gid membership
                        # 3. Add a the user to the new gid as primary
                        user_primary_gid = self.computer.get_user_primary_group(user.uid).data[0]

                        if user_primary_gid != primary_gid:
                            if self.computer.get_group(gid=primary_gid).success:
                                self.computer.remove_user_from_group(uid=user.uid, gid=user_primary_gid)
                                self.computer.add_user_to_group(user.uid, primary_gid, &#34;primary&#34;)

                    # Will automatically remove incorrect changes
                    self.computer.sync_user_and_group_files()

        def update_shadow(file):
            content = file.content.split(&#34;\n&#34;)

            for item in content:
                subitems = item.split(&#34;:&#34;)
                # An item in the list with a length of 1 or less are usually blank lines
                if len(subitems) &gt; 1:
                    username, password = subitems

                    # Now we want to get the user by username
                    user_lookup = self.computer.get_user(username=username)

                    # We have a user, now lets check if any of the data has changed
                    user = user_lookup.data

                    # If the password is &#39;x&#39;, that password is in the /etc/shadow file and should be ignored here
                    if user.password != password and password != &#34;x&#34;:
                        result = self.computer.change_user_password(user.uid, password, plaintext=False)
                        if result.success:
                            user.password = password

                # Will automatically remove incorrect changes
                self.computer.sync_user_and_group_files()

        def update_group(file):
            content = file.content.split(&#34;\n&#34;)

            for item in content:
                subitems = item.split(&#34;:&#34;)
                # An item in the list with a length of 1 or less are usually blank lines
                if len(subitems) &gt; 1:
                    group_name, password, gid, group_users = subitems

                    try:
                        uid = int(gid)
                    except Exception:
                        return

                    # Now we want to get the group by group name
                    group_lookup = self.computer.get_group(name=group_name)

                    # If we don&#39;t find the user, that means we added a new user
                    if not group_lookup.success:
                        # Make sure no group has the gid
                        if not self.computer.get_group(gid=gid).success:
                            # Add the group
                            self.computer.add_group(group_name, gid)
                            # TODO: Add users to the group by last param
                    else:
                        # We have a group, now lets check if any of the data has changed
                        group = group_lookup.data
                        # TODO: Add changes here

                    # Will automatically remove incorrect changes
                    self.computer.sync_user_and_group_files()

        etc_dir: Directory = self.files.find(&#34;etc&#34;)
        # Create the /etc/passwd file
        passwd_file: File = File(&#34;passwd&#34;, f&#34;&#34;, etc_dir, 0, 0)

        passwd_file.add_event_listener(&#34;write&#34;, update_passwd)

        # Create the /etc/shadow file and change its perms (rw-------)
        shadow_file: File = File(&#34;shadow&#34;, f&#34;&#34;, etc_dir, 0, 0)
        shadow_file.permissions = {&#34;read&#34;: [&#34;owner&#34;], &#34;write&#34;: [&#34;owner&#34;], &#34;execute&#34;: []}
        shadow_file.add_event_listener(&#34;write&#34;, update_shadow)

        # Create the /etc/groups file
        group_file: File = File(&#34;group&#34;, f&#34;root:x:0&#34;, etc_dir, 0, 0)
        group_file.add_event_listener(&#34;write&#34;, update_group)

        # /etc/skel (home dir template)
        skel_dir: Directory = Directory(&#34;skel&#34;, etc_dir, 0, 0)

        for dir in [&#34;Desktop&#34;, &#34;Documents&#34;, &#34;Downloads&#34;, &#34;Music&#34;, &#34;Pictures&#34;, &#34;Public&#34;, &#34;Templates&#34;, &#34;Videos&#34;]:
            current_dir = Directory(dir, skel_dir, 0, 0)
            current_dir.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;],
                                       &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}

        # /etc/skel/.shellrc (.bashrc/.zshrc equivalent)
        DEFAULT_SHELLRC_CONTENT = &#34;alias lsa=ls -l -a\n&#34; \
                                  &#34;alias la=ls -a\n&#34; \
                                  &#34;alias ll=ls -l\n&#34;

        File(&#34;.shellrc&#34;, DEFAULT_SHELLRC_CONTENT, skel_dir, 0, 0)

        # /etc/hostname (holds system hostname)
        # Stupid windows style default hostnames (for fun, might change later)
        new_hostname = f&#34;DESKTOP-{&#39;&#39;.join([choice(ascii_uppercase + digits) for _ in range(7)])}&#34;
        File(&#34;hostname&#34;, new_hostname, etc_dir, 0, 0)

        # /etc/sudoers (holds sudo permissions)
        # Sudoers has permissions r--r-----
        sudoers_file: File = File(&#34;sudoers&#34;, &#34;root ALL=(ALL) ALL\n&#34;, etc_dir, 0, 0)
        sudoers_file.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;], &#34;write&#34;: [], &#34;execute&#34;: []}

        # /etc/apt/sources.list
        apt_dir: Directory = Directory(&#34;apt&#34;, etc_dir, 0, 0)

        File(&#34;sources.list&#34;, &#34;&#34;, apt_dir, 0, 0)

        # /etc/resolv.conf
        File(&#34;resolv.conf&#34;, &#34;nameserver 1.1.1.1&#34;, etc_dir, 0, 0)

    def setup_proc(self) -&gt; None:
        &#34;&#34;&#34;
        Sets up:
        &lt;ul&gt;
            &lt;li&gt;/proc/uptime - Contains the amount of seconds since the system was booted&lt;/li&gt;
        &lt;/ul&gt;

        Returns:
            None
        &#34;&#34;&#34;

        # EventHandler functions for /proc/uptime
        def update_uptime(file):
            file.content = str((datetime.datetime.now() - self.computer.boot_time).total_seconds())

        proc_dir: Directory = self.files.find(&#34;proc&#34;)
        # Create the /proc/uptime file
        uptime_file: File = File(&#34;uptime&#34;, f&#34;&#34;, proc_dir, 0, 0)
        uptime_file.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [], &#34;execute&#34;: []}

        uptime_file.add_event_listener(&#34;read&#34;, update_uptime, when=&#34;before&#34;)

    def setup_root(self) -&gt; None:
        &#34;&#34;&#34;
        Since the root user is different from a &#34;standard&#34; user, root&#39;s home folder needs to be setup separately.
        Otherwise, the format of root&#39;s home folder is the same as any other user

        Returns:
            None
        &#34;&#34;&#34;
        # Create /root/.shellrc
        root_dir: Directory = self.files.find(&#34;root&#34;)

        File(&#34;.shellrc&#34;, &#34;export HOME=/root\nexport USER=root&#34;, root_dir, 0, 0)

    def setup_run(self) -&gt; None:
        &#34;&#34;&#34;
        Sets up:
        &lt;ul&gt;
            &lt;li&gt;/run/sudo/ts/ - Contains auth timeout timestamps for &lt;code&gt;sudo&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;

        Returns:
            None
        &#34;&#34;&#34;
        run_dir: Directory = self.files.find(&#34;run&#34;)

        # Create /run/sudo and /run/sudo/ts
        run_sudo: Directory = Directory(&#34;sudo&#34;, run_dir, 0, 0)
        run_sudo.permissions = {&#34;read&#34;: [&#34;owner&#34;], &#34;write&#34;: [&#34;owner&#34;], &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}

        run_sudo_ts: Directory = Directory(&#34;ts&#34;, run_sudo, 0, 0)
        run_sudo_ts.permissions = {&#34;read&#34;: [&#34;owner&#34;], &#34;write&#34;: [&#34;owner&#34;], &#34;execute&#34;: [&#34;owner&#34;]}

    def setup_usr(self) -&gt; None:
        &#34;&#34;&#34;
        Sets up:
        &lt;ul&gt;
            &lt;li&gt;/usr/share/man - Contains all the &#34;man pages&#34;, or instruction manuals, for all the system binaries&lt;/li&gt;
            &lt;li&gt;/usr/bin - &#34;Aftermarket&#34; installed packages (apt) &lt;/li&gt;
        &lt;/ul&gt;

        Returns:
            None
        &#34;&#34;&#34;
        # Setup /usr/share
        usr_dir: Directory = self.files.find(&#34;usr&#34;)

        share_dir: Directory = Directory(&#34;share&#34;, usr_dir, 0, 0)

        # /usr/share/man
        Directory(&#34;man&#34;, share_dir, 0, 0)

        self.generate_manpages()

        def generate_manpages(file):
            self.generate_manpages()

        bin_dir: Directory = Directory(&#34;bin&#34;, usr_dir, 0, 0)
        bin_dir.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;],
                               &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}
        bin_dir.add_event_listener(&#34;write&#34;, generate_manpages)

    def setup_var(self) -&gt; None:
        &#34;&#34;&#34;
        Sets up:
        &lt;ul&gt;
            &lt;li&gt;/var/log - Contains various log files&lt;/li&gt;
            &lt;li&gt;/var/log/syslog - Logs various information about the given `Computer`&lt;/li&gt;
            &lt;li&gt;/var/log/auth.log - Logs information about authentication attempts&lt;/li&gt;
            &lt;li&gt;/var/lib/dpkg/status - The list of installed packages by apt&lt;/li&gt;
            &lt;li&gt;/var/www/html - Default location for web content served by web servers&lt;/li&gt;
        &lt;/ul&gt;

        Returns:
            None
        &#34;&#34;&#34;
        # This should exist at runtime
        var_dir: Directory = self.files.find(&#34;var&#34;)

        # Create /var/log
        log_dir: Directory = Directory(&#34;log&#34;, var_dir, 0, 0)

        # Create the `syslog` in /var/log
        File(&#34;syslog&#34;, &#34;&#34;, log_dir, 0, 0)

        # Create /var/lib/dpkg/status
        lib_dir: Directory = Directory(&#34;lib&#34;, var_dir, 0, 0)

        dpkg_dir: Directory = Directory(&#34;dpkg&#34;, lib_dir, 0, 0)

        File(&#34;status&#34;, &#34;&#34;, dpkg_dir, 0, 0)

        # Create /var/www/html
        www_dir: Directory = Directory(&#34;www&#34;, var_dir, 0, 0)

        Directory(&#34;html&#34;, www_dir, 0, 0)

    def find(self, pathname: str) -&gt; Result:
        &#34;&#34;&#34;
        Try to find a given file anywhere in the file system based on a given `pathname`

        Args:
            pathname (str): The full (absolute or relative) path of the file

        Returns:
            Result: A `Result` with the `success` flag set accordingly and the `data` flag with the found `File` or `Directory` if the file was found
        &#34;&#34;&#34;

        # Special cases
        # Replace &#39;~&#39; with $HOME (if exists)
        get_home_env_var = self.computer.get_env(&#34;HOME&#34;)
        if get_home_env_var:
            pathname = pathname.replace(&#34;~&#34;, get_home_env_var)

        # Replace all instances of &#34;\&#34; with &#34;/&#34; (because windows)
        pathname = pathname.replace(&#34;\\&#34;, &#34;/&#34;)

        if pathname == &#34;/&#34;:
            return Result(success=True, data=self.files)

        if pathname == &#34;.&#34;:
            return Result(success=True, data=self.computer.sys_getcwd())

        if pathname == &#34;..&#34;:
            # Check if the directory has a parent
            # If it doesn&#39;t, we can assume that we&#39;re at /
            # In the case of /, just return /
            if not self.computer.sys_getcwd().parent:
                return Result(success=True, data=self.files)
            else:
                return Result(success=True, data=self.computer.sys_getcwd().parent)

        if pathname == &#34;...&#34;:
            # Check if the directory has a parent
            # If it doesn&#39;t, we can assume that we&#39;re at /
            # In the case of /, just return /
            # And then do it again (go back twice)0
            if not self.computer.sys_getcwd().parent:
                return Result(success=True, data=self.computer.fs.files)
            else:
                current_dir = self.computer.sys_getcwd().parent
                if current_dir.parent:
                    return Result(success=True, data=current_dir.parent)
                else:
                    return Result(success=True, data=self.computer.fs.files)

        # Regular (non-special cases)
        pathname = pathname.split(&#34;/&#34;)
        # Check if `pathname` is absolute or relative
        # Check if the first arg is empty (because we split by /) which means the first arg is empty if it was a &#34;/&#34;
        if pathname[0] == &#34;&#34;:
            # Absolute (start at root dir)
            current_dir = self.files
        else:
            # Relative (based on current dir)
            current_dir = self.computer.sys_getcwd()

        # Filter out garbage
        while &#34;&#34; in pathname:
            pathname.remove(&#34;&#34;)

        for subdir in pathname:
            # Special case for current directory (.) (ignore it)
            if subdir == &#34;.&#34;:
                continue

            # Special case for (..) (go to parent)
            elif subdir == &#34;..&#34;:
                # Check if we&#39;re at the root
                if not current_dir.parent:
                    current_dir = self.files
                else:
                    current_dir = current_dir.parent

            else:
                if current_dir.is_file():
                    return Result(success=True, data=current_dir)
                current_dir = current_dir.find(subdir)
                if not current_dir:
                    return Result(success=False, message=ResultMessages.NOT_FOUND)

        # This only runs when we successfully found
        return Result(success=True, data=current_dir)

    def generate_manpages(self):
        &#34;&#34;&#34;
        Loop through all available modules and import them. After, use the module.parse_args(doc=True) to generate
        a manpage from the available help information.

        Returns:
            None
        &#34;&#34;&#34;
        find_man_dir = self.find(&#34;/usr/share/man&#34;)

        if not find_man_dir.success:
            return

        man_dir = find_man_dir.data

        find_usr_bin = self.find(&#34;/usr/bin&#34;)

        if not find_usr_bin.success:
            usr_bin = []
        else:
            usr_bin = list(find_usr_bin.data.files.keys())

        # Loop through all the files in /bin and run &#34;parse_args()&#34; with the `doc` set to `True`
        for binary in list(self.files.find(&#34;bin&#34;).files.keys()) + usr_bin:
            # Check if an manpage exist
            if not self.find(f&#34;/usr/share/man/{binary}&#34;).success:
                try:
                    module = importlib.import_module(f&#34;blackhat.bin.{binary}&#34;)
                except ImportError:
                    try:
                        module = importlib.import_module(f&#34;blackhat.bin.installable.{binary}&#34;)
                    except ImportError:
                        continue

                try:
                    manpage = module.parse_args(args=[], doc=True).replace(&#34;**&#34;, Style.BRIGHT).replace(&#34;*/&#34;,
                                                                                                       Style.RESET_ALL)
                    manpage = manpage.removeprefix(&#34;\n&#34;).removesuffix(&#34;\n&#34;)
                    File(binary, manpage, man_dir, 0, 0)
                except AttributeError:
                    continue


def copy(computer, src_path: str, dst_path: str) -&gt; Result:
    &#34;&#34;&#34;
    A helper function to copy a file/directory from a given `src_path` to the given `dst_path`

    Args:
        computer (Computer): The computer to work on
        src_path (str): The path of the `File`/`Directory` to copy
        dst_path (str): The path to copy to. If the final item in the path doesn&#39;t exist, but the item one step up does,
        the final item will be the new name of the `File`/`Directory`

    Returns:
        Result: A `Result` object with the success flag set accordingly
    &#34;&#34;&#34;
    find_src = computer.fs.find(src_path)

    if not find_src.success:
        return Result(success=False, message=ResultMessages.NOT_FOUND)

    src = find_src.data

    # Handle file copying
    if src.is_file():
        # If the path is in the local dir
        if &#34;/&#34; not in dst_path:
            dst_path = &#34;./&#34; + dst_path

        try_find_dst = computer.fs.find(dst_path)

        # If the dst file doesn&#39;t exist, we can try to create a new item in the parent folder
        if not try_find_dst.success:
            # Try to find the destination file parent folder
            try_find_dst = computer.fs.find(&#34;/&#34;.join(dst_path.split(&#34;/&#34;)[:-1]))
            if not try_find_dst.success:
                return Result(success=False, message=ResultMessages.NOT_FOUND)

        to_write: Union[Directory, File] = try_find_dst.data

        # If we found the parent folder, set the filename to the parent folder
        if dst_path.split(&#34;/&#34;)[-1] != to_write.name:
            new_file_name = dst_path.split(&#34;/&#34;)[-1]
            if new_file_name == &#34;&#34;:
                new_file_name = src.name
        else:
            new_file_name = src.name

        if to_write.is_file():
            # If its a file, we&#39;re overwriting
            # Check the permissions (write to `copy_to_dir + file` and read from `self`)
            # Check read first (split for error messages)
            if not src.check_perm(&#34;read&#34;, computer).success:
                return Result(success=False, message=ResultMessages.NOT_ALLOWED_READ)
            else:
                if not to_write.check_perm(&#34;write&#34;, computer).success:
                    return Result(success=False, message=ResultMessages.NOT_ALLOWED_WRITE)
                else:
                    to_write.write(src.content, computer)
                    to_write.owner = computer.sys_getuid()
                    to_write.group_owner = computer.sys_getgid()
        else:
            # If we have the parent dir, we need to create a new file
            if not src.check_perm(&#34;read&#34;, computer).success:
                return Result(success=False, message=ResultMessages.NOT_ALLOWED_READ)
            else:
                if not to_write.check_perm(&#34;write&#34;, computer).success:
                    return Result(success=False, message=ResultMessages.NOT_ALLOWED_WRITE)
                else:
                    new_filename = new_file_name
                    new_file = File(new_filename, src.content, to_write, computer.sys_getuid(), computer.sys_getgid())
                    new_file.events = src.events
                    # We have to do this so the permissions work no matter if we&#39;re overwriting or not
                    to_write = new_file

        to_write.handle_event(&#34;move&#34;)
        return Result(success=True)
    # Handle directory copying
    else:
        # TODO: Refactor this to work in both cases instead of re-writing a ton of code
        # If the path is in the local dir
        if &#34;/&#34; not in dst_path:
            dst_path = &#34;./&#34; + dst_path

        try_find_dst = computer.fs.find(dst_path)

        # If the dst file doesn&#39;t exist, we can try to create a new item in the parent folder
        if not try_find_dst.success:
            # Try to find the destination file parent folder
            try_find_dst = computer.fs.find(&#34;/&#34;.join(dst_path.split(&#34;/&#34;)[:-1]))
            if not try_find_dst.success:
                return Result(success=False, message=ResultMessages.NOT_FOUND)

        to_write: Union[Directory, File] = try_find_dst.data

        # If we found the parent folder, set the filename to the parent folder
        if dst_path.split(&#34;/&#34;)[-1] != to_write.name:
            new_file_name = dst_path.split(&#34;/&#34;)[-1]
        else:
            new_file_name = src.name

        if new_file_name not in to_write.files:
            if not src.check_perm(&#34;read&#34;, computer):
                return Result(success=False, message=ResultMessages.NOT_ALLOWED_READ)
            else:
                if not to_write.check_perm(&#34;write&#34;, computer).success:
                    return Result(success=False, message=ResultMessages.NOT_ALLOWED_WRITE)
                else:
                    new_dir = Directory(new_file_name, to_write, computer.sys_getuid(), computer.sys_getgid())
                    new_dir.events = to_write.events
                    # Set a temporary write permission no matter what the new dir&#39;s permissions were so we can add its children
                    new_dir.permissions[&#34;write&#34;] = [&#34;owner&#34;]
                    # Go through all the source&#39;s files and copy them into the new dir
                    for file in src.files.values():
                        response = copy(computer, file, new_dir.pwd())

                        if not response.success:
                            if response.message == ResultMessages.NOT_ALLOWED_READ:
                                return Result(success=False, message=ResultMessages.NOT_ALLOWED_READ)
                            elif response.message == ResultMessages.NOT_ALLOWED_WRITE:
                                return Result(success=False, message=ResultMessages.NOT_ALLOWED_WRITE)
        else:
            return Result(success=False, message=ResultMessages.ALREADY_EXISTS)

        new_dir.handle_event(&#34;move&#34;)
        return Result(success=True)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="blackhat.fs.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>computer, src_path: str, dst_path: str) ‑> <a title="blackhat.helpers.Result" href="helpers.html#blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>A helper function to copy a file/directory from a given <code>src_path</code> to the given <code>dst_path</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>computer</code></strong> :&ensp;<code>Computer</code></dt>
<dd>The computer to work on</dd>
<dt><strong><code>src_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path of the <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code>/<code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code> to copy</dd>
<dt><strong><code>dst_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to copy to. If the final item in the path doesn't exist, but the item one step up does,</dd>
</dl>
<p>the final item will be the new name of the <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code>/<code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> object with the success flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(computer, src_path: str, dst_path: str) -&gt; Result:
    &#34;&#34;&#34;
    A helper function to copy a file/directory from a given `src_path` to the given `dst_path`

    Args:
        computer (Computer): The computer to work on
        src_path (str): The path of the `File`/`Directory` to copy
        dst_path (str): The path to copy to. If the final item in the path doesn&#39;t exist, but the item one step up does,
        the final item will be the new name of the `File`/`Directory`

    Returns:
        Result: A `Result` object with the success flag set accordingly
    &#34;&#34;&#34;
    find_src = computer.fs.find(src_path)

    if not find_src.success:
        return Result(success=False, message=ResultMessages.NOT_FOUND)

    src = find_src.data

    # Handle file copying
    if src.is_file():
        # If the path is in the local dir
        if &#34;/&#34; not in dst_path:
            dst_path = &#34;./&#34; + dst_path

        try_find_dst = computer.fs.find(dst_path)

        # If the dst file doesn&#39;t exist, we can try to create a new item in the parent folder
        if not try_find_dst.success:
            # Try to find the destination file parent folder
            try_find_dst = computer.fs.find(&#34;/&#34;.join(dst_path.split(&#34;/&#34;)[:-1]))
            if not try_find_dst.success:
                return Result(success=False, message=ResultMessages.NOT_FOUND)

        to_write: Union[Directory, File] = try_find_dst.data

        # If we found the parent folder, set the filename to the parent folder
        if dst_path.split(&#34;/&#34;)[-1] != to_write.name:
            new_file_name = dst_path.split(&#34;/&#34;)[-1]
            if new_file_name == &#34;&#34;:
                new_file_name = src.name
        else:
            new_file_name = src.name

        if to_write.is_file():
            # If its a file, we&#39;re overwriting
            # Check the permissions (write to `copy_to_dir + file` and read from `self`)
            # Check read first (split for error messages)
            if not src.check_perm(&#34;read&#34;, computer).success:
                return Result(success=False, message=ResultMessages.NOT_ALLOWED_READ)
            else:
                if not to_write.check_perm(&#34;write&#34;, computer).success:
                    return Result(success=False, message=ResultMessages.NOT_ALLOWED_WRITE)
                else:
                    to_write.write(src.content, computer)
                    to_write.owner = computer.sys_getuid()
                    to_write.group_owner = computer.sys_getgid()
        else:
            # If we have the parent dir, we need to create a new file
            if not src.check_perm(&#34;read&#34;, computer).success:
                return Result(success=False, message=ResultMessages.NOT_ALLOWED_READ)
            else:
                if not to_write.check_perm(&#34;write&#34;, computer).success:
                    return Result(success=False, message=ResultMessages.NOT_ALLOWED_WRITE)
                else:
                    new_filename = new_file_name
                    new_file = File(new_filename, src.content, to_write, computer.sys_getuid(), computer.sys_getgid())
                    new_file.events = src.events
                    # We have to do this so the permissions work no matter if we&#39;re overwriting or not
                    to_write = new_file

        to_write.handle_event(&#34;move&#34;)
        return Result(success=True)
    # Handle directory copying
    else:
        # TODO: Refactor this to work in both cases instead of re-writing a ton of code
        # If the path is in the local dir
        if &#34;/&#34; not in dst_path:
            dst_path = &#34;./&#34; + dst_path

        try_find_dst = computer.fs.find(dst_path)

        # If the dst file doesn&#39;t exist, we can try to create a new item in the parent folder
        if not try_find_dst.success:
            # Try to find the destination file parent folder
            try_find_dst = computer.fs.find(&#34;/&#34;.join(dst_path.split(&#34;/&#34;)[:-1]))
            if not try_find_dst.success:
                return Result(success=False, message=ResultMessages.NOT_FOUND)

        to_write: Union[Directory, File] = try_find_dst.data

        # If we found the parent folder, set the filename to the parent folder
        if dst_path.split(&#34;/&#34;)[-1] != to_write.name:
            new_file_name = dst_path.split(&#34;/&#34;)[-1]
        else:
            new_file_name = src.name

        if new_file_name not in to_write.files:
            if not src.check_perm(&#34;read&#34;, computer):
                return Result(success=False, message=ResultMessages.NOT_ALLOWED_READ)
            else:
                if not to_write.check_perm(&#34;write&#34;, computer).success:
                    return Result(success=False, message=ResultMessages.NOT_ALLOWED_WRITE)
                else:
                    new_dir = Directory(new_file_name, to_write, computer.sys_getuid(), computer.sys_getgid())
                    new_dir.events = to_write.events
                    # Set a temporary write permission no matter what the new dir&#39;s permissions were so we can add its children
                    new_dir.permissions[&#34;write&#34;] = [&#34;owner&#34;]
                    # Go through all the source&#39;s files and copy them into the new dir
                    for file in src.files.values():
                        response = copy(computer, file, new_dir.pwd())

                        if not response.success:
                            if response.message == ResultMessages.NOT_ALLOWED_READ:
                                return Result(success=False, message=ResultMessages.NOT_ALLOWED_READ)
                            elif response.message == ResultMessages.NOT_ALLOWED_WRITE:
                                return Result(success=False, message=ResultMessages.NOT_ALLOWED_WRITE)
        else:
            return Result(success=False, message=ResultMessages.ALREADY_EXISTS)

        new_dir.handle_event(&#34;move&#34;)
        return Result(success=True)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="blackhat.fs.Directory"><code class="flex name class">
<span>class <span class="ident">Directory</span></span>
<span>(</span><span>name: str, parent: Optional[ForwardRef('<a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a>')], owner: int, group_owner: int)</span>
</code></dt>
<dd>
<div class="desc"><p>The class object representing a directory within the file system</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code>/<code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code></dd>
<dt><strong><code>parent</code></strong> :&ensp;<code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code></dt>
<dd>The <code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code> one level up the tree</dd>
<dt><strong><code>owner</code></strong> :&ensp;<code>int</code></dt>
<dd>The UID of the owner of the <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code>/<code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code></dd>
<dt><strong><code>group_owner</code></strong> :&ensp;<code>int</code></dt>
<dd>The GID of the owner of the <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code>/<code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Directory(FSBaseObject):
    def __init__(self, name: str, parent: Optional[&#34;Directory&#34;], owner: int, group_owner: int):
        &#34;&#34;&#34;
        The class object representing a directory within the file system

        Args:
            name (str): The name of the `File`/`Directory`
            parent (Directory): The `Directory` one level up the tree
            owner (int): The UID of the owner of the `File`/`Directory`
            group_owner (int): The GID of the owner of the `File`/`Directory`
        &#34;&#34;&#34;
        super().__init__(name, parent, owner, group_owner)
        self.files = {}
        self.size = None
        # The default perms for directories are different from files
        self.permissions = {
            &#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;],
            &#34;write&#34;: [&#34;owner&#34;],
            &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;],
        }

        if parent:
            parent.add_file(self)

        self.update_size()

    def add_file(self, file: Union[File, &#34;Directory&#34;]) -&gt; Result:
        &#34;&#34;&#34;
        Add a new `File` or `Directory` to self&#39;s internal file map
        Also updates its size and triggers its parent to update their size

        Args:
            file (File/Directory): The `File`/`Directory` to add to self

        Returns:
            Result: A `Result` with the `success` flag set accordingly
        &#34;&#34;&#34;
        if file.name in self.files.keys():
            return Result(success=False, message=ResultMessages.ALREADY_EXISTS)

        self.files[file.name] = file
        self.update_size()

        self.handle_event(&#34;write&#34;)

        return Result(success=True)

    def calculate_size(self) -&gt; int:
        &#34;&#34;&#34;
        Calculate a total size for the given directory and (recursively) all its children (`File`(s)/`Directory`(ies))

        Returns:
            int: The total size (in bytes) of the given directory
        &#34;&#34;&#34;
        total = 0

        for file in self.files.values():
            if file.is_directory():
                # Recursive
                total += file.calculate_size()
            else:
                if file.size:
                    total += file.size

        return total

    def find(self, filename: str) -&gt; Optional[Union[File, &#34;Directory&#34;]]:
        &#34;&#34;&#34;
        Find a `File` or `Directory` in self&#39;s internal file map

        Args:
            filename (str): The name of the `File`/`Directory` to find

        Returns:
            File or Directory or None: The `File` or `Directory` object if found, otherwise, None
        &#34;&#34;&#34;
        return self.files.get(filename, None)

    def update_size(self) -&gt; None:
        &#34;&#34;&#34;
        Update self&#39;s size using `calculate_size()` then, triggers self&#39;s parent to update their size

        Returns:
            None
        &#34;&#34;&#34;
        self.size = self.calculate_size()

        # This does the same as the file update size. Updates its own size
        # Then the parent updates its size, taking into account self&#39;s new size
        # Like a chain until all parent folders have been updated

        if self.parent:
            self.parent.update_size()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="blackhat.fs.FSBaseObject" href="#blackhat.fs.FSBaseObject">FSBaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="blackhat.fs.Directory.add_file"><code class="name flex">
<span>def <span class="ident">add_file</span></span>(<span>self, file: Union[<a title="blackhat.fs.File" href="#blackhat.fs.File">File</a>, ForwardRef('<a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a>')]) ‑> <a title="blackhat.helpers.Result" href="helpers.html#blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Add a new <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code> or <code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code> to self's internal file map
Also updates its size and triggers its parent to update their size</p>
<h2 id="args">Args</h2>
<p>file (File/Directory): The <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code>/<code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code> to add to self</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> with the <code>success</code> flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_file(self, file: Union[File, &#34;Directory&#34;]) -&gt; Result:
    &#34;&#34;&#34;
    Add a new `File` or `Directory` to self&#39;s internal file map
    Also updates its size and triggers its parent to update their size

    Args:
        file (File/Directory): The `File`/`Directory` to add to self

    Returns:
        Result: A `Result` with the `success` flag set accordingly
    &#34;&#34;&#34;
    if file.name in self.files.keys():
        return Result(success=False, message=ResultMessages.ALREADY_EXISTS)

    self.files[file.name] = file
    self.update_size()

    self.handle_event(&#34;write&#34;)

    return Result(success=True)</code></pre>
</details>
</dd>
<dt id="blackhat.fs.Directory.calculate_size"><code class="name flex">
<span>def <span class="ident">calculate_size</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate a total size for the given directory and (recursively) all its children (<code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code>(s)/<code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code>(ies))</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The total size (in bytes) of the given directory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_size(self) -&gt; int:
    &#34;&#34;&#34;
    Calculate a total size for the given directory and (recursively) all its children (`File`(s)/`Directory`(ies))

    Returns:
        int: The total size (in bytes) of the given directory
    &#34;&#34;&#34;
    total = 0

    for file in self.files.values():
        if file.is_directory():
            # Recursive
            total += file.calculate_size()
        else:
            if file.size:
                total += file.size

    return total</code></pre>
</details>
</dd>
<dt id="blackhat.fs.Directory.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, filename: str) ‑> Union[<a title="blackhat.fs.File" href="#blackhat.fs.File">File</a>, <a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a>, ForwardRef(None)]</span>
</code></dt>
<dd>
<div class="desc"><p>Find a <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code> or <code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code> in self's internal file map</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code>/<code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code> to find</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code> or <code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code> or <code>None</code></dt>
<dd>The <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code> or <code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code> object if found, otherwise, None</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(self, filename: str) -&gt; Optional[Union[File, &#34;Directory&#34;]]:
    &#34;&#34;&#34;
    Find a `File` or `Directory` in self&#39;s internal file map

    Args:
        filename (str): The name of the `File`/`Directory` to find

    Returns:
        File or Directory or None: The `File` or `Directory` object if found, otherwise, None
    &#34;&#34;&#34;
    return self.files.get(filename, None)</code></pre>
</details>
</dd>
<dt id="blackhat.fs.Directory.update_size"><code class="name flex">
<span>def <span class="ident">update_size</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Update self's size using <code>calculate_size()</code> then, triggers self's parent to update their size</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_size(self) -&gt; None:
    &#34;&#34;&#34;
    Update self&#39;s size using `calculate_size()` then, triggers self&#39;s parent to update their size

    Returns:
        None
    &#34;&#34;&#34;
    self.size = self.calculate_size()

    # This does the same as the file update size. Updates its own size
    # Then the parent updates its size, taking into account self&#39;s new size
    # Like a chain until all parent folders have been updated

    if self.parent:
        self.parent.update_size()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="blackhat.fs.FSBaseObject" href="#blackhat.fs.FSBaseObject">FSBaseObject</a></b></code>:
<ul class="hlist">
<li><code><a title="blackhat.fs.FSBaseObject.add_event_listener" href="#blackhat.fs.FSBaseObject.add_event_listener">add_event_listener</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.atime" href="#blackhat.fs.FSBaseObject.atime">atime</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.change_owner" href="#blackhat.fs.FSBaseObject.change_owner">change_owner</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.check_owner" href="#blackhat.fs.FSBaseObject.check_owner">check_owner</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.check_perm" href="#blackhat.fs.FSBaseObject.check_perm">check_perm</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.ctime" href="#blackhat.fs.FSBaseObject.ctime">ctime</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.delete" href="#blackhat.fs.FSBaseObject.delete">delete</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.handle_event" href="#blackhat.fs.FSBaseObject.handle_event">handle_event</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.is_directory" href="#blackhat.fs.FSBaseObject.is_directory">is_directory</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.is_file" href="#blackhat.fs.FSBaseObject.is_file">is_file</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.mtime" href="#blackhat.fs.FSBaseObject.mtime">mtime</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.permissions" href="#blackhat.fs.FSBaseObject.permissions">permissions</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.pwd" href="#blackhat.fs.FSBaseObject.pwd">pwd</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.remove_event_listener" href="#blackhat.fs.FSBaseObject.remove_event_listener">remove_event_listener</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.setuid" href="#blackhat.fs.FSBaseObject.setuid">setuid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="blackhat.fs.FSBaseObject"><code class="flex name class">
<span>class <span class="ident">FSBaseObject</span></span>
<span>(</span><span>name: str, parent: Optional[ForwardRef('<a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a>')], owner: int, group_owner: int)</span>
</code></dt>
<dd>
<div class="desc"><p>The base object that contains info shared between <code>Directories</code> and <code>Files</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code>/<code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code></dd>
<dt><strong><code>parent</code></strong> :&ensp;<code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code></dt>
<dd>The <code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code> one level up the tree</dd>
<dt><strong><code>owner</code></strong> :&ensp;<code>int</code></dt>
<dd>The UID of the owner of the <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code>/<code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code></dd>
<dt><strong><code>group_owner</code></strong> :&ensp;<code>int</code></dt>
<dd>The GID of the owner of the <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code>/<code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FSBaseObject:
    def __init__(self, name: str, parent: Optional[&#34;Directory&#34;], owner: int, group_owner: int) -&gt; None:
        &#34;&#34;&#34;
        The base object that contains info shared between `Directories` and `Files`

        Args:
            name (str): The name of the `File`/`Directory`
            parent (Directory): The `Directory` one level up the tree
            owner (int): The UID of the owner of the `File`/`Directory`
            group_owner (int): The GID of the owner of the `File`/`Directory`
        &#34;&#34;&#34;
        self.name: str = name
        self.permissions: Dict[str, List[Literal[&#34;read&#34;, &#34;write&#34;, &#34;execute&#34;]]] = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;],
                                                                                  &#34;write&#34;: [&#34;owner&#34;],
                                                                                  &#34;execute&#34;: []}
        # TODO: Handle setuid bit on directories
        &#34;&#34;&#34;
        Reference:
        
        27.5 Directories and the Set-User-ID and Set-Group-ID Bits

        On most systems, if a directory’s set-group-ID bit is set, newly created subfiles inherit the same group as the directory, and newly created subdirectories inherit the set-group-ID bit of the parent directory. On a few systems, a directory’s set-user-ID bit has a similar effect on the ownership of new subfiles and the set-user-ID bits of new subdirectories. These mechanisms let users share files more easily, by lessening the need to use chmod or chown to share new files.
        
        (https://www.gnu.org/software/coreutils/manual/html_node/Directory-Setuid-and-Setgid.html)
        &#34;&#34;&#34;
        self.setuid = False
        &#34;&#34;&#34;Permissions for accessing the file. Default permissions; rw-r--r-- (644)&#34;&#34;&#34;
        self.parent: Optional[&#34;Directory&#34;] = parent
        self.owner: int = owner
        self.group_owner: int = group_owner
        self.link_count: int
        self.size: int  # Size in bytes
        self.atime: int  # Last access time (unix time stamp)
        &#34;&#34;&#34;int: Access time; when file was last read from/accessed&#34;&#34;&#34;
        self.mtime: int  # Last modified time (unix time stamp)
        &#34;&#34;&#34;int: Modified time; when the file&#34;s content was last modified&#34;&#34;&#34;
        self.ctime: int  # Last file status change (unix time stamp)
        &#34;&#34;&#34;int: Changed time; when the file&#34;s metadata was last changed (ex. perms)&#34;&#34;&#34;
        self.events: Dict[event_types, Callable] = {}

    def is_directory(self) -&gt; bool:
        &#34;&#34;&#34;
        Determines if a given item is a `Directory`

        Returns:
            bool: `True` if the given item is a `Directory` otherwise `False`
        &#34;&#34;&#34;
        return type(self) == Directory

    def is_file(self) -&gt; bool:
        &#34;&#34;&#34;
        Determines if a given item is a `File`

        Returns:
            bool: `True` if the given item is a `File` otherwise `False`
        &#34;&#34;&#34;
        return type(self) == File

    def check_perm(self, perm: Literal[&#34;read&#34;, &#34;write&#34;, &#34;execute&#34;], computer) -&gt; Result:
        &#34;&#34;&#34;
        Checks if the current user has the given `perm`

        Args:
            perm (str): The permission to check (&#34;read&#34;, &#34;write&#34;, &#34;execute&#34;)
            computer: The current `Computer` instance

        Returns:
            Result: A `Result` object with the `success` flag set accordingly
        &#34;&#34;&#34;
        # If we&#34;re root (UID 0), return True because root has all permissions
        if computer.sys_geteuid() == 0:
            return Result(success=True)
        # If &#34;public&#34;, don&#34;t bother checking anything else
        if &#34;public&#34; in self.permissions[perm]:
            return Result(success=True)

        if &#34;group&#34; in self.permissions[perm]:
            if self.group_owner in computer.get_user_groups(computer.sys_geteuid()).data:
                return Result(success=True)

        if &#34;owner&#34; in self.permissions[perm]:
            if self.owner == computer.sys_geteuid():
                return Result(success=True)

        # No permission
        return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    def check_owner(self, computer) -&gt; Result:
        &#34;&#34;&#34;
        Checks if the given UID or GID is one of the owners (for chmod/chgrp/etc)

        Args:
            computer: The current `Computer` instance

        Returns:
            Result: A `Result` object with the `success` flag set accordingly
        &#34;&#34;&#34;
        # Get the list of user&#39;s groups
        groups = computer.get_user_groups(computer.sys_getuid()).data

        if self.owner == computer.sys_getuid() or self.group_owner in groups:
            return Result(success=True)
        else:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    def change_owner(self, computer, new_user_owner: Optional[int] = None,
                     new_group_owner: Optional[int] = None) -&gt; Result:
        &#34;&#34;&#34;
        Change the owner (user and/or group) of a given `File`/`Directory`, but check if the given UID should be allowed to first

        Args:
            computer: The current `Computer` instance
            new_user_owner (int): The UID of the new owner (user) of the `File`/`Directory`
            new_group_owner (int): The GID of the new owner (group) of the `File`/`Directory`

        Returns:
            Result: A `Result` with the `success` flag set accordingly
        &#34;&#34;&#34;
        caller_groups = computer.get_user_groups(computer.sys_getuid()).data
        # Check if the owner or group owner is correct or if we&#39;re root
        if computer.sys_geteuid() == self.owner or self.group_owner in caller_groups or computer.sys_geteuid() == 0:
            # We need at least one of the two params (uid/gid)
            # Using `if not new_user_owner/not new_group_owner` won&#39;t work because `not 0` (root group) == True (???)
            if new_user_owner is None and new_group_owner is None:
                return Result(success=False, message=ResultMessages.MISSING_ARGUMENT)
            else:
                # Same thing with uid 0
                if new_user_owner is not None:
                    # Confirm that the user exists
                    if computer.get_user(uid=new_user_owner).success:
                        self.owner = new_user_owner
                    else:
                        return Result(success=False, message=ResultMessages.NOT_FOUND)

                # Confirm that the new group exists
                # Same thing with gid 0
                if new_group_owner is not None:
                    # Confirm that the user exists
                    if computer.get_group(gid=new_group_owner).success:
                        self.group_owner = new_group_owner
                    else:
                        return Result(success=False, message=ResultMessages.NOT_FOUND)

                self.handle_event(&#34;change_owner&#34;)
                return Result(success=True)
        else:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    def pwd(self) -&gt; str:
        &#34;&#34;&#34;
        Get the full path of the `File` in the file system

        Returns:
            str: A complete file path starting at / (root)
        &#34;&#34;&#34;
        current_dir = self
        working_dir = []

        while True:
            # Check if we&#39;re at /
            working_dir.append(current_dir.name)
            if not current_dir.parent:
                break
            current_dir = current_dir.parent

        working_dir.reverse()
        working_dir = &#34;/&#34;.join(working_dir)
        # Try to remove double slash
        if working_dir.startswith(&#34;//&#34;):
            working_dir = working_dir[1:]

        return working_dir

    def delete(self, computer) -&gt; Result:
        &#34;&#34;&#34;
        Check if the `caller` has the proper permissions to delete a given file, then remove it

        Args:
            computer: The current computer object

        Returns:
            Result: A `Result` object with the `success` flag set accordingly
        &#34;&#34;&#34;
        if self.parent:
            # In unix, we need read+write permissions to delete
            if self.check_perm(&#34;read&#34;, computer).success and self.check_perm(&#34;write&#34;, computer).success:
                self.handle_event(&#34;delete&#34;)
                del self.parent.files[self.name]
                return Result(success=True)
            else:
                return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    def add_event_listener(self, event: event_types, function: Callable, when: Literal[&#34;before&#34;, &#34;after&#34;] = &#34;after&#34;):
        &#34;&#34;&#34;
        Bind a function to run whenever a given event fires.
        A `FSBaseObject` can only have one function per event type.
        If a function is already bound to the given event type, it will be overwritten.

        Args:
            event: The given event type to bind the given `function` to.
            Valid event types include: `read`, `write`, `move`, `perm`, `delete`
            &lt;ul&gt;
                &lt;li&gt;read - When a file is read from&lt;/li&gt;
                &lt;li&gt;write - When a file is written to&lt;/li&gt;
                &lt;li&gt;move - When a file is moved to a different location AKA: When a file&#39;s parent folder changes&lt;/li&gt;
                &lt;li&gt;perm - When a file&#39;s owner, group owner, or permissions changes&lt;/li&gt;
                &lt;li&gt;delete - Before a file is deleted&lt;/li&gt;
            &lt;/ul&gt;
            function: The function/method to be called when the given `event` is fired
            when (str): When the event is fired (for example, before the read happens, or after)

        Returns:
             Result: A `Result` with the `success` flag set accordingly.
        &#34;&#34;&#34;
        self.events[event] = function
        return Result(success=True)

    def remove_event_listener(self, event: event_types):
        &#34;&#34;&#34;
        Unbinds the current function from the given `event` type

        Args:
            event: The event type to unbind. Valid event types include: `read`, `write`, `move`, `perm`, `delete`

        Returns:
             Result: A `Result` with the `success` flag set accordingly.
        &#34;&#34;&#34;
        try:
            self.events.pop(event)
        except Exception:
            pass

        return Result(success=True)

    def handle_event(self, event: event_types):
        &#34;&#34;&#34;
        Handles executing the function bound to the given `event`

        Args:
            event: The event type to run. Valid event types include: `read`, `write`, `move`, `perm`, `delete`

        Returns:
             Result: A `Result` with the `success` flag set accordingly.
        &#34;&#34;&#34;
        if event in self.events.keys():
            self.events[event](self)

        return Result(success=True)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></li>
<li><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="blackhat.fs.FSBaseObject.atime"><code class="name">var <span class="ident">atime</span></code></dt>
<dd>
<div class="desc"><p>int: Access time; when file was last read from/accessed</p></div>
</dd>
<dt id="blackhat.fs.FSBaseObject.ctime"><code class="name">var <span class="ident">ctime</span></code></dt>
<dd>
<div class="desc"><p>int: Changed time; when the file"s metadata was last changed (ex. perms)</p></div>
</dd>
<dt id="blackhat.fs.FSBaseObject.mtime"><code class="name">var <span class="ident">mtime</span></code></dt>
<dd>
<div class="desc"><p>int: Modified time; when the file"s content was last modified</p></div>
</dd>
<dt id="blackhat.fs.FSBaseObject.permissions"><code class="name">var <span class="ident">permissions</span></code></dt>
<dd>
<div class="desc"><p>Reference:</p>
<p>27.5 Directories and the Set-User-ID and Set-Group-ID Bits</p>
<p>On most systems, if a directory’s set-group-ID bit is set, newly created subfiles inherit the same group as the directory, and newly created subdirectories inherit the set-group-ID bit of the parent directory. On a few systems, a directory’s set-user-ID bit has a similar effect on the ownership of new subfiles and the set-user-ID bits of new subdirectories. These mechanisms let users share files more easily, by lessening the need to use chmod or chown to share new files.</p>
<p>(<a href="https://www.gnu.org/software/coreutils/manual/html_node/Directory-Setuid-and-Setgid.html">https://www.gnu.org/software/coreutils/manual/html_node/Directory-Setuid-and-Setgid.html</a>)</p></div>
</dd>
<dt id="blackhat.fs.FSBaseObject.setuid"><code class="name">var <span class="ident">setuid</span></code></dt>
<dd>
<div class="desc"><p>Permissions for accessing the file. Default permissions; rw-r&ndash;r&ndash; (644)</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="blackhat.fs.FSBaseObject.add_event_listener"><code class="name flex">
<span>def <span class="ident">add_event_listener</span></span>(<span>self, event: Literal['read', 'write', 'move', 'change_perm', 'change_owner', 'delete'], function: Callable, when: Literal['before', 'after'] = 'after')</span>
</code></dt>
<dd>
<div class="desc"><p>Bind a function to run whenever a given event fires.
A <code><a title="blackhat.fs.FSBaseObject" href="#blackhat.fs.FSBaseObject">FSBaseObject</a></code> can only have one function per event type.
If a function is already bound to the given event type, it will be overwritten.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong></dt>
<dd>The given event type to bind the given <code>function</code> to.</dd>
</dl>
<p>Valid event types include: <code>read</code>, <code>write</code>, <code>move</code>, <code>perm</code>, <code>delete</code></p>
<ul>
<li>read - When a file is read from</li>
<li>write - When a file is written to</li>
<li>move - When a file is moved to a different location AKA: When a file's parent folder changes</li>
<li>perm - When a file's owner, group owner, or permissions changes</li>
<li>delete - Before a file is deleted</li>
</ul>
<dl>
<dt><strong><code>function</code></strong></dt>
<dd>The function/method to be called when the given <code>event</code> is fired</dd>
<dt><strong><code>when</code></strong> :&ensp;<code>str</code></dt>
<dd>When the event is fired (for example, before the read happens, or after)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> with the <code>success</code> flag set accordingly.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_event_listener(self, event: event_types, function: Callable, when: Literal[&#34;before&#34;, &#34;after&#34;] = &#34;after&#34;):
    &#34;&#34;&#34;
    Bind a function to run whenever a given event fires.
    A `FSBaseObject` can only have one function per event type.
    If a function is already bound to the given event type, it will be overwritten.

    Args:
        event: The given event type to bind the given `function` to.
        Valid event types include: `read`, `write`, `move`, `perm`, `delete`
        &lt;ul&gt;
            &lt;li&gt;read - When a file is read from&lt;/li&gt;
            &lt;li&gt;write - When a file is written to&lt;/li&gt;
            &lt;li&gt;move - When a file is moved to a different location AKA: When a file&#39;s parent folder changes&lt;/li&gt;
            &lt;li&gt;perm - When a file&#39;s owner, group owner, or permissions changes&lt;/li&gt;
            &lt;li&gt;delete - Before a file is deleted&lt;/li&gt;
        &lt;/ul&gt;
        function: The function/method to be called when the given `event` is fired
        when (str): When the event is fired (for example, before the read happens, or after)

    Returns:
         Result: A `Result` with the `success` flag set accordingly.
    &#34;&#34;&#34;
    self.events[event] = function
    return Result(success=True)</code></pre>
</details>
</dd>
<dt id="blackhat.fs.FSBaseObject.change_owner"><code class="name flex">
<span>def <span class="ident">change_owner</span></span>(<span>self, computer, new_user_owner: Optional[int] = None, new_group_owner: Optional[int] = None) ‑> <a title="blackhat.helpers.Result" href="helpers.html#blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Change the owner (user and/or group) of a given <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code>/<code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code>, but check if the given UID should be allowed to first</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>computer</code></strong></dt>
<dd>The current <code>Computer</code> instance</dd>
<dt><strong><code>new_user_owner</code></strong> :&ensp;<code>int</code></dt>
<dd>The UID of the new owner (user) of the <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code>/<code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code></dd>
<dt><strong><code>new_group_owner</code></strong> :&ensp;<code>int</code></dt>
<dd>The GID of the new owner (group) of the <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code>/<code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> with the <code>success</code> flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_owner(self, computer, new_user_owner: Optional[int] = None,
                 new_group_owner: Optional[int] = None) -&gt; Result:
    &#34;&#34;&#34;
    Change the owner (user and/or group) of a given `File`/`Directory`, but check if the given UID should be allowed to first

    Args:
        computer: The current `Computer` instance
        new_user_owner (int): The UID of the new owner (user) of the `File`/`Directory`
        new_group_owner (int): The GID of the new owner (group) of the `File`/`Directory`

    Returns:
        Result: A `Result` with the `success` flag set accordingly
    &#34;&#34;&#34;
    caller_groups = computer.get_user_groups(computer.sys_getuid()).data
    # Check if the owner or group owner is correct or if we&#39;re root
    if computer.sys_geteuid() == self.owner or self.group_owner in caller_groups or computer.sys_geteuid() == 0:
        # We need at least one of the two params (uid/gid)
        # Using `if not new_user_owner/not new_group_owner` won&#39;t work because `not 0` (root group) == True (???)
        if new_user_owner is None and new_group_owner is None:
            return Result(success=False, message=ResultMessages.MISSING_ARGUMENT)
        else:
            # Same thing with uid 0
            if new_user_owner is not None:
                # Confirm that the user exists
                if computer.get_user(uid=new_user_owner).success:
                    self.owner = new_user_owner
                else:
                    return Result(success=False, message=ResultMessages.NOT_FOUND)

            # Confirm that the new group exists
            # Same thing with gid 0
            if new_group_owner is not None:
                # Confirm that the user exists
                if computer.get_group(gid=new_group_owner).success:
                    self.group_owner = new_group_owner
                else:
                    return Result(success=False, message=ResultMessages.NOT_FOUND)

            self.handle_event(&#34;change_owner&#34;)
            return Result(success=True)
    else:
        return Result(success=False, message=ResultMessages.NOT_ALLOWED)</code></pre>
</details>
</dd>
<dt id="blackhat.fs.FSBaseObject.check_owner"><code class="name flex">
<span>def <span class="ident">check_owner</span></span>(<span>self, computer) ‑> <a title="blackhat.helpers.Result" href="helpers.html#blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the given UID or GID is one of the owners (for chmod/chgrp/etc)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>computer</code></strong></dt>
<dd>The current <code>Computer</code> instance</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> object with the <code>success</code> flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_owner(self, computer) -&gt; Result:
    &#34;&#34;&#34;
    Checks if the given UID or GID is one of the owners (for chmod/chgrp/etc)

    Args:
        computer: The current `Computer` instance

    Returns:
        Result: A `Result` object with the `success` flag set accordingly
    &#34;&#34;&#34;
    # Get the list of user&#39;s groups
    groups = computer.get_user_groups(computer.sys_getuid()).data

    if self.owner == computer.sys_getuid() or self.group_owner in groups:
        return Result(success=True)
    else:
        return Result(success=False, message=ResultMessages.NOT_ALLOWED)</code></pre>
</details>
</dd>
<dt id="blackhat.fs.FSBaseObject.check_perm"><code class="name flex">
<span>def <span class="ident">check_perm</span></span>(<span>self, perm: Literal['read', 'write', 'execute'], computer) ‑> <a title="blackhat.helpers.Result" href="helpers.html#blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the current user has the given <code>perm</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>perm</code></strong> :&ensp;<code>str</code></dt>
<dd>The permission to check ("read", "write", "execute")</dd>
<dt><strong><code>computer</code></strong></dt>
<dd>The current <code>Computer</code> instance</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> object with the <code>success</code> flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_perm(self, perm: Literal[&#34;read&#34;, &#34;write&#34;, &#34;execute&#34;], computer) -&gt; Result:
    &#34;&#34;&#34;
    Checks if the current user has the given `perm`

    Args:
        perm (str): The permission to check (&#34;read&#34;, &#34;write&#34;, &#34;execute&#34;)
        computer: The current `Computer` instance

    Returns:
        Result: A `Result` object with the `success` flag set accordingly
    &#34;&#34;&#34;
    # If we&#34;re root (UID 0), return True because root has all permissions
    if computer.sys_geteuid() == 0:
        return Result(success=True)
    # If &#34;public&#34;, don&#34;t bother checking anything else
    if &#34;public&#34; in self.permissions[perm]:
        return Result(success=True)

    if &#34;group&#34; in self.permissions[perm]:
        if self.group_owner in computer.get_user_groups(computer.sys_geteuid()).data:
            return Result(success=True)

    if &#34;owner&#34; in self.permissions[perm]:
        if self.owner == computer.sys_geteuid():
            return Result(success=True)

    # No permission
    return Result(success=False, message=ResultMessages.NOT_ALLOWED)</code></pre>
</details>
</dd>
<dt id="blackhat.fs.FSBaseObject.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, computer) ‑> <a title="blackhat.helpers.Result" href="helpers.html#blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Check if the <code>caller</code> has the proper permissions to delete a given file, then remove it</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>computer</code></strong></dt>
<dd>The current computer object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> object with the <code>success</code> flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, computer) -&gt; Result:
    &#34;&#34;&#34;
    Check if the `caller` has the proper permissions to delete a given file, then remove it

    Args:
        computer: The current computer object

    Returns:
        Result: A `Result` object with the `success` flag set accordingly
    &#34;&#34;&#34;
    if self.parent:
        # In unix, we need read+write permissions to delete
        if self.check_perm(&#34;read&#34;, computer).success and self.check_perm(&#34;write&#34;, computer).success:
            self.handle_event(&#34;delete&#34;)
            del self.parent.files[self.name]
            return Result(success=True)
        else:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)</code></pre>
</details>
</dd>
<dt id="blackhat.fs.FSBaseObject.handle_event"><code class="name flex">
<span>def <span class="ident">handle_event</span></span>(<span>self, event: Literal['read', 'write', 'move', 'change_perm', 'change_owner', 'delete'])</span>
</code></dt>
<dd>
<div class="desc"><p>Handles executing the function bound to the given <code>event</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong></dt>
<dd>The event type to run. Valid event types include: <code>read</code>, <code>write</code>, <code>move</code>, <code>perm</code>, <code>delete</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> with the <code>success</code> flag set accordingly.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_event(self, event: event_types):
    &#34;&#34;&#34;
    Handles executing the function bound to the given `event`

    Args:
        event: The event type to run. Valid event types include: `read`, `write`, `move`, `perm`, `delete`

    Returns:
         Result: A `Result` with the `success` flag set accordingly.
    &#34;&#34;&#34;
    if event in self.events.keys():
        self.events[event](self)

    return Result(success=True)</code></pre>
</details>
</dd>
<dt id="blackhat.fs.FSBaseObject.is_directory"><code class="name flex">
<span>def <span class="ident">is_directory</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if a given item is a <code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if the given item is a <code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code> otherwise <code>False</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_directory(self) -&gt; bool:
    &#34;&#34;&#34;
    Determines if a given item is a `Directory`

    Returns:
        bool: `True` if the given item is a `Directory` otherwise `False`
    &#34;&#34;&#34;
    return type(self) == Directory</code></pre>
</details>
</dd>
<dt id="blackhat.fs.FSBaseObject.is_file"><code class="name flex">
<span>def <span class="ident">is_file</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if a given item is a <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if the given item is a <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code> otherwise <code>False</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_file(self) -&gt; bool:
    &#34;&#34;&#34;
    Determines if a given item is a `File`

    Returns:
        bool: `True` if the given item is a `File` otherwise `False`
    &#34;&#34;&#34;
    return type(self) == File</code></pre>
</details>
</dd>
<dt id="blackhat.fs.FSBaseObject.pwd"><code class="name flex">
<span>def <span class="ident">pwd</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the full path of the <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code> in the file system</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A complete file path starting at / (root)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pwd(self) -&gt; str:
    &#34;&#34;&#34;
    Get the full path of the `File` in the file system

    Returns:
        str: A complete file path starting at / (root)
    &#34;&#34;&#34;
    current_dir = self
    working_dir = []

    while True:
        # Check if we&#39;re at /
        working_dir.append(current_dir.name)
        if not current_dir.parent:
            break
        current_dir = current_dir.parent

    working_dir.reverse()
    working_dir = &#34;/&#34;.join(working_dir)
    # Try to remove double slash
    if working_dir.startswith(&#34;//&#34;):
        working_dir = working_dir[1:]

    return working_dir</code></pre>
</details>
</dd>
<dt id="blackhat.fs.FSBaseObject.remove_event_listener"><code class="name flex">
<span>def <span class="ident">remove_event_listener</span></span>(<span>self, event: Literal['read', 'write', 'move', 'change_perm', 'change_owner', 'delete'])</span>
</code></dt>
<dd>
<div class="desc"><p>Unbinds the current function from the given <code>event</code> type</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong></dt>
<dd>The event type to unbind. Valid event types include: <code>read</code>, <code>write</code>, <code>move</code>, <code>perm</code>, <code>delete</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> with the <code>success</code> flag set accordingly.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_event_listener(self, event: event_types):
    &#34;&#34;&#34;
    Unbinds the current function from the given `event` type

    Args:
        event: The event type to unbind. Valid event types include: `read`, `write`, `move`, `perm`, `delete`

    Returns:
         Result: A `Result` with the `success` flag set accordingly.
    &#34;&#34;&#34;
    try:
        self.events.pop(event)
    except Exception:
        pass

    return Result(success=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="blackhat.fs.File"><code class="flex name class">
<span>class <span class="ident">File</span></span>
<span>(</span><span>name: str, content: str, parent: <a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a>, owner: int, group_owner: int)</span>
</code></dt>
<dd>
<div class="desc"><p>The class object representing a file in the file system</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the given <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code></dd>
<dt><strong><code>content</code></strong> :&ensp;<code>str</code></dt>
<dd>The content within the given file. May be blank (empty string)</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code></dt>
<dd>The <code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code> one level up the tree</dd>
<dt><strong><code>owner</code></strong> :&ensp;<code>int</code></dt>
<dd>The UID of the owner of the <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code>/<code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code></dd>
<dt><strong><code>group_owner</code></strong> :&ensp;<code>int</code></dt>
<dd>The GID of the owner of the <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code>/`Directory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class File(FSBaseObject):
    def __init__(self, name: str, content: str, parent: &#34;Directory&#34;, owner: int, group_owner: int) -&gt; None:
        &#34;&#34;&#34;
        The class object representing a file in the file system

        Args:
            name (str): The name of the given `File`
            content (str): The content within the given file. May be blank (empty string)
            parent (Directory): The `Directory` one level up the tree
            owner (int): The UID of the owner of the `File`/`Directory`
            group_owner (int): The GID of the owner of the `File`/`Directory
        &#34;&#34;&#34;
        super().__init__(name, parent, owner, group_owner)
        self.content = content
        self.size = sys.getsizeof(self.name + self.content)

        if self.parent:
            self.parent.add_file(self)

    def read(self, computer) -&gt; Result:
        &#34;&#34;&#34;
        Check if the current UID has permission to read the content of the file. Afterwards, return the content if allowed

        Args:
            computer: The current `Computer` instance

        Returns: Result: A `Result` object with the `success` flag set and the `data` flag set with the  file&#39;s content if permitted
        &#34;&#34;&#34;
        if self.check_perm(&#34;read&#34;, computer).success:
            self.handle_event(&#34;read&#34;)
            return Result(success=True, data=self.content)
        else:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    def write(self, data: str, computer) -&gt; Result:
        &#34;&#34;&#34;
        Check if the current UID has permission to write to the file. Update the file&#39;s contents if allowed

        Args:
            data (str): The new content to write to the `File`
            computer: The current `Computer` instance

        Returns:
            Result: A `Result` object with the `success` flag accordingly
        &#34;&#34;&#34;
        if self.check_perm(&#34;write&#34;, computer).success:
            self.content = data
            self.update_size()
            self.handle_event(&#34;write&#34;)
            return Result(success=True)
        else:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    def append(self, data: str, computer) -&gt; Result:
        &#34;&#34;&#34;
        Check if the current UID has permission to write to the file. Append to the file&#39;s contents if allowed

        Args:
            data (str): The content to append to the `File`s current content
            computer: The current `Computer` instance

        Returns:
            Result: A `Result` object with the `success` flag accordingly
        &#34;&#34;&#34;
        # NOTE: This may be unnecessary, we&#34;ll find out later
        if self.check_perm(&#34;write&#34;, computer).success:
            self.content += data
            self.update_size()
            self.handle_event(&#34;write&#34;)
            return Result(success=True)
        else:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    def update_size(self) -&gt; None:
        &#34;&#34;&#34;
        Calculates the size of the `File` and set in the object.
        Also, recursively tells it&#39;s parent to update its size.

        Returns:
            None
        &#34;&#34;&#34;
        self.size = sys.getsizeof(self.name + self.content)

        # First, update our own size
        self.size = sys.getsizeof(self.content + self.name)
        # Now, recursively update our parent&#34;s size
        if self.parent:
            self.parent.update_size()

    def get_perm_octal(self):
        result = 0o000

        # TODO: Find a less shit way to do this
        # Owner
        if &#34;owner&#34; in self.permissions[&#34;read&#34;]:
            result += 0o400

        if &#34;owner&#34; in self.permissions[&#34;write&#34;]:
            result += 0o200

        if &#34;owner&#34; in self.permissions[&#34;execute&#34;]:
            result += 0o100

        # Group
        if &#34;group&#34; in self.permissions[&#34;read&#34;]:
            result += 0o040

        if &#34;group&#34; in self.permissions[&#34;write&#34;]:
            result += 0o020

        if &#34;group&#34; in self.permissions[&#34;execute&#34;]:
            result += 0o010

        # Public
        if &#34;public&#34; in self.permissions[&#34;read&#34;]:
            result += 0o004

        if &#34;public&#34; in self.permissions[&#34;write&#34;]:
            result += 0o002

        if &#34;public&#34; in self.permissions[&#34;execute&#34;]:
            result += 0o001

        return result

    def __str__(self):
        return f&#34;{self.name} - {self.owner}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="blackhat.fs.FSBaseObject" href="#blackhat.fs.FSBaseObject">FSBaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="blackhat.fs.File.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, data: str, computer) ‑> <a title="blackhat.helpers.Result" href="helpers.html#blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Check if the current UID has permission to write to the file. Append to the file's contents if allowed</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>str</code></dt>
<dd>The content to append to the <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code>s current content</dd>
<dt><strong><code>computer</code></strong></dt>
<dd>The current <code>Computer</code> instance</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> object with the <code>success</code> flag accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, data: str, computer) -&gt; Result:
    &#34;&#34;&#34;
    Check if the current UID has permission to write to the file. Append to the file&#39;s contents if allowed

    Args:
        data (str): The content to append to the `File`s current content
        computer: The current `Computer` instance

    Returns:
        Result: A `Result` object with the `success` flag accordingly
    &#34;&#34;&#34;
    # NOTE: This may be unnecessary, we&#34;ll find out later
    if self.check_perm(&#34;write&#34;, computer).success:
        self.content += data
        self.update_size()
        self.handle_event(&#34;write&#34;)
        return Result(success=True)
    else:
        return Result(success=False, message=ResultMessages.NOT_ALLOWED)</code></pre>
</details>
</dd>
<dt id="blackhat.fs.File.get_perm_octal"><code class="name flex">
<span>def <span class="ident">get_perm_octal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_perm_octal(self):
    result = 0o000

    # TODO: Find a less shit way to do this
    # Owner
    if &#34;owner&#34; in self.permissions[&#34;read&#34;]:
        result += 0o400

    if &#34;owner&#34; in self.permissions[&#34;write&#34;]:
        result += 0o200

    if &#34;owner&#34; in self.permissions[&#34;execute&#34;]:
        result += 0o100

    # Group
    if &#34;group&#34; in self.permissions[&#34;read&#34;]:
        result += 0o040

    if &#34;group&#34; in self.permissions[&#34;write&#34;]:
        result += 0o020

    if &#34;group&#34; in self.permissions[&#34;execute&#34;]:
        result += 0o010

    # Public
    if &#34;public&#34; in self.permissions[&#34;read&#34;]:
        result += 0o004

    if &#34;public&#34; in self.permissions[&#34;write&#34;]:
        result += 0o002

    if &#34;public&#34; in self.permissions[&#34;execute&#34;]:
        result += 0o001

    return result</code></pre>
</details>
</dd>
<dt id="blackhat.fs.File.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, computer) ‑> <a title="blackhat.helpers.Result" href="helpers.html#blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Check if the current UID has permission to read the content of the file. Afterwards, return the content if allowed</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>computer</code></strong></dt>
<dd>The current <code>Computer</code> instance</dd>
</dl>
<p>Returns: Result: A <code>Result</code> object with the <code>success</code> flag set and the <code>data</code> flag set with the
file's content if permitted</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, computer) -&gt; Result:
    &#34;&#34;&#34;
    Check if the current UID has permission to read the content of the file. Afterwards, return the content if allowed

    Args:
        computer: The current `Computer` instance

    Returns: Result: A `Result` object with the `success` flag set and the `data` flag set with the  file&#39;s content if permitted
    &#34;&#34;&#34;
    if self.check_perm(&#34;read&#34;, computer).success:
        self.handle_event(&#34;read&#34;)
        return Result(success=True, data=self.content)
    else:
        return Result(success=False, message=ResultMessages.NOT_ALLOWED)</code></pre>
</details>
</dd>
<dt id="blackhat.fs.File.update_size"><code class="name flex">
<span>def <span class="ident">update_size</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the size of the <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code> and set in the object.
Also, recursively tells it's parent to update its size.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_size(self) -&gt; None:
    &#34;&#34;&#34;
    Calculates the size of the `File` and set in the object.
    Also, recursively tells it&#39;s parent to update its size.

    Returns:
        None
    &#34;&#34;&#34;
    self.size = sys.getsizeof(self.name + self.content)

    # First, update our own size
    self.size = sys.getsizeof(self.content + self.name)
    # Now, recursively update our parent&#34;s size
    if self.parent:
        self.parent.update_size()</code></pre>
</details>
</dd>
<dt id="blackhat.fs.File.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, data: str, computer) ‑> <a title="blackhat.helpers.Result" href="helpers.html#blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Check if the current UID has permission to write to the file. Update the file's contents if allowed</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>str</code></dt>
<dd>The new content to write to the <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code></dd>
<dt><strong><code>computer</code></strong></dt>
<dd>The current <code>Computer</code> instance</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> object with the <code>success</code> flag accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, data: str, computer) -&gt; Result:
    &#34;&#34;&#34;
    Check if the current UID has permission to write to the file. Update the file&#39;s contents if allowed

    Args:
        data (str): The new content to write to the `File`
        computer: The current `Computer` instance

    Returns:
        Result: A `Result` object with the `success` flag accordingly
    &#34;&#34;&#34;
    if self.check_perm(&#34;write&#34;, computer).success:
        self.content = data
        self.update_size()
        self.handle_event(&#34;write&#34;)
        return Result(success=True)
    else:
        return Result(success=False, message=ResultMessages.NOT_ALLOWED)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="blackhat.fs.FSBaseObject" href="#blackhat.fs.FSBaseObject">FSBaseObject</a></b></code>:
<ul class="hlist">
<li><code><a title="blackhat.fs.FSBaseObject.add_event_listener" href="#blackhat.fs.FSBaseObject.add_event_listener">add_event_listener</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.atime" href="#blackhat.fs.FSBaseObject.atime">atime</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.change_owner" href="#blackhat.fs.FSBaseObject.change_owner">change_owner</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.check_owner" href="#blackhat.fs.FSBaseObject.check_owner">check_owner</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.check_perm" href="#blackhat.fs.FSBaseObject.check_perm">check_perm</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.ctime" href="#blackhat.fs.FSBaseObject.ctime">ctime</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.delete" href="#blackhat.fs.FSBaseObject.delete">delete</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.handle_event" href="#blackhat.fs.FSBaseObject.handle_event">handle_event</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.is_directory" href="#blackhat.fs.FSBaseObject.is_directory">is_directory</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.is_file" href="#blackhat.fs.FSBaseObject.is_file">is_file</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.mtime" href="#blackhat.fs.FSBaseObject.mtime">mtime</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.permissions" href="#blackhat.fs.FSBaseObject.permissions">permissions</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.pwd" href="#blackhat.fs.FSBaseObject.pwd">pwd</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.remove_event_listener" href="#blackhat.fs.FSBaseObject.remove_event_listener">remove_event_listener</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.setuid" href="#blackhat.fs.FSBaseObject.setuid">setuid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="blackhat.fs.StandardFS"><code class="flex name class">
<span>class <span class="ident">StandardFS</span></span>
<span>(</span><span>computer)</span>
</code></dt>
<dd>
<div class="desc"><p>The class object representing a file system that belongs to a <code>Computer</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>computer</code></strong> :&ensp;<code>Computer</code></dt>
<dd>The <code>Computer</code> that the given file system belongs to</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StandardFS:
    def __init__(self, computer) -&gt; None:
        &#34;&#34;&#34;
        The class object representing a file system that belongs to a `Computer`

        Args:
            computer (Computer): The `Computer` that the given file system belongs to
        &#34;&#34;&#34;
        self.computer = computer

        # The filesystem root (/) (owned by root)
        self.files = Directory(&#34;/&#34;, None, 0, 0)
        self.files.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;],
                                  &#34;write&#34;: [&#34;owner&#34;, &#34;group&#34;],
                                  &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}

        self.init()

    def init(self) -&gt; None:
        &#34;&#34;&#34;
        All the functions required to setup a new filesystem

        Returns:
            None
        &#34;&#34;&#34;
        # Setup the directory structure in the file system (Unix FHS)
        for dir in [&#34;bin&#34;, &#34;etc&#34;, &#34;home&#34;, &#34;lib&#34;, &#34;root&#34;, &#34;run&#34;, &#34;proc&#34;, &#34;tmp&#34;, &#34;usr&#34;, &#34;var&#34;]:
            directory = Directory(dir, self.files, 0, 0)
            # Special case for /tmp (read and write by everyone)
            if dir == &#34;tmp&#34;:
                directory.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;],
                                         &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}
            elif dir == &#34;proc&#34;:
                directory.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [],
                                         &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}
            else:
                # TODO: Change this to be more accurate
                # (rwx rw- r--)
                directory.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;, &#34;group&#34;],
                                         &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}

        # TODO: Replace all these with `mkdir -p` commands
        # NOTE: FS doesn&#39;t exist at this point so running commands might not be possible (since some commands need fs)
        # Individually setup each directory in the root
        self.setup_bin()
        self.setup_etc()
        # self.setup_home()
        # self.setup_lib()
        self.setup_proc()
        self.setup_root()
        self.setup_run()
        # self.setup_tmp()
        self.setup_usr()
        self.setup_var()

    def setup_bin(self) -&gt; None:
        &#34;&#34;&#34;
        Read all the files in the `client.blackhat.bin` directory and create a virtual file in the fs.
        All these files represent binaries in the system

        Returns:
            None
        &#34;&#34;&#34;
        bin_dir: Directory = self.files.find(&#34;bin&#34;)

        for file in os.listdir(&#34;./blackhat/bin&#34;):
            # Ignore the __init__.py and __pycache__ because those aren&#39;t bins (auto generated)
            if file not in [&#34;__init__.py&#34;, &#34;__pycache__&#34;, &#34;installable&#34;]:
                with open(os.path.join(&#34;./blackhat/bin&#34;, file), &#34;r&#34;) as f:
                    source_code = f.read()
                current_file = File(file.replace(&#34;.py&#34;, &#34;&#34;), source_code, bin_dir, 0, 0)
                current_file.size = os.path.getsize(os.path.join(&#34;./blackhat/bin&#34;, file))

                current_file.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;],
                                            &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}
                # Add setuid bit to specific binaries
                if file.replace(&#34;.py&#34;, &#34;&#34;) in [&#34;sudo&#34;, &#34;su&#34;, &#34;passwd&#34;]:
                    current_file.setuid = True

    def setup_etc(self) -&gt; None:
        &#34;&#34;&#34;
        Sets up:
        &lt;ul&gt;
            &lt;li&gt;/etc/passwd - Contains the username, hashed password, and UID of all the users in the system&lt;/li&gt;
            &lt;li&gt;/etc/shadow - Contains the username, and hashed password of all users in the system&lt;/li&gt;
            &lt;li&gt;/etc/groups - Contains the list of groups in the systems (name, GID)&lt;/li&gt;
            &lt;li&gt;/etc/hostname - The hostname of the given `Computer`&lt;/li&gt;
            &lt;li&gt;/etc/skel -  A &#34;skeleton&#34; needed to create a users home folder (located in /home/&lt;USERNAME&gt;)&lt;/li&gt;
            &lt;li&gt;/etc/sudoers - The file that contains all of the sudo permissions&lt;/li&gt;
            &lt;li&gt;/etc/apt/sources.list - Contains urls of apt repo servers&lt;/li&gt;
            &lt;li&gt;/etc/resolv.conf - Contains the list of dns servers&lt;/li&gt;
        &lt;/ul&gt;

        Returns:
            None
        &#34;&#34;&#34;

        # EventHandler functions for /etc/passwd, /etc/shadow, and /etc/group
        def update_passwd(file):
            content = file.content.split(&#34;\n&#34;)

            for item in content:
                subitems = item.split(&#34;:&#34;)
                # An item in the list with a length of 1 or less are usually blank lines
                if len(subitems) &gt; 1:
                    username, password, uid, primary_gid = subitems

                    try:
                        uid = int(uid)
                        primary_gid = int(primary_gid)
                    except Exception:
                        return

                    # Now we want to get the user by username
                    user_lookup = self.computer.get_user(username=username)

                    # If we don&#39;t find the user, that means we added a new user
                    if not user_lookup.success:
                        # Make sure no user has the uid
                        if not self.computer.get_user(uid=uid).success:
                            # Add the user
                            self.computer.add_user(username, password, uid, plaintext=False)
                            self.computer.add_group(name=username, gid=primary_gid)
                            self.computer.add_user_to_group(uid, primary_gid, &#34;primary&#34;)
                    else:
                        # We have a user, now lets check if any of the data has changed
                        user = user_lookup.data

                        # If the password is &#39;x&#39;, that password is in the /etc/shadow file and should be ignored here
                        if user.password != password and password != &#34;x&#34;:
                            result = self.computer.change_user_password(user.uid, password, plaintext=False)
                            if result.success:
                                user.password = password

                        if user.uid != uid:
                            result = self.computer.change_user_uid(user.uid, uid)
                            if result.success:
                                user.uid = uid

                        # If the GID changed, we want to:
                        # 1. Make sure the new GID exists
                        # 2. Remove the user&#39;s old primary gid membership
                        # 3. Add a the user to the new gid as primary
                        user_primary_gid = self.computer.get_user_primary_group(user.uid).data[0]

                        if user_primary_gid != primary_gid:
                            if self.computer.get_group(gid=primary_gid).success:
                                self.computer.remove_user_from_group(uid=user.uid, gid=user_primary_gid)
                                self.computer.add_user_to_group(user.uid, primary_gid, &#34;primary&#34;)

                    # Will automatically remove incorrect changes
                    self.computer.sync_user_and_group_files()

        def update_shadow(file):
            content = file.content.split(&#34;\n&#34;)

            for item in content:
                subitems = item.split(&#34;:&#34;)
                # An item in the list with a length of 1 or less are usually blank lines
                if len(subitems) &gt; 1:
                    username, password = subitems

                    # Now we want to get the user by username
                    user_lookup = self.computer.get_user(username=username)

                    # We have a user, now lets check if any of the data has changed
                    user = user_lookup.data

                    # If the password is &#39;x&#39;, that password is in the /etc/shadow file and should be ignored here
                    if user.password != password and password != &#34;x&#34;:
                        result = self.computer.change_user_password(user.uid, password, plaintext=False)
                        if result.success:
                            user.password = password

                # Will automatically remove incorrect changes
                self.computer.sync_user_and_group_files()

        def update_group(file):
            content = file.content.split(&#34;\n&#34;)

            for item in content:
                subitems = item.split(&#34;:&#34;)
                # An item in the list with a length of 1 or less are usually blank lines
                if len(subitems) &gt; 1:
                    group_name, password, gid, group_users = subitems

                    try:
                        uid = int(gid)
                    except Exception:
                        return

                    # Now we want to get the group by group name
                    group_lookup = self.computer.get_group(name=group_name)

                    # If we don&#39;t find the user, that means we added a new user
                    if not group_lookup.success:
                        # Make sure no group has the gid
                        if not self.computer.get_group(gid=gid).success:
                            # Add the group
                            self.computer.add_group(group_name, gid)
                            # TODO: Add users to the group by last param
                    else:
                        # We have a group, now lets check if any of the data has changed
                        group = group_lookup.data
                        # TODO: Add changes here

                    # Will automatically remove incorrect changes
                    self.computer.sync_user_and_group_files()

        etc_dir: Directory = self.files.find(&#34;etc&#34;)
        # Create the /etc/passwd file
        passwd_file: File = File(&#34;passwd&#34;, f&#34;&#34;, etc_dir, 0, 0)

        passwd_file.add_event_listener(&#34;write&#34;, update_passwd)

        # Create the /etc/shadow file and change its perms (rw-------)
        shadow_file: File = File(&#34;shadow&#34;, f&#34;&#34;, etc_dir, 0, 0)
        shadow_file.permissions = {&#34;read&#34;: [&#34;owner&#34;], &#34;write&#34;: [&#34;owner&#34;], &#34;execute&#34;: []}
        shadow_file.add_event_listener(&#34;write&#34;, update_shadow)

        # Create the /etc/groups file
        group_file: File = File(&#34;group&#34;, f&#34;root:x:0&#34;, etc_dir, 0, 0)
        group_file.add_event_listener(&#34;write&#34;, update_group)

        # /etc/skel (home dir template)
        skel_dir: Directory = Directory(&#34;skel&#34;, etc_dir, 0, 0)

        for dir in [&#34;Desktop&#34;, &#34;Documents&#34;, &#34;Downloads&#34;, &#34;Music&#34;, &#34;Pictures&#34;, &#34;Public&#34;, &#34;Templates&#34;, &#34;Videos&#34;]:
            current_dir = Directory(dir, skel_dir, 0, 0)
            current_dir.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;],
                                       &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}

        # /etc/skel/.shellrc (.bashrc/.zshrc equivalent)
        DEFAULT_SHELLRC_CONTENT = &#34;alias lsa=ls -l -a\n&#34; \
                                  &#34;alias la=ls -a\n&#34; \
                                  &#34;alias ll=ls -l\n&#34;

        File(&#34;.shellrc&#34;, DEFAULT_SHELLRC_CONTENT, skel_dir, 0, 0)

        # /etc/hostname (holds system hostname)
        # Stupid windows style default hostnames (for fun, might change later)
        new_hostname = f&#34;DESKTOP-{&#39;&#39;.join([choice(ascii_uppercase + digits) for _ in range(7)])}&#34;
        File(&#34;hostname&#34;, new_hostname, etc_dir, 0, 0)

        # /etc/sudoers (holds sudo permissions)
        # Sudoers has permissions r--r-----
        sudoers_file: File = File(&#34;sudoers&#34;, &#34;root ALL=(ALL) ALL\n&#34;, etc_dir, 0, 0)
        sudoers_file.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;], &#34;write&#34;: [], &#34;execute&#34;: []}

        # /etc/apt/sources.list
        apt_dir: Directory = Directory(&#34;apt&#34;, etc_dir, 0, 0)

        File(&#34;sources.list&#34;, &#34;&#34;, apt_dir, 0, 0)

        # /etc/resolv.conf
        File(&#34;resolv.conf&#34;, &#34;nameserver 1.1.1.1&#34;, etc_dir, 0, 0)

    def setup_proc(self) -&gt; None:
        &#34;&#34;&#34;
        Sets up:
        &lt;ul&gt;
            &lt;li&gt;/proc/uptime - Contains the amount of seconds since the system was booted&lt;/li&gt;
        &lt;/ul&gt;

        Returns:
            None
        &#34;&#34;&#34;

        # EventHandler functions for /proc/uptime
        def update_uptime(file):
            file.content = str((datetime.datetime.now() - self.computer.boot_time).total_seconds())

        proc_dir: Directory = self.files.find(&#34;proc&#34;)
        # Create the /proc/uptime file
        uptime_file: File = File(&#34;uptime&#34;, f&#34;&#34;, proc_dir, 0, 0)
        uptime_file.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [], &#34;execute&#34;: []}

        uptime_file.add_event_listener(&#34;read&#34;, update_uptime, when=&#34;before&#34;)

    def setup_root(self) -&gt; None:
        &#34;&#34;&#34;
        Since the root user is different from a &#34;standard&#34; user, root&#39;s home folder needs to be setup separately.
        Otherwise, the format of root&#39;s home folder is the same as any other user

        Returns:
            None
        &#34;&#34;&#34;
        # Create /root/.shellrc
        root_dir: Directory = self.files.find(&#34;root&#34;)

        File(&#34;.shellrc&#34;, &#34;export HOME=/root\nexport USER=root&#34;, root_dir, 0, 0)

    def setup_run(self) -&gt; None:
        &#34;&#34;&#34;
        Sets up:
        &lt;ul&gt;
            &lt;li&gt;/run/sudo/ts/ - Contains auth timeout timestamps for &lt;code&gt;sudo&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;

        Returns:
            None
        &#34;&#34;&#34;
        run_dir: Directory = self.files.find(&#34;run&#34;)

        # Create /run/sudo and /run/sudo/ts
        run_sudo: Directory = Directory(&#34;sudo&#34;, run_dir, 0, 0)
        run_sudo.permissions = {&#34;read&#34;: [&#34;owner&#34;], &#34;write&#34;: [&#34;owner&#34;], &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}

        run_sudo_ts: Directory = Directory(&#34;ts&#34;, run_sudo, 0, 0)
        run_sudo_ts.permissions = {&#34;read&#34;: [&#34;owner&#34;], &#34;write&#34;: [&#34;owner&#34;], &#34;execute&#34;: [&#34;owner&#34;]}

    def setup_usr(self) -&gt; None:
        &#34;&#34;&#34;
        Sets up:
        &lt;ul&gt;
            &lt;li&gt;/usr/share/man - Contains all the &#34;man pages&#34;, or instruction manuals, for all the system binaries&lt;/li&gt;
            &lt;li&gt;/usr/bin - &#34;Aftermarket&#34; installed packages (apt) &lt;/li&gt;
        &lt;/ul&gt;

        Returns:
            None
        &#34;&#34;&#34;
        # Setup /usr/share
        usr_dir: Directory = self.files.find(&#34;usr&#34;)

        share_dir: Directory = Directory(&#34;share&#34;, usr_dir, 0, 0)

        # /usr/share/man
        Directory(&#34;man&#34;, share_dir, 0, 0)

        self.generate_manpages()

        def generate_manpages(file):
            self.generate_manpages()

        bin_dir: Directory = Directory(&#34;bin&#34;, usr_dir, 0, 0)
        bin_dir.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;],
                               &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}
        bin_dir.add_event_listener(&#34;write&#34;, generate_manpages)

    def setup_var(self) -&gt; None:
        &#34;&#34;&#34;
        Sets up:
        &lt;ul&gt;
            &lt;li&gt;/var/log - Contains various log files&lt;/li&gt;
            &lt;li&gt;/var/log/syslog - Logs various information about the given `Computer`&lt;/li&gt;
            &lt;li&gt;/var/log/auth.log - Logs information about authentication attempts&lt;/li&gt;
            &lt;li&gt;/var/lib/dpkg/status - The list of installed packages by apt&lt;/li&gt;
            &lt;li&gt;/var/www/html - Default location for web content served by web servers&lt;/li&gt;
        &lt;/ul&gt;

        Returns:
            None
        &#34;&#34;&#34;
        # This should exist at runtime
        var_dir: Directory = self.files.find(&#34;var&#34;)

        # Create /var/log
        log_dir: Directory = Directory(&#34;log&#34;, var_dir, 0, 0)

        # Create the `syslog` in /var/log
        File(&#34;syslog&#34;, &#34;&#34;, log_dir, 0, 0)

        # Create /var/lib/dpkg/status
        lib_dir: Directory = Directory(&#34;lib&#34;, var_dir, 0, 0)

        dpkg_dir: Directory = Directory(&#34;dpkg&#34;, lib_dir, 0, 0)

        File(&#34;status&#34;, &#34;&#34;, dpkg_dir, 0, 0)

        # Create /var/www/html
        www_dir: Directory = Directory(&#34;www&#34;, var_dir, 0, 0)

        Directory(&#34;html&#34;, www_dir, 0, 0)

    def find(self, pathname: str) -&gt; Result:
        &#34;&#34;&#34;
        Try to find a given file anywhere in the file system based on a given `pathname`

        Args:
            pathname (str): The full (absolute or relative) path of the file

        Returns:
            Result: A `Result` with the `success` flag set accordingly and the `data` flag with the found `File` or `Directory` if the file was found
        &#34;&#34;&#34;

        # Special cases
        # Replace &#39;~&#39; with $HOME (if exists)
        get_home_env_var = self.computer.get_env(&#34;HOME&#34;)
        if get_home_env_var:
            pathname = pathname.replace(&#34;~&#34;, get_home_env_var)

        # Replace all instances of &#34;\&#34; with &#34;/&#34; (because windows)
        pathname = pathname.replace(&#34;\\&#34;, &#34;/&#34;)

        if pathname == &#34;/&#34;:
            return Result(success=True, data=self.files)

        if pathname == &#34;.&#34;:
            return Result(success=True, data=self.computer.sys_getcwd())

        if pathname == &#34;..&#34;:
            # Check if the directory has a parent
            # If it doesn&#39;t, we can assume that we&#39;re at /
            # In the case of /, just return /
            if not self.computer.sys_getcwd().parent:
                return Result(success=True, data=self.files)
            else:
                return Result(success=True, data=self.computer.sys_getcwd().parent)

        if pathname == &#34;...&#34;:
            # Check if the directory has a parent
            # If it doesn&#39;t, we can assume that we&#39;re at /
            # In the case of /, just return /
            # And then do it again (go back twice)0
            if not self.computer.sys_getcwd().parent:
                return Result(success=True, data=self.computer.fs.files)
            else:
                current_dir = self.computer.sys_getcwd().parent
                if current_dir.parent:
                    return Result(success=True, data=current_dir.parent)
                else:
                    return Result(success=True, data=self.computer.fs.files)

        # Regular (non-special cases)
        pathname = pathname.split(&#34;/&#34;)
        # Check if `pathname` is absolute or relative
        # Check if the first arg is empty (because we split by /) which means the first arg is empty if it was a &#34;/&#34;
        if pathname[0] == &#34;&#34;:
            # Absolute (start at root dir)
            current_dir = self.files
        else:
            # Relative (based on current dir)
            current_dir = self.computer.sys_getcwd()

        # Filter out garbage
        while &#34;&#34; in pathname:
            pathname.remove(&#34;&#34;)

        for subdir in pathname:
            # Special case for current directory (.) (ignore it)
            if subdir == &#34;.&#34;:
                continue

            # Special case for (..) (go to parent)
            elif subdir == &#34;..&#34;:
                # Check if we&#39;re at the root
                if not current_dir.parent:
                    current_dir = self.files
                else:
                    current_dir = current_dir.parent

            else:
                if current_dir.is_file():
                    return Result(success=True, data=current_dir)
                current_dir = current_dir.find(subdir)
                if not current_dir:
                    return Result(success=False, message=ResultMessages.NOT_FOUND)

        # This only runs when we successfully found
        return Result(success=True, data=current_dir)

    def generate_manpages(self):
        &#34;&#34;&#34;
        Loop through all available modules and import them. After, use the module.parse_args(doc=True) to generate
        a manpage from the available help information.

        Returns:
            None
        &#34;&#34;&#34;
        find_man_dir = self.find(&#34;/usr/share/man&#34;)

        if not find_man_dir.success:
            return

        man_dir = find_man_dir.data

        find_usr_bin = self.find(&#34;/usr/bin&#34;)

        if not find_usr_bin.success:
            usr_bin = []
        else:
            usr_bin = list(find_usr_bin.data.files.keys())

        # Loop through all the files in /bin and run &#34;parse_args()&#34; with the `doc` set to `True`
        for binary in list(self.files.find(&#34;bin&#34;).files.keys()) + usr_bin:
            # Check if an manpage exist
            if not self.find(f&#34;/usr/share/man/{binary}&#34;).success:
                try:
                    module = importlib.import_module(f&#34;blackhat.bin.{binary}&#34;)
                except ImportError:
                    try:
                        module = importlib.import_module(f&#34;blackhat.bin.installable.{binary}&#34;)
                    except ImportError:
                        continue

                try:
                    manpage = module.parse_args(args=[], doc=True).replace(&#34;**&#34;, Style.BRIGHT).replace(&#34;*/&#34;,
                                                                                                       Style.RESET_ALL)
                    manpage = manpage.removeprefix(&#34;\n&#34;).removesuffix(&#34;\n&#34;)
                    File(binary, manpage, man_dir, 0, 0)
                except AttributeError:
                    continue</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="blackhat.fs.StandardFS.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, pathname: str) ‑> <a title="blackhat.helpers.Result" href="helpers.html#blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Try to find a given file anywhere in the file system based on a given <code>pathname</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pathname</code></strong> :&ensp;<code>str</code></dt>
<dd>The full (absolute or relative) path of the file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> with the <code>success</code> flag set accordingly and the <code>data</code> flag with the found <code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code> or <code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code> if the file was found</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(self, pathname: str) -&gt; Result:
    &#34;&#34;&#34;
    Try to find a given file anywhere in the file system based on a given `pathname`

    Args:
        pathname (str): The full (absolute or relative) path of the file

    Returns:
        Result: A `Result` with the `success` flag set accordingly and the `data` flag with the found `File` or `Directory` if the file was found
    &#34;&#34;&#34;

    # Special cases
    # Replace &#39;~&#39; with $HOME (if exists)
    get_home_env_var = self.computer.get_env(&#34;HOME&#34;)
    if get_home_env_var:
        pathname = pathname.replace(&#34;~&#34;, get_home_env_var)

    # Replace all instances of &#34;\&#34; with &#34;/&#34; (because windows)
    pathname = pathname.replace(&#34;\\&#34;, &#34;/&#34;)

    if pathname == &#34;/&#34;:
        return Result(success=True, data=self.files)

    if pathname == &#34;.&#34;:
        return Result(success=True, data=self.computer.sys_getcwd())

    if pathname == &#34;..&#34;:
        # Check if the directory has a parent
        # If it doesn&#39;t, we can assume that we&#39;re at /
        # In the case of /, just return /
        if not self.computer.sys_getcwd().parent:
            return Result(success=True, data=self.files)
        else:
            return Result(success=True, data=self.computer.sys_getcwd().parent)

    if pathname == &#34;...&#34;:
        # Check if the directory has a parent
        # If it doesn&#39;t, we can assume that we&#39;re at /
        # In the case of /, just return /
        # And then do it again (go back twice)0
        if not self.computer.sys_getcwd().parent:
            return Result(success=True, data=self.computer.fs.files)
        else:
            current_dir = self.computer.sys_getcwd().parent
            if current_dir.parent:
                return Result(success=True, data=current_dir.parent)
            else:
                return Result(success=True, data=self.computer.fs.files)

    # Regular (non-special cases)
    pathname = pathname.split(&#34;/&#34;)
    # Check if `pathname` is absolute or relative
    # Check if the first arg is empty (because we split by /) which means the first arg is empty if it was a &#34;/&#34;
    if pathname[0] == &#34;&#34;:
        # Absolute (start at root dir)
        current_dir = self.files
    else:
        # Relative (based on current dir)
        current_dir = self.computer.sys_getcwd()

    # Filter out garbage
    while &#34;&#34; in pathname:
        pathname.remove(&#34;&#34;)

    for subdir in pathname:
        # Special case for current directory (.) (ignore it)
        if subdir == &#34;.&#34;:
            continue

        # Special case for (..) (go to parent)
        elif subdir == &#34;..&#34;:
            # Check if we&#39;re at the root
            if not current_dir.parent:
                current_dir = self.files
            else:
                current_dir = current_dir.parent

        else:
            if current_dir.is_file():
                return Result(success=True, data=current_dir)
            current_dir = current_dir.find(subdir)
            if not current_dir:
                return Result(success=False, message=ResultMessages.NOT_FOUND)

    # This only runs when we successfully found
    return Result(success=True, data=current_dir)</code></pre>
</details>
</dd>
<dt id="blackhat.fs.StandardFS.generate_manpages"><code class="name flex">
<span>def <span class="ident">generate_manpages</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Loop through all available modules and import them. After, use the module.parse_args(doc=True) to generate
a manpage from the available help information.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_manpages(self):
    &#34;&#34;&#34;
    Loop through all available modules and import them. After, use the module.parse_args(doc=True) to generate
    a manpage from the available help information.

    Returns:
        None
    &#34;&#34;&#34;
    find_man_dir = self.find(&#34;/usr/share/man&#34;)

    if not find_man_dir.success:
        return

    man_dir = find_man_dir.data

    find_usr_bin = self.find(&#34;/usr/bin&#34;)

    if not find_usr_bin.success:
        usr_bin = []
    else:
        usr_bin = list(find_usr_bin.data.files.keys())

    # Loop through all the files in /bin and run &#34;parse_args()&#34; with the `doc` set to `True`
    for binary in list(self.files.find(&#34;bin&#34;).files.keys()) + usr_bin:
        # Check if an manpage exist
        if not self.find(f&#34;/usr/share/man/{binary}&#34;).success:
            try:
                module = importlib.import_module(f&#34;blackhat.bin.{binary}&#34;)
            except ImportError:
                try:
                    module = importlib.import_module(f&#34;blackhat.bin.installable.{binary}&#34;)
                except ImportError:
                    continue

            try:
                manpage = module.parse_args(args=[], doc=True).replace(&#34;**&#34;, Style.BRIGHT).replace(&#34;*/&#34;,
                                                                                                   Style.RESET_ALL)
                manpage = manpage.removeprefix(&#34;\n&#34;).removesuffix(&#34;\n&#34;)
                File(binary, manpage, man_dir, 0, 0)
            except AttributeError:
                continue</code></pre>
</details>
</dd>
<dt id="blackhat.fs.StandardFS.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>All the functions required to setup a new filesystem</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init(self) -&gt; None:
    &#34;&#34;&#34;
    All the functions required to setup a new filesystem

    Returns:
        None
    &#34;&#34;&#34;
    # Setup the directory structure in the file system (Unix FHS)
    for dir in [&#34;bin&#34;, &#34;etc&#34;, &#34;home&#34;, &#34;lib&#34;, &#34;root&#34;, &#34;run&#34;, &#34;proc&#34;, &#34;tmp&#34;, &#34;usr&#34;, &#34;var&#34;]:
        directory = Directory(dir, self.files, 0, 0)
        # Special case for /tmp (read and write by everyone)
        if dir == &#34;tmp&#34;:
            directory.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;],
                                     &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}
        elif dir == &#34;proc&#34;:
            directory.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [],
                                     &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}
        else:
            # TODO: Change this to be more accurate
            # (rwx rw- r--)
            directory.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;, &#34;group&#34;],
                                     &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}

    # TODO: Replace all these with `mkdir -p` commands
    # NOTE: FS doesn&#39;t exist at this point so running commands might not be possible (since some commands need fs)
    # Individually setup each directory in the root
    self.setup_bin()
    self.setup_etc()
    # self.setup_home()
    # self.setup_lib()
    self.setup_proc()
    self.setup_root()
    self.setup_run()
    # self.setup_tmp()
    self.setup_usr()
    self.setup_var()</code></pre>
</details>
</dd>
<dt id="blackhat.fs.StandardFS.setup_bin"><code class="name flex">
<span>def <span class="ident">setup_bin</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Read all the files in the <code>client.blackhat.bin</code> directory and create a virtual file in the fs.
All these files represent binaries in the system</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_bin(self) -&gt; None:
    &#34;&#34;&#34;
    Read all the files in the `client.blackhat.bin` directory and create a virtual file in the fs.
    All these files represent binaries in the system

    Returns:
        None
    &#34;&#34;&#34;
    bin_dir: Directory = self.files.find(&#34;bin&#34;)

    for file in os.listdir(&#34;./blackhat/bin&#34;):
        # Ignore the __init__.py and __pycache__ because those aren&#39;t bins (auto generated)
        if file not in [&#34;__init__.py&#34;, &#34;__pycache__&#34;, &#34;installable&#34;]:
            with open(os.path.join(&#34;./blackhat/bin&#34;, file), &#34;r&#34;) as f:
                source_code = f.read()
            current_file = File(file.replace(&#34;.py&#34;, &#34;&#34;), source_code, bin_dir, 0, 0)
            current_file.size = os.path.getsize(os.path.join(&#34;./blackhat/bin&#34;, file))

            current_file.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;],
                                        &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}
            # Add setuid bit to specific binaries
            if file.replace(&#34;.py&#34;, &#34;&#34;) in [&#34;sudo&#34;, &#34;su&#34;, &#34;passwd&#34;]:
                current_file.setuid = True</code></pre>
</details>
</dd>
<dt id="blackhat.fs.StandardFS.setup_etc"><code class="name flex">
<span>def <span class="ident">setup_etc</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Sets up:</p>
<ul>
<li>/etc/passwd - Contains the username, hashed password, and UID of all the users in the system</li>
<li>/etc/shadow - Contains the username, and hashed password of all users in the system</li>
<li>/etc/groups - Contains the list of groups in the systems (name, GID)</li>
<li>/etc/hostname - The hostname of the given <code>Computer</code></li>
<li>/etc/skel -
A "skeleton" needed to create a users home folder (located in /home/<USERNAME>)</li>
<li>/etc/sudoers - The file that contains all of the sudo permissions</li>
<li>/etc/apt/sources.list - Contains urls of apt repo servers</li>
<li>/etc/resolv.conf - Contains the list of dns servers</li>
</ul>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_etc(self) -&gt; None:
    &#34;&#34;&#34;
    Sets up:
    &lt;ul&gt;
        &lt;li&gt;/etc/passwd - Contains the username, hashed password, and UID of all the users in the system&lt;/li&gt;
        &lt;li&gt;/etc/shadow - Contains the username, and hashed password of all users in the system&lt;/li&gt;
        &lt;li&gt;/etc/groups - Contains the list of groups in the systems (name, GID)&lt;/li&gt;
        &lt;li&gt;/etc/hostname - The hostname of the given `Computer`&lt;/li&gt;
        &lt;li&gt;/etc/skel -  A &#34;skeleton&#34; needed to create a users home folder (located in /home/&lt;USERNAME&gt;)&lt;/li&gt;
        &lt;li&gt;/etc/sudoers - The file that contains all of the sudo permissions&lt;/li&gt;
        &lt;li&gt;/etc/apt/sources.list - Contains urls of apt repo servers&lt;/li&gt;
        &lt;li&gt;/etc/resolv.conf - Contains the list of dns servers&lt;/li&gt;
    &lt;/ul&gt;

    Returns:
        None
    &#34;&#34;&#34;

    # EventHandler functions for /etc/passwd, /etc/shadow, and /etc/group
    def update_passwd(file):
        content = file.content.split(&#34;\n&#34;)

        for item in content:
            subitems = item.split(&#34;:&#34;)
            # An item in the list with a length of 1 or less are usually blank lines
            if len(subitems) &gt; 1:
                username, password, uid, primary_gid = subitems

                try:
                    uid = int(uid)
                    primary_gid = int(primary_gid)
                except Exception:
                    return

                # Now we want to get the user by username
                user_lookup = self.computer.get_user(username=username)

                # If we don&#39;t find the user, that means we added a new user
                if not user_lookup.success:
                    # Make sure no user has the uid
                    if not self.computer.get_user(uid=uid).success:
                        # Add the user
                        self.computer.add_user(username, password, uid, plaintext=False)
                        self.computer.add_group(name=username, gid=primary_gid)
                        self.computer.add_user_to_group(uid, primary_gid, &#34;primary&#34;)
                else:
                    # We have a user, now lets check if any of the data has changed
                    user = user_lookup.data

                    # If the password is &#39;x&#39;, that password is in the /etc/shadow file and should be ignored here
                    if user.password != password and password != &#34;x&#34;:
                        result = self.computer.change_user_password(user.uid, password, plaintext=False)
                        if result.success:
                            user.password = password

                    if user.uid != uid:
                        result = self.computer.change_user_uid(user.uid, uid)
                        if result.success:
                            user.uid = uid

                    # If the GID changed, we want to:
                    # 1. Make sure the new GID exists
                    # 2. Remove the user&#39;s old primary gid membership
                    # 3. Add a the user to the new gid as primary
                    user_primary_gid = self.computer.get_user_primary_group(user.uid).data[0]

                    if user_primary_gid != primary_gid:
                        if self.computer.get_group(gid=primary_gid).success:
                            self.computer.remove_user_from_group(uid=user.uid, gid=user_primary_gid)
                            self.computer.add_user_to_group(user.uid, primary_gid, &#34;primary&#34;)

                # Will automatically remove incorrect changes
                self.computer.sync_user_and_group_files()

    def update_shadow(file):
        content = file.content.split(&#34;\n&#34;)

        for item in content:
            subitems = item.split(&#34;:&#34;)
            # An item in the list with a length of 1 or less are usually blank lines
            if len(subitems) &gt; 1:
                username, password = subitems

                # Now we want to get the user by username
                user_lookup = self.computer.get_user(username=username)

                # We have a user, now lets check if any of the data has changed
                user = user_lookup.data

                # If the password is &#39;x&#39;, that password is in the /etc/shadow file and should be ignored here
                if user.password != password and password != &#34;x&#34;:
                    result = self.computer.change_user_password(user.uid, password, plaintext=False)
                    if result.success:
                        user.password = password

            # Will automatically remove incorrect changes
            self.computer.sync_user_and_group_files()

    def update_group(file):
        content = file.content.split(&#34;\n&#34;)

        for item in content:
            subitems = item.split(&#34;:&#34;)
            # An item in the list with a length of 1 or less are usually blank lines
            if len(subitems) &gt; 1:
                group_name, password, gid, group_users = subitems

                try:
                    uid = int(gid)
                except Exception:
                    return

                # Now we want to get the group by group name
                group_lookup = self.computer.get_group(name=group_name)

                # If we don&#39;t find the user, that means we added a new user
                if not group_lookup.success:
                    # Make sure no group has the gid
                    if not self.computer.get_group(gid=gid).success:
                        # Add the group
                        self.computer.add_group(group_name, gid)
                        # TODO: Add users to the group by last param
                else:
                    # We have a group, now lets check if any of the data has changed
                    group = group_lookup.data
                    # TODO: Add changes here

                # Will automatically remove incorrect changes
                self.computer.sync_user_and_group_files()

    etc_dir: Directory = self.files.find(&#34;etc&#34;)
    # Create the /etc/passwd file
    passwd_file: File = File(&#34;passwd&#34;, f&#34;&#34;, etc_dir, 0, 0)

    passwd_file.add_event_listener(&#34;write&#34;, update_passwd)

    # Create the /etc/shadow file and change its perms (rw-------)
    shadow_file: File = File(&#34;shadow&#34;, f&#34;&#34;, etc_dir, 0, 0)
    shadow_file.permissions = {&#34;read&#34;: [&#34;owner&#34;], &#34;write&#34;: [&#34;owner&#34;], &#34;execute&#34;: []}
    shadow_file.add_event_listener(&#34;write&#34;, update_shadow)

    # Create the /etc/groups file
    group_file: File = File(&#34;group&#34;, f&#34;root:x:0&#34;, etc_dir, 0, 0)
    group_file.add_event_listener(&#34;write&#34;, update_group)

    # /etc/skel (home dir template)
    skel_dir: Directory = Directory(&#34;skel&#34;, etc_dir, 0, 0)

    for dir in [&#34;Desktop&#34;, &#34;Documents&#34;, &#34;Downloads&#34;, &#34;Music&#34;, &#34;Pictures&#34;, &#34;Public&#34;, &#34;Templates&#34;, &#34;Videos&#34;]:
        current_dir = Directory(dir, skel_dir, 0, 0)
        current_dir.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;],
                                   &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}

    # /etc/skel/.shellrc (.bashrc/.zshrc equivalent)
    DEFAULT_SHELLRC_CONTENT = &#34;alias lsa=ls -l -a\n&#34; \
                              &#34;alias la=ls -a\n&#34; \
                              &#34;alias ll=ls -l\n&#34;

    File(&#34;.shellrc&#34;, DEFAULT_SHELLRC_CONTENT, skel_dir, 0, 0)

    # /etc/hostname (holds system hostname)
    # Stupid windows style default hostnames (for fun, might change later)
    new_hostname = f&#34;DESKTOP-{&#39;&#39;.join([choice(ascii_uppercase + digits) for _ in range(7)])}&#34;
    File(&#34;hostname&#34;, new_hostname, etc_dir, 0, 0)

    # /etc/sudoers (holds sudo permissions)
    # Sudoers has permissions r--r-----
    sudoers_file: File = File(&#34;sudoers&#34;, &#34;root ALL=(ALL) ALL\n&#34;, etc_dir, 0, 0)
    sudoers_file.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;], &#34;write&#34;: [], &#34;execute&#34;: []}

    # /etc/apt/sources.list
    apt_dir: Directory = Directory(&#34;apt&#34;, etc_dir, 0, 0)

    File(&#34;sources.list&#34;, &#34;&#34;, apt_dir, 0, 0)

    # /etc/resolv.conf
    File(&#34;resolv.conf&#34;, &#34;nameserver 1.1.1.1&#34;, etc_dir, 0, 0)</code></pre>
</details>
</dd>
<dt id="blackhat.fs.StandardFS.setup_proc"><code class="name flex">
<span>def <span class="ident">setup_proc</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Sets up:</p>
<ul>
<li>/proc/uptime - Contains the amount of seconds since the system was booted</li>
</ul>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_proc(self) -&gt; None:
    &#34;&#34;&#34;
    Sets up:
    &lt;ul&gt;
        &lt;li&gt;/proc/uptime - Contains the amount of seconds since the system was booted&lt;/li&gt;
    &lt;/ul&gt;

    Returns:
        None
    &#34;&#34;&#34;

    # EventHandler functions for /proc/uptime
    def update_uptime(file):
        file.content = str((datetime.datetime.now() - self.computer.boot_time).total_seconds())

    proc_dir: Directory = self.files.find(&#34;proc&#34;)
    # Create the /proc/uptime file
    uptime_file: File = File(&#34;uptime&#34;, f&#34;&#34;, proc_dir, 0, 0)
    uptime_file.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [], &#34;execute&#34;: []}

    uptime_file.add_event_listener(&#34;read&#34;, update_uptime, when=&#34;before&#34;)</code></pre>
</details>
</dd>
<dt id="blackhat.fs.StandardFS.setup_root"><code class="name flex">
<span>def <span class="ident">setup_root</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Since the root user is different from a "standard" user, root's home folder needs to be setup separately.
Otherwise, the format of root's home folder is the same as any other user</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_root(self) -&gt; None:
    &#34;&#34;&#34;
    Since the root user is different from a &#34;standard&#34; user, root&#39;s home folder needs to be setup separately.
    Otherwise, the format of root&#39;s home folder is the same as any other user

    Returns:
        None
    &#34;&#34;&#34;
    # Create /root/.shellrc
    root_dir: Directory = self.files.find(&#34;root&#34;)

    File(&#34;.shellrc&#34;, &#34;export HOME=/root\nexport USER=root&#34;, root_dir, 0, 0)</code></pre>
</details>
</dd>
<dt id="blackhat.fs.StandardFS.setup_run"><code class="name flex">
<span>def <span class="ident">setup_run</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Sets up:</p>
<ul>
<li>/run/sudo/ts/ - Contains auth timeout timestamps for <code>sudo</code></li>
</ul>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_run(self) -&gt; None:
    &#34;&#34;&#34;
    Sets up:
    &lt;ul&gt;
        &lt;li&gt;/run/sudo/ts/ - Contains auth timeout timestamps for &lt;code&gt;sudo&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;

    Returns:
        None
    &#34;&#34;&#34;
    run_dir: Directory = self.files.find(&#34;run&#34;)

    # Create /run/sudo and /run/sudo/ts
    run_sudo: Directory = Directory(&#34;sudo&#34;, run_dir, 0, 0)
    run_sudo.permissions = {&#34;read&#34;: [&#34;owner&#34;], &#34;write&#34;: [&#34;owner&#34;], &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}

    run_sudo_ts: Directory = Directory(&#34;ts&#34;, run_sudo, 0, 0)
    run_sudo_ts.permissions = {&#34;read&#34;: [&#34;owner&#34;], &#34;write&#34;: [&#34;owner&#34;], &#34;execute&#34;: [&#34;owner&#34;]}</code></pre>
</details>
</dd>
<dt id="blackhat.fs.StandardFS.setup_usr"><code class="name flex">
<span>def <span class="ident">setup_usr</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Sets up:</p>
<ul>
<li>/usr/share/man - Contains all the "man pages", or instruction manuals, for all the system binaries</li>
<li>/usr/bin - "Aftermarket" installed packages (apt) </li>
</ul>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_usr(self) -&gt; None:
    &#34;&#34;&#34;
    Sets up:
    &lt;ul&gt;
        &lt;li&gt;/usr/share/man - Contains all the &#34;man pages&#34;, or instruction manuals, for all the system binaries&lt;/li&gt;
        &lt;li&gt;/usr/bin - &#34;Aftermarket&#34; installed packages (apt) &lt;/li&gt;
    &lt;/ul&gt;

    Returns:
        None
    &#34;&#34;&#34;
    # Setup /usr/share
    usr_dir: Directory = self.files.find(&#34;usr&#34;)

    share_dir: Directory = Directory(&#34;share&#34;, usr_dir, 0, 0)

    # /usr/share/man
    Directory(&#34;man&#34;, share_dir, 0, 0)

    self.generate_manpages()

    def generate_manpages(file):
        self.generate_manpages()

    bin_dir: Directory = Directory(&#34;bin&#34;, usr_dir, 0, 0)
    bin_dir.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;],
                           &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}
    bin_dir.add_event_listener(&#34;write&#34;, generate_manpages)</code></pre>
</details>
</dd>
<dt id="blackhat.fs.StandardFS.setup_var"><code class="name flex">
<span>def <span class="ident">setup_var</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Sets up:</p>
<ul>
<li>/var/log - Contains various log files</li>
<li>/var/log/syslog - Logs various information about the given <code>Computer</code></li>
<li>/var/log/auth.log - Logs information about authentication attempts</li>
<li>/var/lib/dpkg/status - The list of installed packages by apt</li>
<li>/var/www/html - Default location for web content served by web servers</li>
</ul>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_var(self) -&gt; None:
    &#34;&#34;&#34;
    Sets up:
    &lt;ul&gt;
        &lt;li&gt;/var/log - Contains various log files&lt;/li&gt;
        &lt;li&gt;/var/log/syslog - Logs various information about the given `Computer`&lt;/li&gt;
        &lt;li&gt;/var/log/auth.log - Logs information about authentication attempts&lt;/li&gt;
        &lt;li&gt;/var/lib/dpkg/status - The list of installed packages by apt&lt;/li&gt;
        &lt;li&gt;/var/www/html - Default location for web content served by web servers&lt;/li&gt;
    &lt;/ul&gt;

    Returns:
        None
    &#34;&#34;&#34;
    # This should exist at runtime
    var_dir: Directory = self.files.find(&#34;var&#34;)

    # Create /var/log
    log_dir: Directory = Directory(&#34;log&#34;, var_dir, 0, 0)

    # Create the `syslog` in /var/log
    File(&#34;syslog&#34;, &#34;&#34;, log_dir, 0, 0)

    # Create /var/lib/dpkg/status
    lib_dir: Directory = Directory(&#34;lib&#34;, var_dir, 0, 0)

    dpkg_dir: Directory = Directory(&#34;dpkg&#34;, lib_dir, 0, 0)

    File(&#34;status&#34;, &#34;&#34;, dpkg_dir, 0, 0)

    # Create /var/www/html
    www_dir: Directory = Directory(&#34;www&#34;, var_dir, 0, 0)

    Directory(&#34;html&#34;, www_dir, 0, 0)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="blackhat" href="index.html">blackhat</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="blackhat.fs.copy" href="#blackhat.fs.copy">copy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="blackhat.fs.Directory" href="#blackhat.fs.Directory">Directory</a></code></h4>
<ul class="">
<li><code><a title="blackhat.fs.Directory.add_file" href="#blackhat.fs.Directory.add_file">add_file</a></code></li>
<li><code><a title="blackhat.fs.Directory.calculate_size" href="#blackhat.fs.Directory.calculate_size">calculate_size</a></code></li>
<li><code><a title="blackhat.fs.Directory.find" href="#blackhat.fs.Directory.find">find</a></code></li>
<li><code><a title="blackhat.fs.Directory.update_size" href="#blackhat.fs.Directory.update_size">update_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="blackhat.fs.FSBaseObject" href="#blackhat.fs.FSBaseObject">FSBaseObject</a></code></h4>
<ul class="">
<li><code><a title="blackhat.fs.FSBaseObject.add_event_listener" href="#blackhat.fs.FSBaseObject.add_event_listener">add_event_listener</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.atime" href="#blackhat.fs.FSBaseObject.atime">atime</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.change_owner" href="#blackhat.fs.FSBaseObject.change_owner">change_owner</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.check_owner" href="#blackhat.fs.FSBaseObject.check_owner">check_owner</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.check_perm" href="#blackhat.fs.FSBaseObject.check_perm">check_perm</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.ctime" href="#blackhat.fs.FSBaseObject.ctime">ctime</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.delete" href="#blackhat.fs.FSBaseObject.delete">delete</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.handle_event" href="#blackhat.fs.FSBaseObject.handle_event">handle_event</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.is_directory" href="#blackhat.fs.FSBaseObject.is_directory">is_directory</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.is_file" href="#blackhat.fs.FSBaseObject.is_file">is_file</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.mtime" href="#blackhat.fs.FSBaseObject.mtime">mtime</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.permissions" href="#blackhat.fs.FSBaseObject.permissions">permissions</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.pwd" href="#blackhat.fs.FSBaseObject.pwd">pwd</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.remove_event_listener" href="#blackhat.fs.FSBaseObject.remove_event_listener">remove_event_listener</a></code></li>
<li><code><a title="blackhat.fs.FSBaseObject.setuid" href="#blackhat.fs.FSBaseObject.setuid">setuid</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="blackhat.fs.File" href="#blackhat.fs.File">File</a></code></h4>
<ul class="">
<li><code><a title="blackhat.fs.File.append" href="#blackhat.fs.File.append">append</a></code></li>
<li><code><a title="blackhat.fs.File.get_perm_octal" href="#blackhat.fs.File.get_perm_octal">get_perm_octal</a></code></li>
<li><code><a title="blackhat.fs.File.read" href="#blackhat.fs.File.read">read</a></code></li>
<li><code><a title="blackhat.fs.File.update_size" href="#blackhat.fs.File.update_size">update_size</a></code></li>
<li><code><a title="blackhat.fs.File.write" href="#blackhat.fs.File.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="blackhat.fs.StandardFS" href="#blackhat.fs.StandardFS">StandardFS</a></code></h4>
<ul class="two-column">
<li><code><a title="blackhat.fs.StandardFS.find" href="#blackhat.fs.StandardFS.find">find</a></code></li>
<li><code><a title="blackhat.fs.StandardFS.generate_manpages" href="#blackhat.fs.StandardFS.generate_manpages">generate_manpages</a></code></li>
<li><code><a title="blackhat.fs.StandardFS.init" href="#blackhat.fs.StandardFS.init">init</a></code></li>
<li><code><a title="blackhat.fs.StandardFS.setup_bin" href="#blackhat.fs.StandardFS.setup_bin">setup_bin</a></code></li>
<li><code><a title="blackhat.fs.StandardFS.setup_etc" href="#blackhat.fs.StandardFS.setup_etc">setup_etc</a></code></li>
<li><code><a title="blackhat.fs.StandardFS.setup_proc" href="#blackhat.fs.StandardFS.setup_proc">setup_proc</a></code></li>
<li><code><a title="blackhat.fs.StandardFS.setup_root" href="#blackhat.fs.StandardFS.setup_root">setup_root</a></code></li>
<li><code><a title="blackhat.fs.StandardFS.setup_run" href="#blackhat.fs.StandardFS.setup_run">setup_run</a></code></li>
<li><code><a title="blackhat.fs.StandardFS.setup_usr" href="#blackhat.fs.StandardFS.setup_usr">setup_usr</a></code></li>
<li><code><a title="blackhat.fs.StandardFS.setup_var" href="#blackhat.fs.StandardFS.setup_var">setup_var</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html><style>body {
    background-color: #121212;
    color: white;
}

#sidebar {
    background-color: #242424;
}

#sidebar code {
    background-color: #282828 !important;
}


a {
    color: #8c00f7 !important;
}

.name {
    background-color: #1a1a1a !important;
}

code {
    background-color: #1a1a1a !important;
}

pre {
    background-color: #242424 !important;
    border-top: #242424 !important;
    border-bottom: #242424 !important;
    overflow-x: hidden !important;
}


h1:target, h2:target, h3:target, h4:target, h5:target, h6:target{
    background: #8c00f7
}

/* Modify color syntax highlighting */
.hljs {
    display: block;
    overflow-x: auto;
    padding: .5em;
    color: white !important;
    background: #f8f8f8
}

.hljs-comment,
.hljs-quote {
    color: #998;
    font-style: italic
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-subst {
    color: dodgerblue !important;
    font-weight: 700
}

.hljs-literal,
.hljs-number,
.hljs-tag .hljs-attr,
.hljs-template-variable,
.hljs-variable {
    color: teal
}

.hljs-doctag,
.hljs-string {
    color: #d14
}

.hljs-section,
.hljs-selector-id,
.hljs-title {
    color: #900;
    font-weight: 700
}

.hljs-subst {
    font-weight: 400
}

.hljs-class .hljs-title,
.hljs-type {
    color: #458;
    font-weight: 700
}

.hljs-attribute,
.hljs-name,
.hljs-tag {
    color: navy;
    font-weight: 400
}

.hljs-link,
.hljs-regexp {
    color: #009926
}

.hljs-bullet,
.hljs-symbol {
    color: #990073
}

.hljs-built_in,
.hljs-builtin-name {
    color: #0086b3
}

.hljs-meta {
    color: #999;
    font-weight: 700
}

.hljs-deletion {
    background: #fdd
}

.hljs-addition {
    background: #dfd
}

.hljs-emphasis {
    font-style: italic
}

.hljs-strong {
    font-weight: 700
}

/* Custom scrollbar */
/* width */
::-webkit-scrollbar {
    width: 10px;
}

/* Track */
::-webkit-scrollbar-track {
    box-shadow: inset 0 0 2.5px grey;
    border-radius: 5px;
}

/* Handle */
::-webkit-scrollbar-thumb {
    background: gray;
    border-radius: 5px;
}

/* Handle on hover */
::-webkit-scrollbar-thumb:hover {
    background: #6b6b6b;
}

@media only screen and (max-width: 600px) {
    pre {
        overflow: scroll !important;
    }

    pre::-webkit-scrollbar {
        display: none !important;
    }
}</style>
