<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>client.blackhat.fs API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>client.blackhat.fs</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import importlib
import os
import sys
from random import choice
from string import ascii_uppercase, digits
from typing import Optional, Dict, List, Literal, Union

from .helpers import SysCallStatus, SysCallMessages


class FSBaseObject:
    def __init__(self, name: str, parent: Optional[&#34;Directory&#34;], owner: int, group_owner: int) -&gt; None:
        &#34;&#34;&#34;
        The base object that contains info shared between `Directories` and `Files`

        Args:
            name (str): The name of the `File`/`Directory`
            parent (Directory): The `Directory` one level up the tree
            owner (int): The UID of the owner of the `File`/`Directory`
            group_owner (int): The GID of the owner of the `File`/`Directory`
        &#34;&#34;&#34;
        self.name: str = name
        self.permissions: Dict[str, List[Literal[&#34;read&#34;, &#34;write&#34;, &#34;execute&#34;]]] = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;],
                                                                                  &#34;write&#34;: [&#34;owner&#34;],
                                                                                  &#34;execute&#34;: []}
        &#34;&#34;&#34;Permissions for accessing the file. Default permissions; rw-r--r-- (644)&#34;&#34;&#34;
        self.parent: Optional[&#34;Directory&#34;] = parent
        self.owner: int = owner
        self.group_owner: int = group_owner
        self.link_count: int
        self.size: int
        self.atime: int  # Last access time (unix time stamp)
        &#34;&#34;&#34;int: Access time; when file was last read from/accessed&#34;&#34;&#34;
        self.mtime: int  # Last modified time (unix time stamp)
        &#34;&#34;&#34;int: Modified time; when the file&#34;s content was last modified&#34;&#34;&#34;
        self.ctime: int  # Last file status change (unix time stamp)
        &#34;&#34;&#34;imt: Changed time; when the file&#34;s metadata was last changed (ex. perms)&#34;&#34;&#34;

    def is_directory(self) -&gt; bool:
        &#34;&#34;&#34;
        Determines if a given item is a `Directory`

        Returns:
            bool: `True` if the given item is a `Directory` otherwise `False`
        &#34;&#34;&#34;
        return type(self) == Directory

    def is_file(self) -&gt; bool:
        &#34;&#34;&#34;
        Determines if a given item is a `File`

        Returns:
            bool: `True` if the given item is a `File` otherwise `False`
        &#34;&#34;&#34;
        return type(self) == File

    def check_perm(self, perm: Literal[&#34;read&#34;, &#34;write&#34;, &#34;execute&#34;], computer) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Checks if the current user has the given `perm`

        Args:
            perm (str): The permission to check (&#34;read&#34;, &#34;write&#34;, &#34;execute&#34;)
            computer: The current `Computer` instance

        Returns:
            SysCallStatus: A `SysCallStatus` object with the `success` flag set accordingly
        &#34;&#34;&#34;
        # If we&#34;re root (UID 0), return True because root has all permissions
        if computer.get_uid() == 0:
            return SysCallStatus(success=True)
        # If &#34;public&#34;, don&#34;t bother checking anything else
        if &#34;public&#34; in self.permissions[perm]:
            return SysCallStatus(success=True)

        if &#34;group&#34; in self.permissions[perm]:
            if self.group_owner in computer.find_user_groups(computer.get_uid()).data:
                return SysCallStatus(success=True)

        if &#34;owner&#34; in self.permissions[perm]:
            if self.owner == computer.get_uid():
                return SysCallStatus(success=True)

        # No permission
        return SysCallStatus(success=False, message=SysCallMessages.NOT_ALLOWED)

    def check_owner(self, computer) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Checks if the given UID or GID is one of the owners (for chmod/chgrp/etc)

        Args:
            computer: The current `Computer` instance

        Returns:
            SysCallStatus: A `SysCallStatus` object with the `success` flag set accordingly
        &#34;&#34;&#34;
        # Get the list of user&#39;s groups
        groups = computer.find_user_groups(computer.get_uid()).data

        if self.owner == computer.get_uid() or self.group_owner in groups:
            return SysCallStatus(success=True)
        else:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_ALLOWED)

    def change_owner(self, computer, new_user_owner: Optional[int] = None,
                     new_group_owner: Optional[int] = None) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Change the owner (user and/or group) of a given `File`/`Directory`, but check if the given UID should be allowed to first

        Args:
            computer: The current `Computer` instance
            new_user_owner (int): The UID of the new owner (user) of the `File`/`Directory`
            new_group_owner (int): The GID of the new owner (group) of the `File`/`Directory`

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set accordingly
        &#34;&#34;&#34;
        caller_groups = computer.find_user_groups(computer.get_uid()).data
        # Check if the owner or group owner is correct or if we&#39;re root
        if computer.get_uid() == self.owner or self.group_owner in caller_groups or computer.get_uid() == 0:
            # We need at least one of the two params (uid/gid)
            # Using `if not new_user_owner/not new_group_owner` won&#39;t work because `not 0` (root group) == True (???)
            if new_user_owner is None and new_group_owner is None:
                return SysCallStatus(success=False, message=SysCallMessages.MISSING_ARGUMENT)
            else:
                # Same thing with uid 0
                if new_user_owner is not None:
                    # Confirm that the user exists
                    if computer.find_user(uid=new_user_owner).success:
                        self.owner = new_user_owner
                    else:
                        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

                # Confirm that the new group exists
                # Same thing with gid 0
                if new_group_owner is not None:
                    # Confirm that the user exists
                    if computer.find_group(gid=new_group_owner).success:
                        self.group_owner = new_group_owner
                    else:
                        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

                return SysCallStatus(success=True)
        else:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_ALLOWED)

    def pwd(self) -&gt; str:
        &#34;&#34;&#34;
        Get the full path of the `File` in the file system

        Returns:
            str: A complete file path starting at / (root)
        &#34;&#34;&#34;
        current_dir = self
        working_dir = []

        while True:
            # Check if we&#39;re at /
            working_dir.append(current_dir.name)
            if not current_dir.parent:
                break
            current_dir = current_dir.parent

        working_dir.reverse()
        working_dir = &#34;/&#34;.join(working_dir)
        # Try to remove double slash
        if working_dir.startswith(&#34;//&#34;):
            working_dir = working_dir[1:]

        return working_dir

    def delete(self, computer) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Check if the `caller` has the proper permissions to delete a given file, then remove it

        Args:
            computer: The current computer object

        Returns:
            SysCallStatus: A `SysCallStatus` object with the `success` flag set accordingly
        &#34;&#34;&#34;
        if self.parent:
            # In unix, we need read+write permissions to delete
            if self.check_perm(&#34;read&#34;, computer).success and self.check_perm(&#34;write&#34;, computer).success:
                del self.parent.files[self.name]
                return SysCallStatus(success=True)
            else:
                return SysCallStatus(success=False, message=SysCallMessages.NOT_ALLOWED)


class File(FSBaseObject):
    def __init__(self, name: str, content: str, parent: &#34;Directory&#34;, owner: int, group_owner: int) -&gt; None:
        &#34;&#34;&#34;
        The class object representing a file in the file system

        Args:
            name (str): The name of the given `File`
            content (str): The content within the given file. May be blank (empty string)
            parent (Directory): The `Directory` one level up the tree
            owner (int): The UID of the owner of the `File`/`Directory`
            group_owner (int): The GID of the owner of the `File`/`Directory
        &#34;&#34;&#34;
        super().__init__(name, parent, owner, group_owner)
        self.content = content
        self.size = sys.getsizeof(self.name + self.content)

    def read(self, computer) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Check if the current UID has permission to read the content of the file. Afterwards, return the content if allowed

        Args:
            computer: The current `Computer` instance

        Returns:
            SysCallStatus: A `SysCallStatus` object with the `success` flag set and the `data` flag set with the file&#39;s content if permitted
        &#34;&#34;&#34;
        if self.check_perm(&#34;read&#34;, computer).success:
            return SysCallStatus(success=True, data=self.content)
        else:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_ALLOWED)

    def write(self, data: str, computer) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Check if the current UID has permission to write to the file. Update the file&#39;s contents if allowed

        Args:
            data (str): The new content to write to the `File`
            computer: The current `Computer` instance

        Returns:
            SysCallStatus: A `SysCallStatus` object with the `success` flag accordingly
        &#34;&#34;&#34;
        if self.check_perm(&#34;write&#34;, computer).success:
            self.content = data
            self.update_size()
            return SysCallStatus(success=True)
        else:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_ALLOWED)

    def append(self, data: str, computer) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Check if the current UID has permission to write to the file. Append to the file&#39;s contents if allowed

        Args:
            data (str): The content to append to the `File`s current content
            computer: The current `Computer` instance

        Returns:
            SysCallStatus: A `SysCallStatus` object with the `success` flag accordingly
        &#34;&#34;&#34;
        # NOTE: This may be unnecessary, we&#34;ll find out later
        if self.check_perm(&#34;write&#34;, computer).success:
            self.content += data
            self.update_size()
            return SysCallStatus(success=True)
        else:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_ALLOWED)

    def update_size(self) -&gt; None:
        &#34;&#34;&#34;
        Calculates the size of the `File` and set in the object.
        Also, recursively tells it&#39;s parent to update its size.

        Returns:
            None
        &#34;&#34;&#34;
        self.size = sys.getsizeof(self.name + self.content)

        # First, update our own size
        self.size = sys.getsizeof(self.content + self.name)
        # Now, recursively update our parent&#34;s size
        if self.parent:
            self.parent.update_size()


class Directory(FSBaseObject):
    def __init__(self, name: str, parent: Optional[&#34;Directory&#34;], owner: int, group_owner: int):
        &#34;&#34;&#34;
        The class object representing a directory within the file system

        Args:
            name (str): The name of the `File`/`Directory`
            parent (Directory): The `Directory` one level up the tree
            owner (int): The UID of the owner of the `File`/`Directory`
            group_owner (int): The GID of the owner of the `File`/`Directory`
        &#34;&#34;&#34;
        super().__init__(name, parent, owner, group_owner)
        self.files = {}
        self.size = None

        self.update_size()

    def add_file(self, file: Union[File, &#34;Directory&#34;]) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Add a new `File` or `Directory` to self&#39;s internal file map
        Also updates its size and triggers its parent to update their size

        Args:
            file (File/Directory): The `File`/`Directory` to add to self

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set accordingly
        &#34;&#34;&#34;
        if file.name in self.files.keys():
            return SysCallStatus(success=False, message=SysCallMessages.ALREADY_EXISTS)

        self.files[file.name] = file
        self.update_size()
        return SysCallStatus(success=True)

    def calculate_size(self) -&gt; int:
        &#34;&#34;&#34;
        Calculate a total size for the given directory and (recursively) all its children (`File`(s)/`Directory`(ies))

        Returns:
            int: The total size (in bytes) of the given directory
        &#34;&#34;&#34;
        total = 0

        for file in self.files.values():
            if file.is_directory():
                # Recursive
                total += file.calculate_size()
            else:
                if file.size:
                    total += file.size

        return total

    def find(self, filename: str) -&gt; Optional[Union[File, &#34;Directory&#34;]]:
        &#34;&#34;&#34;
        Find a `File` or `Directory` in self&#39;s internal file map

        Args:
            filename (str): The name of the `File`/`Directory` to find

        Returns:
            File or Directory or None: The `File` or `Directory` object if found, otherwise, None
        &#34;&#34;&#34;
        return self.files.get(filename, None)

    def update_size(self) -&gt; None:
        &#34;&#34;&#34;
        Update self&#39;s size using `calculate_size()` then, triggers self&#39;s parent to update their size

        Returns:
            None
        &#34;&#34;&#34;
        self.size = self.calculate_size()

        # This does the same as the file update size. Updates its own size
        # Then the parent updates its size, taking into account self&#39;s new size
        # Like a chain until all parent folders have been updated

        if self.parent:
            self.parent.update_size()


class StandardFS:
    def __init__(self, computer) -&gt; None:
        &#34;&#34;&#34;
        The class object representing a file system that belongs to a `Computer`

        Args:
            computer (Computer): The `Computer` that the given file system belongs to
        &#34;&#34;&#34;
        self.computer = computer

        # The filesystem root (/) (owned by root)
        self.files = Directory(&#34;/&#34;, None, 0, 0)

        self.init()

    def init(self) -&gt; None:
        &#34;&#34;&#34;
        All the functions required to setup a new filesystem

        Returns:
            None
        &#34;&#34;&#34;
        # Setup the directory structure in the file system (Unix FHS)
        for dir in [&#34;bin&#34;, &#34;etc&#34;, &#34;home&#34;, &#34;lib&#34;, &#34;root&#34;, &#34;tmp&#34;, &#34;usr&#34;, &#34;var&#34;]:
            directory = Directory(dir, self.files, 0, 0)
            # Special case for /tmp (read and write by everyone)
            if dir == &#34;tmp&#34;:
                directory.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;],
                                         &#34;execute&#34;: []}
            else:
                # TODO: Change this to be more accurate
                # (rwx rw- r--)
                directory.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;, &#34;group&#34;],
                                         &#34;execute&#34;: [&#34;owner&#34;]}

            self.files.add_file(directory)

        # TODO: Replace all these with `mkdir -p` commands
        # NOTE: FS doesn&#39;t exist at this point so running commands might not be possible (since some commands need fs)
        # Individually setup each directory in the root
        self.setup_bin()
        self.setup_etc()
        # self.setup_home()
        # self.setup_lib()
        self.setup_root()
        # self.setup_tmp()
        self.setup_usr()
        self.setup_var()

    def setup_bin(self) -&gt; None:
        &#34;&#34;&#34;
        Read all the files in the `client.blackhat.bin` directory and create a virtual file in the fs.
        All these files represent binaries in the system

        Returns:
            None
        &#34;&#34;&#34;
        bin_dir: Directory = self.files.find(&#34;bin&#34;)

        for file in os.listdir(&#34;./blackhat/bin&#34;):
            # Ignore the __init__.py and __pycache__ because those aren&#39;t bins (auto generated)
            if file not in [&#34;__init__.py&#34;, &#34;__pycache__&#34;, &#34;installable&#34;]:
                current_file = File(file.replace(&#34;.py&#34;, &#34;&#34;), &#34;[BINARY DATA]&#34;, bin_dir, 0, 0)
                with open(f&#34;./blackhat/bin/{file}&#34;, &#34;r&#34;) as f:
                    current_file.size = sys.getsizeof(f.read()) / 32
                    current_file.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;],
                                                &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}

                bin_dir.add_file(current_file)

    def setup_etc(self) -&gt; None:
        &#34;&#34;&#34;
        Sets up:
        &lt;ul&gt;
            &lt;li&gt;/etc/passwd - Contains the username, hashed password, and UID of all the users in the system&lt;/li&gt;
            &lt;li&gt;/etc/groups - Contains the list of groups in the systems (name, GID)&lt;/li&gt;
            &lt;li&gt;/etc/hostname - The hostname of the given `Computer`&lt;/li&gt;
            &lt;li&gt;/etc/skel -  A &#34;skeleton&#34; needed to create a users home folder (located in /home/&lt;USERNAME&gt;)&lt;/li&gt;
            &lt;li&gt;/etc/sudoers - The file that contains all of the sudo permissions&lt;/li&gt;
            &lt;li&gt;/etc/apt/sources.list - Contains urls of apt repo servers&lt;/li&gt;
        &lt;/ul&gt;

        Returns:
            None
        &#34;&#34;&#34;
        # TODO: Separate /etc/passwd and /etc/shadow
        etc_dir: Directory = self.files.find(&#34;etc&#34;)
        # Create the /etc/passwd file
        # The passwd file should have roots creds (bc root is created before the file)
        # passwd_file: File = File(&#34;passwd&#34;, f&#34;root:{self.computer.users[0].password}\n&#34;, etc_dir, 0, 0)
        passwd_file: File = File(&#34;passwd&#34;, f&#34;&#34;, etc_dir, 0, 0)
        etc_dir.add_file(passwd_file)

        # Create the /etc/groups file
        groups_file: File = File(&#34;group&#34;, f&#34;root:x:0&#34;, etc_dir, 0, 0)
        etc_dir.add_file(groups_file)

        # /etc/skel (home dir template)
        skel_dir: Directory = Directory(&#34;skel&#34;, etc_dir, 0, 0)

        for dir in [&#34;Desktop&#34;, &#34;Documents&#34;, &#34;Downloads&#34;, &#34;Music&#34;, &#34;Pictures&#34;, &#34;public&#34;, &#34;Templates&#34;, &#34;Videos&#34;]:
            current_dir = Directory(dir, skel_dir, 0, 0)
            current_dir.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;],
                                       &#34;execute&#34;: []}
            skel_dir.add_file(current_dir)

        # /etc/skel/.shellrc (.bashrc/.zshrc equivalent)
        skel_dir.add_file(File(&#34;.shellrc&#34;, &#34;&#34;, skel_dir, 0, 0))

        etc_dir.add_file(skel_dir)

        # /etc/hostname (holds system hostname)
        # Stupid windows style default hostnames (for fun, might change later)
        new_hostname = f&#34;DESKTOP-{&#39;&#39;.join([choice(ascii_uppercase + digits) for _ in range(7)])}&#34;
        etc_dir.add_file(File(&#34;hostname&#34;, new_hostname, etc_dir, 0, 0))

        # /etc/sudoers (holds sudo permissions)
        # Sudoers has permissions r--r-----
        sudoers_file: File = File(&#34;sudoers&#34;, &#34;root ALL=(ALL) ALL\n&#34;, etc_dir, 0, 0)
        sudoers_file.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;], &#34;write&#34;: [], &#34;execute&#34;: []}
        etc_dir.add_file(sudoers_file)

        # /etc/apt/sources.list
        apt_dir: Directory = Directory(&#34;apt&#34;, etc_dir, 0, 0)
        etc_dir.add_file(apt_dir)

        sources_file: File = File(&#34;sources.list&#34;, &#34;&#34;, apt_dir, 0, 0)
        apt_dir.add_file(sources_file)

    def setup_root(self) -&gt; None:
        &#34;&#34;&#34;
        Since the root user is different from a &#34;standard&#34; user, root&#39;s home folder needs to be setup separately.
        Otherwise, the format of root&#39;s home folder is the same as any other user

        Returns:
            None
        &#34;&#34;&#34;
        # Create /root/.shellrc
        root_dir: Directory = self.files.find(&#34;root&#34;)

        root_shellrc: File = File(&#34;.shellrc&#34;, &#34;export HOME=/root&#34;, root_dir, 0, 0)
        root_dir.add_file(root_shellrc)

    def setup_usr(self) -&gt; None:
        &#34;&#34;&#34;
        Sets up:
        &lt;ul&gt;
            &lt;li&gt;/usr/share/man - Contains all the &#34;man pages&#34;, or instruction manuals, for all the system binaries&lt;/li&gt;
            &lt;li&gt;/usr/bin - &#34;Aftermarket&#34; installed packages (apt) &lt;/li&gt;
        &lt;/ul&gt;

        Returns:
            None
        &#34;&#34;&#34;
        # Setup /usr/share
        usr_dir: Directory = self.files.find(&#34;usr&#34;)

        share_dir: Directory = Directory(&#34;share&#34;, usr_dir, 0, 0)
        usr_dir.add_file(share_dir)

        # /usr/share/man (stores man pages from __DOC__)
        man_dir: Directory = Directory(&#34;man&#34;, share_dir, 0, 0)
        share_dir.add_file(man_dir)

        # Loop through all the files in /bin and check if they have a __DOC__.
        for binary in self.files.find(&#34;bin&#34;).files.keys():
            try:
                module = importlib.import_module(f&#34;blackhat.bin.{binary}&#34;)
                current_manpage = File(binary, module.__DOC__, man_dir, 0, 0)
                man_dir.add_file(current_manpage)
            except AttributeError as e:
                pass

        bin_dir: Directory = Directory(&#34;bin&#34;, usr_dir, 0, 0)
        usr_dir.add_file(bin_dir)

    def setup_var(self) -&gt; None:
        &#34;&#34;&#34;
        Sets up:
        &lt;ul&gt;
            &lt;li&gt;/var/log - Contains various log files&lt;/li&gt;
            &lt;li&gt;/var/log/syslog - Logs various information about the given `Computer`&lt;/li&gt;
            &lt;li&gt;/var/log/auth.log - Logs information about authentication attempts&lt;/li&gt;
            &lt;li&gt;/var/lib/dpkg/status - The list of installed packages by apt&lt;/li&gt;
            &lt;li&gt;/var/www/html - Default location for web content served by web servers&lt;/li&gt;
        &lt;/ul&gt;

        Returns:
            None
        &#34;&#34;&#34;
        # This should exist at runtime
        var_dir: Directory = self.files.find(&#34;var&#34;)

        # Create /var/log
        log_dir: Directory = Directory(&#34;log&#34;, var_dir, 0, 0)
        # mv log -&gt; var
        var_dir.add_file(log_dir)

        # Create the `syslog` in /var/log
        log_dir.add_file(File(&#34;syslog&#34;, &#34;&#34;, log_dir, 0, 0))

        # Create /var/lib/dpkg/status
        lib_dir: Directory = Directory(&#34;lib&#34;, var_dir, 0, 0)
        var_dir.add_file(lib_dir)

        dpkg_dir: Directory = Directory(&#34;dpkg&#34;, lib_dir, 0, 0)
        lib_dir.add_file(dpkg_dir)

        status_file: File = File(&#34;status&#34;, &#34;&#34;, dpkg_dir, 0, 0)
        dpkg_dir.add_file(status_file)

        # Create /var/www/html
        www_dir: Directory = Directory(&#34;www&#34;, var_dir, 0, 0)
        var_dir.add_file(www_dir)

        html_dir: Directory = Directory(&#34;html&#34;, www_dir, 0, 0)
        www_dir.add_file(html_dir)

    def find(self, pathname: str) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Try to find a given file anywhere in the file system based on a given `pathname`

        Args:
            pathname (str): The full (absolute or relative) path of the file

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set accordingly and the `data` flag with the found `File` or `Directory` if the file was found
        &#34;&#34;&#34;

        # Special cases
        # Replace &#39;~&#39; with $HOME (if exists)
        get_home_env_var = self.computer.get_env(&#34;HOME&#34;)
        if get_home_env_var:
            pathname = pathname.replace(&#34;~&#34;, get_home_env_var)

        if pathname == &#34;/&#34;:
            return SysCallStatus(success=True, data=self.files)

        if pathname == &#34;.&#34;:
            return SysCallStatus(success=True, data=self.computer.get_pwd())

        if pathname == &#34;..&#34;:
            # Check if the directory has a parent
            # If it doesn&#39;t, we can assume that we&#39;re at /
            # In the case of /, just return /
            if not self.computer.get_pwd().parent:
                return SysCallStatus(success=True, data=self.files)
            else:
                return SysCallStatus(success=True, data=self.computer.get_pwd().parent)

        if pathname == &#34;...&#34;:
            # Check if the directory has a parent
            # If it doesn&#39;t, we can assume that we&#39;re at /
            # In the case of /, just return /
            # And then do it again (go back twice)0
            if not self.computer.get_pwd().parent:
                return SysCallStatus(success=True, data=self.computer.fs.files)
            else:
                current_dir = self.computer.get_pwd().parent
                if current_dir.parent:
                    return SysCallStatus(success=True, data=current_dir.parent)
                else:
                    return SysCallStatus(success=True, data=self.computer.fs.files)

        # Regular (non-special cases)
        pathname = pathname.split(&#34;/&#34;)
        # Check if `pathname` is absolute or relative
        # Check if the first arg is empty (because we split by /) which means the first arg is empty if it was a &#34;/&#34;
        if pathname[0] == &#34;&#34;:
            # Absolute (start at root dir)
            current_dir = self.files
        else:
            # Relative (based on current dir)
            current_dir = self.computer.get_pwd()

        # Filter out garbage
        while &#34;&#34; in pathname:
            pathname.remove(&#34;&#34;)

        for subdir in pathname:
            # Special case for current directory (.) (ignore it)
            if subdir == &#34;.&#34;:
                continue

            # Special case for (..) (go to parent)
            elif subdir == &#34;..&#34;:
                # Check if we&#39;re at the root
                if not current_dir.parent:
                    current_dir = self.files
                else:
                    current_dir = current_dir.parent

            else:
                current_dir = current_dir.find(subdir)
                if not current_dir:
                    return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

        # This only runs when we successfully found
        return SysCallStatus(success=True, data=current_dir)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="client.blackhat.fs.Directory"><code class="flex name class">
<span>class <span class="ident">Directory</span></span>
<span>(</span><span>name: str, parent: Optional[ForwardRef('<a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a>')], owner: int, group_owner: int)</span>
</code></dt>
<dd>
<div class="desc"><p>The class object representing a directory within the file system</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code>/<code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code></dd>
<dt><strong><code>parent</code></strong> :&ensp;<code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code></dt>
<dd>The <code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code> one level up the tree</dd>
<dt><strong><code>owner</code></strong> :&ensp;<code>int</code></dt>
<dd>The UID of the owner of the <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code>/<code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code></dd>
<dt><strong><code>group_owner</code></strong> :&ensp;<code>int</code></dt>
<dd>The GID of the owner of the <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code>/<code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Directory(FSBaseObject):
    def __init__(self, name: str, parent: Optional[&#34;Directory&#34;], owner: int, group_owner: int):
        &#34;&#34;&#34;
        The class object representing a directory within the file system

        Args:
            name (str): The name of the `File`/`Directory`
            parent (Directory): The `Directory` one level up the tree
            owner (int): The UID of the owner of the `File`/`Directory`
            group_owner (int): The GID of the owner of the `File`/`Directory`
        &#34;&#34;&#34;
        super().__init__(name, parent, owner, group_owner)
        self.files = {}
        self.size = None

        self.update_size()

    def add_file(self, file: Union[File, &#34;Directory&#34;]) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Add a new `File` or `Directory` to self&#39;s internal file map
        Also updates its size and triggers its parent to update their size

        Args:
            file (File/Directory): The `File`/`Directory` to add to self

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set accordingly
        &#34;&#34;&#34;
        if file.name in self.files.keys():
            return SysCallStatus(success=False, message=SysCallMessages.ALREADY_EXISTS)

        self.files[file.name] = file
        self.update_size()
        return SysCallStatus(success=True)

    def calculate_size(self) -&gt; int:
        &#34;&#34;&#34;
        Calculate a total size for the given directory and (recursively) all its children (`File`(s)/`Directory`(ies))

        Returns:
            int: The total size (in bytes) of the given directory
        &#34;&#34;&#34;
        total = 0

        for file in self.files.values():
            if file.is_directory():
                # Recursive
                total += file.calculate_size()
            else:
                if file.size:
                    total += file.size

        return total

    def find(self, filename: str) -&gt; Optional[Union[File, &#34;Directory&#34;]]:
        &#34;&#34;&#34;
        Find a `File` or `Directory` in self&#39;s internal file map

        Args:
            filename (str): The name of the `File`/`Directory` to find

        Returns:
            File or Directory or None: The `File` or `Directory` object if found, otherwise, None
        &#34;&#34;&#34;
        return self.files.get(filename, None)

    def update_size(self) -&gt; None:
        &#34;&#34;&#34;
        Update self&#39;s size using `calculate_size()` then, triggers self&#39;s parent to update their size

        Returns:
            None
        &#34;&#34;&#34;
        self.size = self.calculate_size()

        # This does the same as the file update size. Updates its own size
        # Then the parent updates its size, taking into account self&#39;s new size
        # Like a chain until all parent folders have been updated

        if self.parent:
            self.parent.update_size()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="client.blackhat.fs.FSBaseObject" href="#client.blackhat.fs.FSBaseObject">FSBaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="client.blackhat.fs.Directory.add_file"><code class="name flex">
<span>def <span class="ident">add_file</span></span>(<span>self, file: Union[<a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a>, ForwardRef('<a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a>')]) ‑> <a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Add a new <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code> or <code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code> to self's internal file map
Also updates its size and triggers its parent to update their size</p>
<h2 id="args">Args</h2>
<p>file (File/Directory): The <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code>/<code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code> to add to self</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> with the <code>success</code> flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_file(self, file: Union[File, &#34;Directory&#34;]) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Add a new `File` or `Directory` to self&#39;s internal file map
    Also updates its size and triggers its parent to update their size

    Args:
        file (File/Directory): The `File`/`Directory` to add to self

    Returns:
        SysCallStatus: A `SysCallStatus` with the `success` flag set accordingly
    &#34;&#34;&#34;
    if file.name in self.files.keys():
        return SysCallStatus(success=False, message=SysCallMessages.ALREADY_EXISTS)

    self.files[file.name] = file
    self.update_size()
    return SysCallStatus(success=True)</code></pre>
</details>
</dd>
<dt id="client.blackhat.fs.Directory.calculate_size"><code class="name flex">
<span>def <span class="ident">calculate_size</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate a total size for the given directory and (recursively) all its children (<code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code>(s)/<code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code>(ies))</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The total size (in bytes) of the given directory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_size(self) -&gt; int:
    &#34;&#34;&#34;
    Calculate a total size for the given directory and (recursively) all its children (`File`(s)/`Directory`(ies))

    Returns:
        int: The total size (in bytes) of the given directory
    &#34;&#34;&#34;
    total = 0

    for file in self.files.values():
        if file.is_directory():
            # Recursive
            total += file.calculate_size()
        else:
            if file.size:
                total += file.size

    return total</code></pre>
</details>
</dd>
<dt id="client.blackhat.fs.Directory.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, filename: str) ‑> Union[<a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a>, <a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Find a <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code> or <code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code> in self's internal file map</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code>/<code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code> to find</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code> or <code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code> or <code>None</code></dt>
<dd>The <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code> or <code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code> object if found, otherwise, None</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(self, filename: str) -&gt; Optional[Union[File, &#34;Directory&#34;]]:
    &#34;&#34;&#34;
    Find a `File` or `Directory` in self&#39;s internal file map

    Args:
        filename (str): The name of the `File`/`Directory` to find

    Returns:
        File or Directory or None: The `File` or `Directory` object if found, otherwise, None
    &#34;&#34;&#34;
    return self.files.get(filename, None)</code></pre>
</details>
</dd>
<dt id="client.blackhat.fs.Directory.update_size"><code class="name flex">
<span>def <span class="ident">update_size</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Update self's size using <code>calculate_size()</code> then, triggers self's parent to update their size</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_size(self) -&gt; None:
    &#34;&#34;&#34;
    Update self&#39;s size using `calculate_size()` then, triggers self&#39;s parent to update their size

    Returns:
        None
    &#34;&#34;&#34;
    self.size = self.calculate_size()

    # This does the same as the file update size. Updates its own size
    # Then the parent updates its size, taking into account self&#39;s new size
    # Like a chain until all parent folders have been updated

    if self.parent:
        self.parent.update_size()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="client.blackhat.fs.FSBaseObject" href="#client.blackhat.fs.FSBaseObject">FSBaseObject</a></b></code>:
<ul class="hlist">
<li><code><a title="client.blackhat.fs.FSBaseObject.atime" href="#client.blackhat.fs.FSBaseObject.atime">atime</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.change_owner" href="#client.blackhat.fs.FSBaseObject.change_owner">change_owner</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.check_owner" href="#client.blackhat.fs.FSBaseObject.check_owner">check_owner</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.check_perm" href="#client.blackhat.fs.FSBaseObject.check_perm">check_perm</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.ctime" href="#client.blackhat.fs.FSBaseObject.ctime">ctime</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.delete" href="#client.blackhat.fs.FSBaseObject.delete">delete</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.is_directory" href="#client.blackhat.fs.FSBaseObject.is_directory">is_directory</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.is_file" href="#client.blackhat.fs.FSBaseObject.is_file">is_file</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.mtime" href="#client.blackhat.fs.FSBaseObject.mtime">mtime</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.permissions" href="#client.blackhat.fs.FSBaseObject.permissions">permissions</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.pwd" href="#client.blackhat.fs.FSBaseObject.pwd">pwd</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="client.blackhat.fs.FSBaseObject"><code class="flex name class">
<span>class <span class="ident">FSBaseObject</span></span>
<span>(</span><span>name: str, parent: Optional[ForwardRef('<a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a>')], owner: int, group_owner: int)</span>
</code></dt>
<dd>
<div class="desc"><p>The base object that contains info shared between <code>Directories</code> and <code>Files</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code>/<code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code></dd>
<dt><strong><code>parent</code></strong> :&ensp;<code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code></dt>
<dd>The <code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code> one level up the tree</dd>
<dt><strong><code>owner</code></strong> :&ensp;<code>int</code></dt>
<dd>The UID of the owner of the <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code>/<code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code></dd>
<dt><strong><code>group_owner</code></strong> :&ensp;<code>int</code></dt>
<dd>The GID of the owner of the <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code>/<code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FSBaseObject:
    def __init__(self, name: str, parent: Optional[&#34;Directory&#34;], owner: int, group_owner: int) -&gt; None:
        &#34;&#34;&#34;
        The base object that contains info shared between `Directories` and `Files`

        Args:
            name (str): The name of the `File`/`Directory`
            parent (Directory): The `Directory` one level up the tree
            owner (int): The UID of the owner of the `File`/`Directory`
            group_owner (int): The GID of the owner of the `File`/`Directory`
        &#34;&#34;&#34;
        self.name: str = name
        self.permissions: Dict[str, List[Literal[&#34;read&#34;, &#34;write&#34;, &#34;execute&#34;]]] = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;],
                                                                                  &#34;write&#34;: [&#34;owner&#34;],
                                                                                  &#34;execute&#34;: []}
        &#34;&#34;&#34;Permissions for accessing the file. Default permissions; rw-r--r-- (644)&#34;&#34;&#34;
        self.parent: Optional[&#34;Directory&#34;] = parent
        self.owner: int = owner
        self.group_owner: int = group_owner
        self.link_count: int
        self.size: int
        self.atime: int  # Last access time (unix time stamp)
        &#34;&#34;&#34;int: Access time; when file was last read from/accessed&#34;&#34;&#34;
        self.mtime: int  # Last modified time (unix time stamp)
        &#34;&#34;&#34;int: Modified time; when the file&#34;s content was last modified&#34;&#34;&#34;
        self.ctime: int  # Last file status change (unix time stamp)
        &#34;&#34;&#34;imt: Changed time; when the file&#34;s metadata was last changed (ex. perms)&#34;&#34;&#34;

    def is_directory(self) -&gt; bool:
        &#34;&#34;&#34;
        Determines if a given item is a `Directory`

        Returns:
            bool: `True` if the given item is a `Directory` otherwise `False`
        &#34;&#34;&#34;
        return type(self) == Directory

    def is_file(self) -&gt; bool:
        &#34;&#34;&#34;
        Determines if a given item is a `File`

        Returns:
            bool: `True` if the given item is a `File` otherwise `False`
        &#34;&#34;&#34;
        return type(self) == File

    def check_perm(self, perm: Literal[&#34;read&#34;, &#34;write&#34;, &#34;execute&#34;], computer) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Checks if the current user has the given `perm`

        Args:
            perm (str): The permission to check (&#34;read&#34;, &#34;write&#34;, &#34;execute&#34;)
            computer: The current `Computer` instance

        Returns:
            SysCallStatus: A `SysCallStatus` object with the `success` flag set accordingly
        &#34;&#34;&#34;
        # If we&#34;re root (UID 0), return True because root has all permissions
        if computer.get_uid() == 0:
            return SysCallStatus(success=True)
        # If &#34;public&#34;, don&#34;t bother checking anything else
        if &#34;public&#34; in self.permissions[perm]:
            return SysCallStatus(success=True)

        if &#34;group&#34; in self.permissions[perm]:
            if self.group_owner in computer.find_user_groups(computer.get_uid()).data:
                return SysCallStatus(success=True)

        if &#34;owner&#34; in self.permissions[perm]:
            if self.owner == computer.get_uid():
                return SysCallStatus(success=True)

        # No permission
        return SysCallStatus(success=False, message=SysCallMessages.NOT_ALLOWED)

    def check_owner(self, computer) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Checks if the given UID or GID is one of the owners (for chmod/chgrp/etc)

        Args:
            computer: The current `Computer` instance

        Returns:
            SysCallStatus: A `SysCallStatus` object with the `success` flag set accordingly
        &#34;&#34;&#34;
        # Get the list of user&#39;s groups
        groups = computer.find_user_groups(computer.get_uid()).data

        if self.owner == computer.get_uid() or self.group_owner in groups:
            return SysCallStatus(success=True)
        else:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_ALLOWED)

    def change_owner(self, computer, new_user_owner: Optional[int] = None,
                     new_group_owner: Optional[int] = None) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Change the owner (user and/or group) of a given `File`/`Directory`, but check if the given UID should be allowed to first

        Args:
            computer: The current `Computer` instance
            new_user_owner (int): The UID of the new owner (user) of the `File`/`Directory`
            new_group_owner (int): The GID of the new owner (group) of the `File`/`Directory`

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set accordingly
        &#34;&#34;&#34;
        caller_groups = computer.find_user_groups(computer.get_uid()).data
        # Check if the owner or group owner is correct or if we&#39;re root
        if computer.get_uid() == self.owner or self.group_owner in caller_groups or computer.get_uid() == 0:
            # We need at least one of the two params (uid/gid)
            # Using `if not new_user_owner/not new_group_owner` won&#39;t work because `not 0` (root group) == True (???)
            if new_user_owner is None and new_group_owner is None:
                return SysCallStatus(success=False, message=SysCallMessages.MISSING_ARGUMENT)
            else:
                # Same thing with uid 0
                if new_user_owner is not None:
                    # Confirm that the user exists
                    if computer.find_user(uid=new_user_owner).success:
                        self.owner = new_user_owner
                    else:
                        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

                # Confirm that the new group exists
                # Same thing with gid 0
                if new_group_owner is not None:
                    # Confirm that the user exists
                    if computer.find_group(gid=new_group_owner).success:
                        self.group_owner = new_group_owner
                    else:
                        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

                return SysCallStatus(success=True)
        else:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_ALLOWED)

    def pwd(self) -&gt; str:
        &#34;&#34;&#34;
        Get the full path of the `File` in the file system

        Returns:
            str: A complete file path starting at / (root)
        &#34;&#34;&#34;
        current_dir = self
        working_dir = []

        while True:
            # Check if we&#39;re at /
            working_dir.append(current_dir.name)
            if not current_dir.parent:
                break
            current_dir = current_dir.parent

        working_dir.reverse()
        working_dir = &#34;/&#34;.join(working_dir)
        # Try to remove double slash
        if working_dir.startswith(&#34;//&#34;):
            working_dir = working_dir[1:]

        return working_dir

    def delete(self, computer) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Check if the `caller` has the proper permissions to delete a given file, then remove it

        Args:
            computer: The current computer object

        Returns:
            SysCallStatus: A `SysCallStatus` object with the `success` flag set accordingly
        &#34;&#34;&#34;
        if self.parent:
            # In unix, we need read+write permissions to delete
            if self.check_perm(&#34;read&#34;, computer).success and self.check_perm(&#34;write&#34;, computer).success:
                del self.parent.files[self.name]
                return SysCallStatus(success=True)
            else:
                return SysCallStatus(success=False, message=SysCallMessages.NOT_ALLOWED)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></li>
<li><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="client.blackhat.fs.FSBaseObject.atime"><code class="name">var <span class="ident">atime</span></code></dt>
<dd>
<div class="desc"><p>int: Access time; when file was last read from/accessed</p></div>
</dd>
<dt id="client.blackhat.fs.FSBaseObject.ctime"><code class="name">var <span class="ident">ctime</span></code></dt>
<dd>
<div class="desc"><p>imt: Changed time; when the file"s metadata was last changed (ex. perms)</p></div>
</dd>
<dt id="client.blackhat.fs.FSBaseObject.mtime"><code class="name">var <span class="ident">mtime</span></code></dt>
<dd>
<div class="desc"><p>int: Modified time; when the file"s content was last modified</p></div>
</dd>
<dt id="client.blackhat.fs.FSBaseObject.permissions"><code class="name">var <span class="ident">permissions</span></code></dt>
<dd>
<div class="desc"><p>Permissions for accessing the file. Default permissions; rw-r&ndash;r&ndash; (644)</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="client.blackhat.fs.FSBaseObject.change_owner"><code class="name flex">
<span>def <span class="ident">change_owner</span></span>(<span>self, computer, new_user_owner: Optional[int] = None, new_group_owner: Optional[int] = None) ‑> <a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Change the owner (user and/or group) of a given <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code>/<code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code>, but check if the given UID should be allowed to first</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>computer</code></strong></dt>
<dd>The current <code>Computer</code> instance</dd>
<dt><strong><code>new_user_owner</code></strong> :&ensp;<code>int</code></dt>
<dd>The UID of the new owner (user) of the <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code>/<code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code></dd>
<dt><strong><code>new_group_owner</code></strong> :&ensp;<code>int</code></dt>
<dd>The GID of the new owner (group) of the <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code>/<code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> with the <code>success</code> flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_owner(self, computer, new_user_owner: Optional[int] = None,
                 new_group_owner: Optional[int] = None) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Change the owner (user and/or group) of a given `File`/`Directory`, but check if the given UID should be allowed to first

    Args:
        computer: The current `Computer` instance
        new_user_owner (int): The UID of the new owner (user) of the `File`/`Directory`
        new_group_owner (int): The GID of the new owner (group) of the `File`/`Directory`

    Returns:
        SysCallStatus: A `SysCallStatus` with the `success` flag set accordingly
    &#34;&#34;&#34;
    caller_groups = computer.find_user_groups(computer.get_uid()).data
    # Check if the owner or group owner is correct or if we&#39;re root
    if computer.get_uid() == self.owner or self.group_owner in caller_groups or computer.get_uid() == 0:
        # We need at least one of the two params (uid/gid)
        # Using `if not new_user_owner/not new_group_owner` won&#39;t work because `not 0` (root group) == True (???)
        if new_user_owner is None and new_group_owner is None:
            return SysCallStatus(success=False, message=SysCallMessages.MISSING_ARGUMENT)
        else:
            # Same thing with uid 0
            if new_user_owner is not None:
                # Confirm that the user exists
                if computer.find_user(uid=new_user_owner).success:
                    self.owner = new_user_owner
                else:
                    return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

            # Confirm that the new group exists
            # Same thing with gid 0
            if new_group_owner is not None:
                # Confirm that the user exists
                if computer.find_group(gid=new_group_owner).success:
                    self.group_owner = new_group_owner
                else:
                    return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

            return SysCallStatus(success=True)
    else:
        return SysCallStatus(success=False, message=SysCallMessages.NOT_ALLOWED)</code></pre>
</details>
</dd>
<dt id="client.blackhat.fs.FSBaseObject.check_owner"><code class="name flex">
<span>def <span class="ident">check_owner</span></span>(<span>self, computer) ‑> <a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the given UID or GID is one of the owners (for chmod/chgrp/etc)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>computer</code></strong></dt>
<dd>The current <code>Computer</code> instance</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> object with the <code>success</code> flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_owner(self, computer) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Checks if the given UID or GID is one of the owners (for chmod/chgrp/etc)

    Args:
        computer: The current `Computer` instance

    Returns:
        SysCallStatus: A `SysCallStatus` object with the `success` flag set accordingly
    &#34;&#34;&#34;
    # Get the list of user&#39;s groups
    groups = computer.find_user_groups(computer.get_uid()).data

    if self.owner == computer.get_uid() or self.group_owner in groups:
        return SysCallStatus(success=True)
    else:
        return SysCallStatus(success=False, message=SysCallMessages.NOT_ALLOWED)</code></pre>
</details>
</dd>
<dt id="client.blackhat.fs.FSBaseObject.check_perm"><code class="name flex">
<span>def <span class="ident">check_perm</span></span>(<span>self, perm: Literal['read', 'write', 'execute'], computer) ‑> <a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the current user has the given <code>perm</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>perm</code></strong> :&ensp;<code>str</code></dt>
<dd>The permission to check ("read", "write", "execute")</dd>
<dt><strong><code>computer</code></strong></dt>
<dd>The current <code>Computer</code> instance</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> object with the <code>success</code> flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_perm(self, perm: Literal[&#34;read&#34;, &#34;write&#34;, &#34;execute&#34;], computer) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Checks if the current user has the given `perm`

    Args:
        perm (str): The permission to check (&#34;read&#34;, &#34;write&#34;, &#34;execute&#34;)
        computer: The current `Computer` instance

    Returns:
        SysCallStatus: A `SysCallStatus` object with the `success` flag set accordingly
    &#34;&#34;&#34;
    # If we&#34;re root (UID 0), return True because root has all permissions
    if computer.get_uid() == 0:
        return SysCallStatus(success=True)
    # If &#34;public&#34;, don&#34;t bother checking anything else
    if &#34;public&#34; in self.permissions[perm]:
        return SysCallStatus(success=True)

    if &#34;group&#34; in self.permissions[perm]:
        if self.group_owner in computer.find_user_groups(computer.get_uid()).data:
            return SysCallStatus(success=True)

    if &#34;owner&#34; in self.permissions[perm]:
        if self.owner == computer.get_uid():
            return SysCallStatus(success=True)

    # No permission
    return SysCallStatus(success=False, message=SysCallMessages.NOT_ALLOWED)</code></pre>
</details>
</dd>
<dt id="client.blackhat.fs.FSBaseObject.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, computer) ‑> <a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Check if the <code>caller</code> has the proper permissions to delete a given file, then remove it</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>computer</code></strong></dt>
<dd>The current computer object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> object with the <code>success</code> flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, computer) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Check if the `caller` has the proper permissions to delete a given file, then remove it

    Args:
        computer: The current computer object

    Returns:
        SysCallStatus: A `SysCallStatus` object with the `success` flag set accordingly
    &#34;&#34;&#34;
    if self.parent:
        # In unix, we need read+write permissions to delete
        if self.check_perm(&#34;read&#34;, computer).success and self.check_perm(&#34;write&#34;, computer).success:
            del self.parent.files[self.name]
            return SysCallStatus(success=True)
        else:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_ALLOWED)</code></pre>
</details>
</dd>
<dt id="client.blackhat.fs.FSBaseObject.is_directory"><code class="name flex">
<span>def <span class="ident">is_directory</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if a given item is a <code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if the given item is a <code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code> otherwise <code>False</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_directory(self) -&gt; bool:
    &#34;&#34;&#34;
    Determines if a given item is a `Directory`

    Returns:
        bool: `True` if the given item is a `Directory` otherwise `False`
    &#34;&#34;&#34;
    return type(self) == Directory</code></pre>
</details>
</dd>
<dt id="client.blackhat.fs.FSBaseObject.is_file"><code class="name flex">
<span>def <span class="ident">is_file</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if a given item is a <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if the given item is a <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code> otherwise <code>False</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_file(self) -&gt; bool:
    &#34;&#34;&#34;
    Determines if a given item is a `File`

    Returns:
        bool: `True` if the given item is a `File` otherwise `False`
    &#34;&#34;&#34;
    return type(self) == File</code></pre>
</details>
</dd>
<dt id="client.blackhat.fs.FSBaseObject.pwd"><code class="name flex">
<span>def <span class="ident">pwd</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the full path of the <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code> in the file system</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A complete file path starting at / (root)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pwd(self) -&gt; str:
    &#34;&#34;&#34;
    Get the full path of the `File` in the file system

    Returns:
        str: A complete file path starting at / (root)
    &#34;&#34;&#34;
    current_dir = self
    working_dir = []

    while True:
        # Check if we&#39;re at /
        working_dir.append(current_dir.name)
        if not current_dir.parent:
            break
        current_dir = current_dir.parent

    working_dir.reverse()
    working_dir = &#34;/&#34;.join(working_dir)
    # Try to remove double slash
    if working_dir.startswith(&#34;//&#34;):
        working_dir = working_dir[1:]

    return working_dir</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="client.blackhat.fs.File"><code class="flex name class">
<span>class <span class="ident">File</span></span>
<span>(</span><span>name: str, content: str, parent: <a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a>, owner: int, group_owner: int)</span>
</code></dt>
<dd>
<div class="desc"><p>The class object representing a file in the file system</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the given <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code></dd>
<dt><strong><code>content</code></strong> :&ensp;<code>str</code></dt>
<dd>The content within the given file. May be blank (empty string)</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code></dt>
<dd>The <code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code> one level up the tree</dd>
<dt><strong><code>owner</code></strong> :&ensp;<code>int</code></dt>
<dd>The UID of the owner of the <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code>/<code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code></dd>
<dt><strong><code>group_owner</code></strong> :&ensp;<code>int</code></dt>
<dd>The GID of the owner of the <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code>/`Directory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class File(FSBaseObject):
    def __init__(self, name: str, content: str, parent: &#34;Directory&#34;, owner: int, group_owner: int) -&gt; None:
        &#34;&#34;&#34;
        The class object representing a file in the file system

        Args:
            name (str): The name of the given `File`
            content (str): The content within the given file. May be blank (empty string)
            parent (Directory): The `Directory` one level up the tree
            owner (int): The UID of the owner of the `File`/`Directory`
            group_owner (int): The GID of the owner of the `File`/`Directory
        &#34;&#34;&#34;
        super().__init__(name, parent, owner, group_owner)
        self.content = content
        self.size = sys.getsizeof(self.name + self.content)

    def read(self, computer) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Check if the current UID has permission to read the content of the file. Afterwards, return the content if allowed

        Args:
            computer: The current `Computer` instance

        Returns:
            SysCallStatus: A `SysCallStatus` object with the `success` flag set and the `data` flag set with the file&#39;s content if permitted
        &#34;&#34;&#34;
        if self.check_perm(&#34;read&#34;, computer).success:
            return SysCallStatus(success=True, data=self.content)
        else:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_ALLOWED)

    def write(self, data: str, computer) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Check if the current UID has permission to write to the file. Update the file&#39;s contents if allowed

        Args:
            data (str): The new content to write to the `File`
            computer: The current `Computer` instance

        Returns:
            SysCallStatus: A `SysCallStatus` object with the `success` flag accordingly
        &#34;&#34;&#34;
        if self.check_perm(&#34;write&#34;, computer).success:
            self.content = data
            self.update_size()
            return SysCallStatus(success=True)
        else:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_ALLOWED)

    def append(self, data: str, computer) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Check if the current UID has permission to write to the file. Append to the file&#39;s contents if allowed

        Args:
            data (str): The content to append to the `File`s current content
            computer: The current `Computer` instance

        Returns:
            SysCallStatus: A `SysCallStatus` object with the `success` flag accordingly
        &#34;&#34;&#34;
        # NOTE: This may be unnecessary, we&#34;ll find out later
        if self.check_perm(&#34;write&#34;, computer).success:
            self.content += data
            self.update_size()
            return SysCallStatus(success=True)
        else:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_ALLOWED)

    def update_size(self) -&gt; None:
        &#34;&#34;&#34;
        Calculates the size of the `File` and set in the object.
        Also, recursively tells it&#39;s parent to update its size.

        Returns:
            None
        &#34;&#34;&#34;
        self.size = sys.getsizeof(self.name + self.content)

        # First, update our own size
        self.size = sys.getsizeof(self.content + self.name)
        # Now, recursively update our parent&#34;s size
        if self.parent:
            self.parent.update_size()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="client.blackhat.fs.FSBaseObject" href="#client.blackhat.fs.FSBaseObject">FSBaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="client.blackhat.fs.File.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, data: str, computer) ‑> <a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Check if the current UID has permission to write to the file. Append to the file's contents if allowed</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>str</code></dt>
<dd>The content to append to the <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code>s current content</dd>
<dt><strong><code>computer</code></strong></dt>
<dd>The current <code>Computer</code> instance</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> object with the <code>success</code> flag accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, data: str, computer) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Check if the current UID has permission to write to the file. Append to the file&#39;s contents if allowed

    Args:
        data (str): The content to append to the `File`s current content
        computer: The current `Computer` instance

    Returns:
        SysCallStatus: A `SysCallStatus` object with the `success` flag accordingly
    &#34;&#34;&#34;
    # NOTE: This may be unnecessary, we&#34;ll find out later
    if self.check_perm(&#34;write&#34;, computer).success:
        self.content += data
        self.update_size()
        return SysCallStatus(success=True)
    else:
        return SysCallStatus(success=False, message=SysCallMessages.NOT_ALLOWED)</code></pre>
</details>
</dd>
<dt id="client.blackhat.fs.File.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, computer) ‑> <a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Check if the current UID has permission to read the content of the file. Afterwards, return the content if allowed</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>computer</code></strong></dt>
<dd>The current <code>Computer</code> instance</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> object with the <code>success</code> flag set and the <code>data</code> flag set with the file's content if permitted</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, computer) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Check if the current UID has permission to read the content of the file. Afterwards, return the content if allowed

    Args:
        computer: The current `Computer` instance

    Returns:
        SysCallStatus: A `SysCallStatus` object with the `success` flag set and the `data` flag set with the file&#39;s content if permitted
    &#34;&#34;&#34;
    if self.check_perm(&#34;read&#34;, computer).success:
        return SysCallStatus(success=True, data=self.content)
    else:
        return SysCallStatus(success=False, message=SysCallMessages.NOT_ALLOWED)</code></pre>
</details>
</dd>
<dt id="client.blackhat.fs.File.update_size"><code class="name flex">
<span>def <span class="ident">update_size</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the size of the <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code> and set in the object.
Also, recursively tells it's parent to update its size.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_size(self) -&gt; None:
    &#34;&#34;&#34;
    Calculates the size of the `File` and set in the object.
    Also, recursively tells it&#39;s parent to update its size.

    Returns:
        None
    &#34;&#34;&#34;
    self.size = sys.getsizeof(self.name + self.content)

    # First, update our own size
    self.size = sys.getsizeof(self.content + self.name)
    # Now, recursively update our parent&#34;s size
    if self.parent:
        self.parent.update_size()</code></pre>
</details>
</dd>
<dt id="client.blackhat.fs.File.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, data: str, computer) ‑> <a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Check if the current UID has permission to write to the file. Update the file's contents if allowed</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>str</code></dt>
<dd>The new content to write to the <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code></dd>
<dt><strong><code>computer</code></strong></dt>
<dd>The current <code>Computer</code> instance</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> object with the <code>success</code> flag accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, data: str, computer) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Check if the current UID has permission to write to the file. Update the file&#39;s contents if allowed

    Args:
        data (str): The new content to write to the `File`
        computer: The current `Computer` instance

    Returns:
        SysCallStatus: A `SysCallStatus` object with the `success` flag accordingly
    &#34;&#34;&#34;
    if self.check_perm(&#34;write&#34;, computer).success:
        self.content = data
        self.update_size()
        return SysCallStatus(success=True)
    else:
        return SysCallStatus(success=False, message=SysCallMessages.NOT_ALLOWED)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="client.blackhat.fs.FSBaseObject" href="#client.blackhat.fs.FSBaseObject">FSBaseObject</a></b></code>:
<ul class="hlist">
<li><code><a title="client.blackhat.fs.FSBaseObject.atime" href="#client.blackhat.fs.FSBaseObject.atime">atime</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.change_owner" href="#client.blackhat.fs.FSBaseObject.change_owner">change_owner</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.check_owner" href="#client.blackhat.fs.FSBaseObject.check_owner">check_owner</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.check_perm" href="#client.blackhat.fs.FSBaseObject.check_perm">check_perm</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.ctime" href="#client.blackhat.fs.FSBaseObject.ctime">ctime</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.delete" href="#client.blackhat.fs.FSBaseObject.delete">delete</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.is_directory" href="#client.blackhat.fs.FSBaseObject.is_directory">is_directory</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.is_file" href="#client.blackhat.fs.FSBaseObject.is_file">is_file</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.mtime" href="#client.blackhat.fs.FSBaseObject.mtime">mtime</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.permissions" href="#client.blackhat.fs.FSBaseObject.permissions">permissions</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.pwd" href="#client.blackhat.fs.FSBaseObject.pwd">pwd</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="client.blackhat.fs.StandardFS"><code class="flex name class">
<span>class <span class="ident">StandardFS</span></span>
<span>(</span><span>computer)</span>
</code></dt>
<dd>
<div class="desc"><p>The class object representing a file system that belongs to a <code>Computer</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>computer</code></strong> :&ensp;<code>Computer</code></dt>
<dd>The <code>Computer</code> that the given file system belongs to</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StandardFS:
    def __init__(self, computer) -&gt; None:
        &#34;&#34;&#34;
        The class object representing a file system that belongs to a `Computer`

        Args:
            computer (Computer): The `Computer` that the given file system belongs to
        &#34;&#34;&#34;
        self.computer = computer

        # The filesystem root (/) (owned by root)
        self.files = Directory(&#34;/&#34;, None, 0, 0)

        self.init()

    def init(self) -&gt; None:
        &#34;&#34;&#34;
        All the functions required to setup a new filesystem

        Returns:
            None
        &#34;&#34;&#34;
        # Setup the directory structure in the file system (Unix FHS)
        for dir in [&#34;bin&#34;, &#34;etc&#34;, &#34;home&#34;, &#34;lib&#34;, &#34;root&#34;, &#34;tmp&#34;, &#34;usr&#34;, &#34;var&#34;]:
            directory = Directory(dir, self.files, 0, 0)
            # Special case for /tmp (read and write by everyone)
            if dir == &#34;tmp&#34;:
                directory.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;],
                                         &#34;execute&#34;: []}
            else:
                # TODO: Change this to be more accurate
                # (rwx rw- r--)
                directory.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;, &#34;group&#34;],
                                         &#34;execute&#34;: [&#34;owner&#34;]}

            self.files.add_file(directory)

        # TODO: Replace all these with `mkdir -p` commands
        # NOTE: FS doesn&#39;t exist at this point so running commands might not be possible (since some commands need fs)
        # Individually setup each directory in the root
        self.setup_bin()
        self.setup_etc()
        # self.setup_home()
        # self.setup_lib()
        self.setup_root()
        # self.setup_tmp()
        self.setup_usr()
        self.setup_var()

    def setup_bin(self) -&gt; None:
        &#34;&#34;&#34;
        Read all the files in the `client.blackhat.bin` directory and create a virtual file in the fs.
        All these files represent binaries in the system

        Returns:
            None
        &#34;&#34;&#34;
        bin_dir: Directory = self.files.find(&#34;bin&#34;)

        for file in os.listdir(&#34;./blackhat/bin&#34;):
            # Ignore the __init__.py and __pycache__ because those aren&#39;t bins (auto generated)
            if file not in [&#34;__init__.py&#34;, &#34;__pycache__&#34;, &#34;installable&#34;]:
                current_file = File(file.replace(&#34;.py&#34;, &#34;&#34;), &#34;[BINARY DATA]&#34;, bin_dir, 0, 0)
                with open(f&#34;./blackhat/bin/{file}&#34;, &#34;r&#34;) as f:
                    current_file.size = sys.getsizeof(f.read()) / 32
                    current_file.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;],
                                                &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}

                bin_dir.add_file(current_file)

    def setup_etc(self) -&gt; None:
        &#34;&#34;&#34;
        Sets up:
        &lt;ul&gt;
            &lt;li&gt;/etc/passwd - Contains the username, hashed password, and UID of all the users in the system&lt;/li&gt;
            &lt;li&gt;/etc/groups - Contains the list of groups in the systems (name, GID)&lt;/li&gt;
            &lt;li&gt;/etc/hostname - The hostname of the given `Computer`&lt;/li&gt;
            &lt;li&gt;/etc/skel -  A &#34;skeleton&#34; needed to create a users home folder (located in /home/&lt;USERNAME&gt;)&lt;/li&gt;
            &lt;li&gt;/etc/sudoers - The file that contains all of the sudo permissions&lt;/li&gt;
            &lt;li&gt;/etc/apt/sources.list - Contains urls of apt repo servers&lt;/li&gt;
        &lt;/ul&gt;

        Returns:
            None
        &#34;&#34;&#34;
        # TODO: Separate /etc/passwd and /etc/shadow
        etc_dir: Directory = self.files.find(&#34;etc&#34;)
        # Create the /etc/passwd file
        # The passwd file should have roots creds (bc root is created before the file)
        # passwd_file: File = File(&#34;passwd&#34;, f&#34;root:{self.computer.users[0].password}\n&#34;, etc_dir, 0, 0)
        passwd_file: File = File(&#34;passwd&#34;, f&#34;&#34;, etc_dir, 0, 0)
        etc_dir.add_file(passwd_file)

        # Create the /etc/groups file
        groups_file: File = File(&#34;group&#34;, f&#34;root:x:0&#34;, etc_dir, 0, 0)
        etc_dir.add_file(groups_file)

        # /etc/skel (home dir template)
        skel_dir: Directory = Directory(&#34;skel&#34;, etc_dir, 0, 0)

        for dir in [&#34;Desktop&#34;, &#34;Documents&#34;, &#34;Downloads&#34;, &#34;Music&#34;, &#34;Pictures&#34;, &#34;public&#34;, &#34;Templates&#34;, &#34;Videos&#34;]:
            current_dir = Directory(dir, skel_dir, 0, 0)
            current_dir.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;],
                                       &#34;execute&#34;: []}
            skel_dir.add_file(current_dir)

        # /etc/skel/.shellrc (.bashrc/.zshrc equivalent)
        skel_dir.add_file(File(&#34;.shellrc&#34;, &#34;&#34;, skel_dir, 0, 0))

        etc_dir.add_file(skel_dir)

        # /etc/hostname (holds system hostname)
        # Stupid windows style default hostnames (for fun, might change later)
        new_hostname = f&#34;DESKTOP-{&#39;&#39;.join([choice(ascii_uppercase + digits) for _ in range(7)])}&#34;
        etc_dir.add_file(File(&#34;hostname&#34;, new_hostname, etc_dir, 0, 0))

        # /etc/sudoers (holds sudo permissions)
        # Sudoers has permissions r--r-----
        sudoers_file: File = File(&#34;sudoers&#34;, &#34;root ALL=(ALL) ALL\n&#34;, etc_dir, 0, 0)
        sudoers_file.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;], &#34;write&#34;: [], &#34;execute&#34;: []}
        etc_dir.add_file(sudoers_file)

        # /etc/apt/sources.list
        apt_dir: Directory = Directory(&#34;apt&#34;, etc_dir, 0, 0)
        etc_dir.add_file(apt_dir)

        sources_file: File = File(&#34;sources.list&#34;, &#34;&#34;, apt_dir, 0, 0)
        apt_dir.add_file(sources_file)

    def setup_root(self) -&gt; None:
        &#34;&#34;&#34;
        Since the root user is different from a &#34;standard&#34; user, root&#39;s home folder needs to be setup separately.
        Otherwise, the format of root&#39;s home folder is the same as any other user

        Returns:
            None
        &#34;&#34;&#34;
        # Create /root/.shellrc
        root_dir: Directory = self.files.find(&#34;root&#34;)

        root_shellrc: File = File(&#34;.shellrc&#34;, &#34;export HOME=/root&#34;, root_dir, 0, 0)
        root_dir.add_file(root_shellrc)

    def setup_usr(self) -&gt; None:
        &#34;&#34;&#34;
        Sets up:
        &lt;ul&gt;
            &lt;li&gt;/usr/share/man - Contains all the &#34;man pages&#34;, or instruction manuals, for all the system binaries&lt;/li&gt;
            &lt;li&gt;/usr/bin - &#34;Aftermarket&#34; installed packages (apt) &lt;/li&gt;
        &lt;/ul&gt;

        Returns:
            None
        &#34;&#34;&#34;
        # Setup /usr/share
        usr_dir: Directory = self.files.find(&#34;usr&#34;)

        share_dir: Directory = Directory(&#34;share&#34;, usr_dir, 0, 0)
        usr_dir.add_file(share_dir)

        # /usr/share/man (stores man pages from __DOC__)
        man_dir: Directory = Directory(&#34;man&#34;, share_dir, 0, 0)
        share_dir.add_file(man_dir)

        # Loop through all the files in /bin and check if they have a __DOC__.
        for binary in self.files.find(&#34;bin&#34;).files.keys():
            try:
                module = importlib.import_module(f&#34;blackhat.bin.{binary}&#34;)
                current_manpage = File(binary, module.__DOC__, man_dir, 0, 0)
                man_dir.add_file(current_manpage)
            except AttributeError as e:
                pass

        bin_dir: Directory = Directory(&#34;bin&#34;, usr_dir, 0, 0)
        usr_dir.add_file(bin_dir)

    def setup_var(self) -&gt; None:
        &#34;&#34;&#34;
        Sets up:
        &lt;ul&gt;
            &lt;li&gt;/var/log - Contains various log files&lt;/li&gt;
            &lt;li&gt;/var/log/syslog - Logs various information about the given `Computer`&lt;/li&gt;
            &lt;li&gt;/var/log/auth.log - Logs information about authentication attempts&lt;/li&gt;
            &lt;li&gt;/var/lib/dpkg/status - The list of installed packages by apt&lt;/li&gt;
            &lt;li&gt;/var/www/html - Default location for web content served by web servers&lt;/li&gt;
        &lt;/ul&gt;

        Returns:
            None
        &#34;&#34;&#34;
        # This should exist at runtime
        var_dir: Directory = self.files.find(&#34;var&#34;)

        # Create /var/log
        log_dir: Directory = Directory(&#34;log&#34;, var_dir, 0, 0)
        # mv log -&gt; var
        var_dir.add_file(log_dir)

        # Create the `syslog` in /var/log
        log_dir.add_file(File(&#34;syslog&#34;, &#34;&#34;, log_dir, 0, 0))

        # Create /var/lib/dpkg/status
        lib_dir: Directory = Directory(&#34;lib&#34;, var_dir, 0, 0)
        var_dir.add_file(lib_dir)

        dpkg_dir: Directory = Directory(&#34;dpkg&#34;, lib_dir, 0, 0)
        lib_dir.add_file(dpkg_dir)

        status_file: File = File(&#34;status&#34;, &#34;&#34;, dpkg_dir, 0, 0)
        dpkg_dir.add_file(status_file)

        # Create /var/www/html
        www_dir: Directory = Directory(&#34;www&#34;, var_dir, 0, 0)
        var_dir.add_file(www_dir)

        html_dir: Directory = Directory(&#34;html&#34;, www_dir, 0, 0)
        www_dir.add_file(html_dir)

    def find(self, pathname: str) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Try to find a given file anywhere in the file system based on a given `pathname`

        Args:
            pathname (str): The full (absolute or relative) path of the file

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set accordingly and the `data` flag with the found `File` or `Directory` if the file was found
        &#34;&#34;&#34;

        # Special cases
        # Replace &#39;~&#39; with $HOME (if exists)
        get_home_env_var = self.computer.get_env(&#34;HOME&#34;)
        if get_home_env_var:
            pathname = pathname.replace(&#34;~&#34;, get_home_env_var)

        if pathname == &#34;/&#34;:
            return SysCallStatus(success=True, data=self.files)

        if pathname == &#34;.&#34;:
            return SysCallStatus(success=True, data=self.computer.get_pwd())

        if pathname == &#34;..&#34;:
            # Check if the directory has a parent
            # If it doesn&#39;t, we can assume that we&#39;re at /
            # In the case of /, just return /
            if not self.computer.get_pwd().parent:
                return SysCallStatus(success=True, data=self.files)
            else:
                return SysCallStatus(success=True, data=self.computer.get_pwd().parent)

        if pathname == &#34;...&#34;:
            # Check if the directory has a parent
            # If it doesn&#39;t, we can assume that we&#39;re at /
            # In the case of /, just return /
            # And then do it again (go back twice)0
            if not self.computer.get_pwd().parent:
                return SysCallStatus(success=True, data=self.computer.fs.files)
            else:
                current_dir = self.computer.get_pwd().parent
                if current_dir.parent:
                    return SysCallStatus(success=True, data=current_dir.parent)
                else:
                    return SysCallStatus(success=True, data=self.computer.fs.files)

        # Regular (non-special cases)
        pathname = pathname.split(&#34;/&#34;)
        # Check if `pathname` is absolute or relative
        # Check if the first arg is empty (because we split by /) which means the first arg is empty if it was a &#34;/&#34;
        if pathname[0] == &#34;&#34;:
            # Absolute (start at root dir)
            current_dir = self.files
        else:
            # Relative (based on current dir)
            current_dir = self.computer.get_pwd()

        # Filter out garbage
        while &#34;&#34; in pathname:
            pathname.remove(&#34;&#34;)

        for subdir in pathname:
            # Special case for current directory (.) (ignore it)
            if subdir == &#34;.&#34;:
                continue

            # Special case for (..) (go to parent)
            elif subdir == &#34;..&#34;:
                # Check if we&#39;re at the root
                if not current_dir.parent:
                    current_dir = self.files
                else:
                    current_dir = current_dir.parent

            else:
                current_dir = current_dir.find(subdir)
                if not current_dir:
                    return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

        # This only runs when we successfully found
        return SysCallStatus(success=True, data=current_dir)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="client.blackhat.fs.StandardFS.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, pathname: str) ‑> <a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Try to find a given file anywhere in the file system based on a given <code>pathname</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pathname</code></strong> :&ensp;<code>str</code></dt>
<dd>The full (absolute or relative) path of the file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> with the <code>success</code> flag set accordingly and the <code>data</code> flag with the found <code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code> or <code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code> if the file was found</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(self, pathname: str) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Try to find a given file anywhere in the file system based on a given `pathname`

    Args:
        pathname (str): The full (absolute or relative) path of the file

    Returns:
        SysCallStatus: A `SysCallStatus` with the `success` flag set accordingly and the `data` flag with the found `File` or `Directory` if the file was found
    &#34;&#34;&#34;

    # Special cases
    # Replace &#39;~&#39; with $HOME (if exists)
    get_home_env_var = self.computer.get_env(&#34;HOME&#34;)
    if get_home_env_var:
        pathname = pathname.replace(&#34;~&#34;, get_home_env_var)

    if pathname == &#34;/&#34;:
        return SysCallStatus(success=True, data=self.files)

    if pathname == &#34;.&#34;:
        return SysCallStatus(success=True, data=self.computer.get_pwd())

    if pathname == &#34;..&#34;:
        # Check if the directory has a parent
        # If it doesn&#39;t, we can assume that we&#39;re at /
        # In the case of /, just return /
        if not self.computer.get_pwd().parent:
            return SysCallStatus(success=True, data=self.files)
        else:
            return SysCallStatus(success=True, data=self.computer.get_pwd().parent)

    if pathname == &#34;...&#34;:
        # Check if the directory has a parent
        # If it doesn&#39;t, we can assume that we&#39;re at /
        # In the case of /, just return /
        # And then do it again (go back twice)0
        if not self.computer.get_pwd().parent:
            return SysCallStatus(success=True, data=self.computer.fs.files)
        else:
            current_dir = self.computer.get_pwd().parent
            if current_dir.parent:
                return SysCallStatus(success=True, data=current_dir.parent)
            else:
                return SysCallStatus(success=True, data=self.computer.fs.files)

    # Regular (non-special cases)
    pathname = pathname.split(&#34;/&#34;)
    # Check if `pathname` is absolute or relative
    # Check if the first arg is empty (because we split by /) which means the first arg is empty if it was a &#34;/&#34;
    if pathname[0] == &#34;&#34;:
        # Absolute (start at root dir)
        current_dir = self.files
    else:
        # Relative (based on current dir)
        current_dir = self.computer.get_pwd()

    # Filter out garbage
    while &#34;&#34; in pathname:
        pathname.remove(&#34;&#34;)

    for subdir in pathname:
        # Special case for current directory (.) (ignore it)
        if subdir == &#34;.&#34;:
            continue

        # Special case for (..) (go to parent)
        elif subdir == &#34;..&#34;:
            # Check if we&#39;re at the root
            if not current_dir.parent:
                current_dir = self.files
            else:
                current_dir = current_dir.parent

        else:
            current_dir = current_dir.find(subdir)
            if not current_dir:
                return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    # This only runs when we successfully found
    return SysCallStatus(success=True, data=current_dir)</code></pre>
</details>
</dd>
<dt id="client.blackhat.fs.StandardFS.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>All the functions required to setup a new filesystem</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init(self) -&gt; None:
    &#34;&#34;&#34;
    All the functions required to setup a new filesystem

    Returns:
        None
    &#34;&#34;&#34;
    # Setup the directory structure in the file system (Unix FHS)
    for dir in [&#34;bin&#34;, &#34;etc&#34;, &#34;home&#34;, &#34;lib&#34;, &#34;root&#34;, &#34;tmp&#34;, &#34;usr&#34;, &#34;var&#34;]:
        directory = Directory(dir, self.files, 0, 0)
        # Special case for /tmp (read and write by everyone)
        if dir == &#34;tmp&#34;:
            directory.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;],
                                     &#34;execute&#34;: []}
        else:
            # TODO: Change this to be more accurate
            # (rwx rw- r--)
            directory.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;, &#34;group&#34;],
                                     &#34;execute&#34;: [&#34;owner&#34;]}

        self.files.add_file(directory)

    # TODO: Replace all these with `mkdir -p` commands
    # NOTE: FS doesn&#39;t exist at this point so running commands might not be possible (since some commands need fs)
    # Individually setup each directory in the root
    self.setup_bin()
    self.setup_etc()
    # self.setup_home()
    # self.setup_lib()
    self.setup_root()
    # self.setup_tmp()
    self.setup_usr()
    self.setup_var()</code></pre>
</details>
</dd>
<dt id="client.blackhat.fs.StandardFS.setup_bin"><code class="name flex">
<span>def <span class="ident">setup_bin</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Read all the files in the <code><a title="client.blackhat.bin" href="bin/index.html">client.blackhat.bin</a></code> directory and create a virtual file in the fs.
All these files represent binaries in the system</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_bin(self) -&gt; None:
    &#34;&#34;&#34;
    Read all the files in the `client.blackhat.bin` directory and create a virtual file in the fs.
    All these files represent binaries in the system

    Returns:
        None
    &#34;&#34;&#34;
    bin_dir: Directory = self.files.find(&#34;bin&#34;)

    for file in os.listdir(&#34;./blackhat/bin&#34;):
        # Ignore the __init__.py and __pycache__ because those aren&#39;t bins (auto generated)
        if file not in [&#34;__init__.py&#34;, &#34;__pycache__&#34;, &#34;installable&#34;]:
            current_file = File(file.replace(&#34;.py&#34;, &#34;&#34;), &#34;[BINARY DATA]&#34;, bin_dir, 0, 0)
            with open(f&#34;./blackhat/bin/{file}&#34;, &#34;r&#34;) as f:
                current_file.size = sys.getsizeof(f.read()) / 32
                current_file.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;],
                                            &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}

            bin_dir.add_file(current_file)</code></pre>
</details>
</dd>
<dt id="client.blackhat.fs.StandardFS.setup_etc"><code class="name flex">
<span>def <span class="ident">setup_etc</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Sets up:</p>
<ul>
<li>/etc/passwd - Contains the username, hashed password, and UID of all the users in the system</li>
<li>/etc/groups - Contains the list of groups in the systems (name, GID)</li>
<li>/etc/hostname - The hostname of the given <code>Computer</code></li>
<li>/etc/skel -
A "skeleton" needed to create a users home folder (located in /home/<USERNAME>)</li>
<li>/etc/sudoers - The file that contains all of the sudo permissions</li>
<li>/etc/apt/sources.list - Contains urls of apt repo servers</li>
</ul>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_etc(self) -&gt; None:
    &#34;&#34;&#34;
    Sets up:
    &lt;ul&gt;
        &lt;li&gt;/etc/passwd - Contains the username, hashed password, and UID of all the users in the system&lt;/li&gt;
        &lt;li&gt;/etc/groups - Contains the list of groups in the systems (name, GID)&lt;/li&gt;
        &lt;li&gt;/etc/hostname - The hostname of the given `Computer`&lt;/li&gt;
        &lt;li&gt;/etc/skel -  A &#34;skeleton&#34; needed to create a users home folder (located in /home/&lt;USERNAME&gt;)&lt;/li&gt;
        &lt;li&gt;/etc/sudoers - The file that contains all of the sudo permissions&lt;/li&gt;
        &lt;li&gt;/etc/apt/sources.list - Contains urls of apt repo servers&lt;/li&gt;
    &lt;/ul&gt;

    Returns:
        None
    &#34;&#34;&#34;
    # TODO: Separate /etc/passwd and /etc/shadow
    etc_dir: Directory = self.files.find(&#34;etc&#34;)
    # Create the /etc/passwd file
    # The passwd file should have roots creds (bc root is created before the file)
    # passwd_file: File = File(&#34;passwd&#34;, f&#34;root:{self.computer.users[0].password}\n&#34;, etc_dir, 0, 0)
    passwd_file: File = File(&#34;passwd&#34;, f&#34;&#34;, etc_dir, 0, 0)
    etc_dir.add_file(passwd_file)

    # Create the /etc/groups file
    groups_file: File = File(&#34;group&#34;, f&#34;root:x:0&#34;, etc_dir, 0, 0)
    etc_dir.add_file(groups_file)

    # /etc/skel (home dir template)
    skel_dir: Directory = Directory(&#34;skel&#34;, etc_dir, 0, 0)

    for dir in [&#34;Desktop&#34;, &#34;Documents&#34;, &#34;Downloads&#34;, &#34;Music&#34;, &#34;Pictures&#34;, &#34;public&#34;, &#34;Templates&#34;, &#34;Videos&#34;]:
        current_dir = Directory(dir, skel_dir, 0, 0)
        current_dir.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;],
                                   &#34;execute&#34;: []}
        skel_dir.add_file(current_dir)

    # /etc/skel/.shellrc (.bashrc/.zshrc equivalent)
    skel_dir.add_file(File(&#34;.shellrc&#34;, &#34;&#34;, skel_dir, 0, 0))

    etc_dir.add_file(skel_dir)

    # /etc/hostname (holds system hostname)
    # Stupid windows style default hostnames (for fun, might change later)
    new_hostname = f&#34;DESKTOP-{&#39;&#39;.join([choice(ascii_uppercase + digits) for _ in range(7)])}&#34;
    etc_dir.add_file(File(&#34;hostname&#34;, new_hostname, etc_dir, 0, 0))

    # /etc/sudoers (holds sudo permissions)
    # Sudoers has permissions r--r-----
    sudoers_file: File = File(&#34;sudoers&#34;, &#34;root ALL=(ALL) ALL\n&#34;, etc_dir, 0, 0)
    sudoers_file.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;], &#34;write&#34;: [], &#34;execute&#34;: []}
    etc_dir.add_file(sudoers_file)

    # /etc/apt/sources.list
    apt_dir: Directory = Directory(&#34;apt&#34;, etc_dir, 0, 0)
    etc_dir.add_file(apt_dir)

    sources_file: File = File(&#34;sources.list&#34;, &#34;&#34;, apt_dir, 0, 0)
    apt_dir.add_file(sources_file)</code></pre>
</details>
</dd>
<dt id="client.blackhat.fs.StandardFS.setup_root"><code class="name flex">
<span>def <span class="ident">setup_root</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Since the root user is different from a "standard" user, root's home folder needs to be setup separately.
Otherwise, the format of root's home folder is the same as any other user</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_root(self) -&gt; None:
    &#34;&#34;&#34;
    Since the root user is different from a &#34;standard&#34; user, root&#39;s home folder needs to be setup separately.
    Otherwise, the format of root&#39;s home folder is the same as any other user

    Returns:
        None
    &#34;&#34;&#34;
    # Create /root/.shellrc
    root_dir: Directory = self.files.find(&#34;root&#34;)

    root_shellrc: File = File(&#34;.shellrc&#34;, &#34;export HOME=/root&#34;, root_dir, 0, 0)
    root_dir.add_file(root_shellrc)</code></pre>
</details>
</dd>
<dt id="client.blackhat.fs.StandardFS.setup_usr"><code class="name flex">
<span>def <span class="ident">setup_usr</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Sets up:</p>
<ul>
<li>/usr/share/man - Contains all the "man pages", or instruction manuals, for all the system binaries</li>
<li>/usr/bin - "Aftermarket" installed packages (apt) </li>
</ul>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_usr(self) -&gt; None:
    &#34;&#34;&#34;
    Sets up:
    &lt;ul&gt;
        &lt;li&gt;/usr/share/man - Contains all the &#34;man pages&#34;, or instruction manuals, for all the system binaries&lt;/li&gt;
        &lt;li&gt;/usr/bin - &#34;Aftermarket&#34; installed packages (apt) &lt;/li&gt;
    &lt;/ul&gt;

    Returns:
        None
    &#34;&#34;&#34;
    # Setup /usr/share
    usr_dir: Directory = self.files.find(&#34;usr&#34;)

    share_dir: Directory = Directory(&#34;share&#34;, usr_dir, 0, 0)
    usr_dir.add_file(share_dir)

    # /usr/share/man (stores man pages from __DOC__)
    man_dir: Directory = Directory(&#34;man&#34;, share_dir, 0, 0)
    share_dir.add_file(man_dir)

    # Loop through all the files in /bin and check if they have a __DOC__.
    for binary in self.files.find(&#34;bin&#34;).files.keys():
        try:
            module = importlib.import_module(f&#34;blackhat.bin.{binary}&#34;)
            current_manpage = File(binary, module.__DOC__, man_dir, 0, 0)
            man_dir.add_file(current_manpage)
        except AttributeError as e:
            pass

    bin_dir: Directory = Directory(&#34;bin&#34;, usr_dir, 0, 0)
    usr_dir.add_file(bin_dir)</code></pre>
</details>
</dd>
<dt id="client.blackhat.fs.StandardFS.setup_var"><code class="name flex">
<span>def <span class="ident">setup_var</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Sets up:</p>
<ul>
<li>/var/log - Contains various log files</li>
<li>/var/log/syslog - Logs various information about the given <code>Computer</code></li>
<li>/var/log/auth.log - Logs information about authentication attempts</li>
<li>/var/lib/dpkg/status - The list of installed packages by apt</li>
<li>/var/www/html - Default location for web content served by web servers</li>
</ul>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_var(self) -&gt; None:
    &#34;&#34;&#34;
    Sets up:
    &lt;ul&gt;
        &lt;li&gt;/var/log - Contains various log files&lt;/li&gt;
        &lt;li&gt;/var/log/syslog - Logs various information about the given `Computer`&lt;/li&gt;
        &lt;li&gt;/var/log/auth.log - Logs information about authentication attempts&lt;/li&gt;
        &lt;li&gt;/var/lib/dpkg/status - The list of installed packages by apt&lt;/li&gt;
        &lt;li&gt;/var/www/html - Default location for web content served by web servers&lt;/li&gt;
    &lt;/ul&gt;

    Returns:
        None
    &#34;&#34;&#34;
    # This should exist at runtime
    var_dir: Directory = self.files.find(&#34;var&#34;)

    # Create /var/log
    log_dir: Directory = Directory(&#34;log&#34;, var_dir, 0, 0)
    # mv log -&gt; var
    var_dir.add_file(log_dir)

    # Create the `syslog` in /var/log
    log_dir.add_file(File(&#34;syslog&#34;, &#34;&#34;, log_dir, 0, 0))

    # Create /var/lib/dpkg/status
    lib_dir: Directory = Directory(&#34;lib&#34;, var_dir, 0, 0)
    var_dir.add_file(lib_dir)

    dpkg_dir: Directory = Directory(&#34;dpkg&#34;, lib_dir, 0, 0)
    lib_dir.add_file(dpkg_dir)

    status_file: File = File(&#34;status&#34;, &#34;&#34;, dpkg_dir, 0, 0)
    dpkg_dir.add_file(status_file)

    # Create /var/www/html
    www_dir: Directory = Directory(&#34;www&#34;, var_dir, 0, 0)
    var_dir.add_file(www_dir)

    html_dir: Directory = Directory(&#34;html&#34;, www_dir, 0, 0)
    www_dir.add_file(html_dir)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="client.blackhat" href="index.html">client.blackhat</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="client.blackhat.fs.Directory" href="#client.blackhat.fs.Directory">Directory</a></code></h4>
<ul class="">
<li><code><a title="client.blackhat.fs.Directory.add_file" href="#client.blackhat.fs.Directory.add_file">add_file</a></code></li>
<li><code><a title="client.blackhat.fs.Directory.calculate_size" href="#client.blackhat.fs.Directory.calculate_size">calculate_size</a></code></li>
<li><code><a title="client.blackhat.fs.Directory.find" href="#client.blackhat.fs.Directory.find">find</a></code></li>
<li><code><a title="client.blackhat.fs.Directory.update_size" href="#client.blackhat.fs.Directory.update_size">update_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="client.blackhat.fs.FSBaseObject" href="#client.blackhat.fs.FSBaseObject">FSBaseObject</a></code></h4>
<ul class="two-column">
<li><code><a title="client.blackhat.fs.FSBaseObject.atime" href="#client.blackhat.fs.FSBaseObject.atime">atime</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.change_owner" href="#client.blackhat.fs.FSBaseObject.change_owner">change_owner</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.check_owner" href="#client.blackhat.fs.FSBaseObject.check_owner">check_owner</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.check_perm" href="#client.blackhat.fs.FSBaseObject.check_perm">check_perm</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.ctime" href="#client.blackhat.fs.FSBaseObject.ctime">ctime</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.delete" href="#client.blackhat.fs.FSBaseObject.delete">delete</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.is_directory" href="#client.blackhat.fs.FSBaseObject.is_directory">is_directory</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.is_file" href="#client.blackhat.fs.FSBaseObject.is_file">is_file</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.mtime" href="#client.blackhat.fs.FSBaseObject.mtime">mtime</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.permissions" href="#client.blackhat.fs.FSBaseObject.permissions">permissions</a></code></li>
<li><code><a title="client.blackhat.fs.FSBaseObject.pwd" href="#client.blackhat.fs.FSBaseObject.pwd">pwd</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="client.blackhat.fs.File" href="#client.blackhat.fs.File">File</a></code></h4>
<ul class="">
<li><code><a title="client.blackhat.fs.File.append" href="#client.blackhat.fs.File.append">append</a></code></li>
<li><code><a title="client.blackhat.fs.File.read" href="#client.blackhat.fs.File.read">read</a></code></li>
<li><code><a title="client.blackhat.fs.File.update_size" href="#client.blackhat.fs.File.update_size">update_size</a></code></li>
<li><code><a title="client.blackhat.fs.File.write" href="#client.blackhat.fs.File.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="client.blackhat.fs.StandardFS" href="#client.blackhat.fs.StandardFS">StandardFS</a></code></h4>
<ul class="two-column">
<li><code><a title="client.blackhat.fs.StandardFS.find" href="#client.blackhat.fs.StandardFS.find">find</a></code></li>
<li><code><a title="client.blackhat.fs.StandardFS.init" href="#client.blackhat.fs.StandardFS.init">init</a></code></li>
<li><code><a title="client.blackhat.fs.StandardFS.setup_bin" href="#client.blackhat.fs.StandardFS.setup_bin">setup_bin</a></code></li>
<li><code><a title="client.blackhat.fs.StandardFS.setup_etc" href="#client.blackhat.fs.StandardFS.setup_etc">setup_etc</a></code></li>
<li><code><a title="client.blackhat.fs.StandardFS.setup_root" href="#client.blackhat.fs.StandardFS.setup_root">setup_root</a></code></li>
<li><code><a title="client.blackhat.fs.StandardFS.setup_usr" href="#client.blackhat.fs.StandardFS.setup_usr">setup_usr</a></code></li>
<li><code><a title="client.blackhat.fs.StandardFS.setup_var" href="#client.blackhat.fs.StandardFS.setup_var">setup_var</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>