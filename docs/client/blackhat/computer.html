<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>client.blackhat.computer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>client.blackhat.computer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import importlib
import os
import pickle
import sqlite3
from datetime import datetime
from hashlib import md5
from os import system as real_syscall
from platform import system
from random import choice
from secrets import token_hex
from time import time, sleep
from typing import Optional, Dict, Union, List, Literal

from .fs import Directory, File, StandardFS, FSBaseObject, copy
from .helpers import Result, ResultMessages, AccessMode, timeval, stat_struct, RebootMode
from .lib import unistd, stdlib, dirent, fcntl, stdio, pwd, ifaddrs, netdb
from .lib.arpa import inet
from .lib.sys import time, stat, socket
from .lib.sys.socket import Socket
from .services.pingserver import PingServer
from .services.service import Service
from .session import Session
from .user import User, Group


class Computer:
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        The class object representing a basic linux computer. This class is the base for all nodes on a network
        &#34;&#34;&#34;
        self.connection = sqlite3.connect(&#34;blackhat.db&#34;)
        self.database = self.connection.cursor()
        self.boot_time = datetime.now()
        self.parent: Optional[Computer, Router, ISPRouter] = None  # Router
        self.hostname: Optional[str] = None
        self.users: Dict[int, User] = {}
        self.groups: Dict[int, Group] = {}
        self.sessions: List[Session] = []
        self.lan = None
        self.id = token_hex(8)
        self.shell = None
        # Root user needs to be created before the FS is initialized (FS needs root to have a password to create /etc/passwd)
        self.init()

        # self.create_root_user()

        self.fs: StandardFS = StandardFS(self)
        self.services: dict[int, Service] = {0: PingServer(self)}
        self.post_fs_init()

    ##################
    # Init functions #
    ##################

    def init(self) -&gt; None:
        &#34;&#34;&#34;
        Functions ran when a computer is booted (pre file-system setup/pre root user creation)

        Returns:
            None
        &#34;&#34;&#34;
        self.boot_time = datetime.now()
        # Try to setup the user, group, and group membership tables
        init_tables_file = open(&#34;blackhat/database/init_tables.sql&#34;)
        init_tables = init_tables_file.read()
        self.database.executescript(init_tables)

        # Check if the computer we&#39;re initializing already exists in the database (we&#39;re loading an existing save)
        result = self.database.execute(&#34;SELECT * FROM computer WHERE id=?&#34;, (self.id,)).fetchall()

        if len(result) == 0:
            # We&#39;re starting a new save, lets save a copy of this computers id in the database, along with create the root user
            self.database.execute(&#34;INSERT INTO computer VALUES (?)&#34;, (self.id,))
            self.create_root_user()
            self.connection.commit()

        init_tables_file.close()

    def post_fs_init(self) -&gt; None:
        &#34;&#34;&#34;
        Function ran after the file system and root user were initialized

        Returns:
            None
        &#34;&#34;&#34;
        self.sync_hostname()
        self.sync_user_and_group_files()

    def update_libs(self):
        &#34;&#34;&#34;
        The system libraries need access to the given `Computer` object, so before a command runs, we pass a reference
        to the current `Computer` object, so the binaries don&#39;t need `computer` in their arguments (prevents cheating in
        binaries). If commands had access to a `Computer` object, they could just read files without permission, access
        user passwords that they shouldn&#39;t, change current UID when they shouldn&#39;t, etc.

        Returns:
            None
        &#34;&#34;&#34;
        libs = [unistd, time, stat, stdlib, dirent, fcntl, inet, stdio, pwd, socket, ifaddrs, netdb]

        for lib in libs:
            lib.update(self)

    ##############
    # Sync files #
    ##############

    def sync_hostname(self) -&gt; None:
        &#34;&#34;&#34;
        Reads /etc/hostname and sets the system hostname accordingly
        If /etc/hostname doesn&#39;t exist, the hostname is set to &#34;localhost&#34;

        Returns:
            None
        &#34;&#34;&#34;
        # Note: We don&#39;t need to use the sethostname syscall because this is only if we updated the /etc/hostname file
        etc_dir: Directory = self.fs.files.find(&#34;etc&#34;)

        if not etc_dir:
            self.hostname = &#34;localhost&#34;

        else:
            hostname_file: File = etc_dir.find(&#34;hostname&#34;)

            if not hostname_file:
                self.hostname = &#34;localhost&#34;
            else:
                self.hostname = hostname_file.content.split(&#34;\n&#34;)[0]

    def sync_user_and_group_files(self) -&gt; Result:
        &#34;&#34;&#34;
        Makes sure that:
        /etc/passwd matches our internal user map
        /etc/shadow matches our internal user map
        /etc/group matches our internal group map

        Returns:
            None
        &#34;&#34;&#34;
        etc_dir: Directory = self.fs.files.find(&#34;etc&#34;)

        if not etc_dir:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        passwd_file: File = etc_dir.find(&#34;passwd&#34;)
        shadow_file: File = etc_dir.find(&#34;shadow&#34;)
        group_file: File = etc_dir.find(&#34;group&#34;)

        # TODO: Allow modification of home directory from here
        # passwd format: USERNAME:MD5_PASSWORD OR &#34;x&#34;:UID:PRIMARY_GID
        # shadow format: USERNAME:MD5_PASSWORD
        # group format: GROUP_NAME:x:GID:GROUP_USERS

        passwd_content = &#34;&#34;
        shadow_content = &#34;&#34;
        group_content = &#34;&#34;

        for user in self.get_all_users().data:
            # Find the &#34;primary&#34; group
            primary_group = self.get_user_primary_group(user.uid)
            if primary_group.success:
                if len(primary_group.data) &gt; 0:
                    primary_group = primary_group.data[0]
                else:
                    primary_group = &#34;?&#34;
            else:
                primary_group = &#34;?&#34;

            passwd_content += f&#34;{user.username}:x:{user.uid}:{primary_group}\n&#34;
            shadow_content += f&#34;{user.username}:{user.password}\n&#34;

        for group in self.get_all_groups().data:
            uids = self.get_users_in_group(group.gid).data
            usernames = &#34;&#34;
            for uid in uids:
                user_lookup = self.get_user(uid=uid[0])
                usernames += (&#34;?&#34; if not user_lookup.success else user_lookup.data.username) + &#34;,&#34;

            usernames = usernames[:-1]

            group_content += f&#34;{group.name}:x:{group.gid}:{usernames}\n&#34;
            # print(group_content, end=&#34;&#34;)

        if not passwd_file:
            # Create the /etc/passwd
            etc_dir.add_file(File(&#34;passwd&#34;, passwd_content, etc_dir, 0, 0))
        else:
            passwd_file.content = passwd_content

        if not shadow_file:
            # Create the /etc/shadow file and change its perms (rw-------)
            shadow_file = File(&#34;shadow&#34;, shadow_content, etc_dir, 0, 0)
            shadow_file.permissions = {&#34;read&#34;: [&#34;owner&#34;], &#34;write&#34;: [&#34;owner&#34;], &#34;execute&#34;: []}
            etc_dir.add_file(shadow_file)
        else:
            shadow_file.content = shadow_content

        if not group_file:
            # Create the /etc/group
            etc_dir.add_file(File(&#34;group&#34;, group_content, etc_dir, 0, 0))
        else:
            group_file.content = group_content

        return Result(success=True)

    def run_command(self, command: str, args: Union[str, List[str], None], pipe: bool) -&gt; Result:
        &#34;&#34;&#34;
        Runs a system binary or an external binary
        Args:
            command (str): The command or binary to run
            args (list): A list of arguments passed to the command or binary
            pipe (bool): If a pipe was used (used for routing input/output)
        Returns:
            SysCallStatus: A `SysCallStatus` object that contains a success status and some response data (changed on a case-by-case basis)
        &#34;&#34;&#34;
        # The way that the path works is that if there are 2 binaries with the same name in 2 different directories,
        # The one that matches first in the path gets run
        # For example, if ls is in /etc/ and in /bin/ and the path is PATH=/home:/bin:/etc, the one in bin will run
        # For example, if ls is in /etc/ and in /bin/ and the path is PATH=/home:/etc:/bin, the one in etc will run
        self.update_libs()
        try:
            bin_dirs_text = self.sessions[-1].env.get(&#34;PATH&#34;).split(&#34;:&#34;)
            bin_dirs = []

            for dir in bin_dirs_text:
                find_dir = self.fs.find(dir)
                if find_dir.success:
                    bin_dirs.append(find_dir.data)
        except AttributeError:
            find_bin = self.fs.find(&#34;/bin&#34;)
            if find_bin.success:
                bin_dirs = [find_bin.data]
            else:
                bin_dirs = []

        if len(bin_dirs) == 0:
            print(f&#34;{command}: command not found&#34;)
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        exists = False

        for dir in bin_dirs:
            if command in list(dir.files.keys()):
                to_run = True
                break
        else:
            print(f&#34;{command}: command not found&#34;)
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        try:
            module = importlib.import_module(f&#34;blackhat.bin.{command}&#34;)

        except ImportError:
            try:
                module = importlib.import_module(f&#34;blackhat.bin.installable.{command}&#34;)
            except ImportError:
                print(f&#34;There was an error when running command: {command}&#34;)
                return Result(success=False, message=ResultMessages.GENERIC)

        try:
            response = module.main(args, pipe)

        except Exception as e:
            import traceback
            traceback.print_exc()
            print(f&#34;{command}: Segmentation violation&#34;)
            return Result(success=False, message=ResultMessages.GENERIC)

        self.sessions[-1].effective_uid = self.sessions[-1].real_uid
        if os.getenv(&#34;DEBUGMODE&#34;) == &#34;false&#34;:
            self.save()

        return response

    #################
    # User + Groups #
    #################

    def add_user(self, username: str, password: str, uid: Optional[int] = None, plaintext=True) -&gt; Result:
        &#34;&#34;&#34;
        Add a new user to the system.
        This function also generates the UID for the new user (unless manually specified)

        Args:
            username (str): The username for the new user
            password (str): The plaintext password for the new user
            uid (int, optional): The UID of the new user
                        plaintext (bool): If the given `new_password` is plain text or an MD5 hash

        Returns:
            Result: A `Result` instance with the `success` flag set accordingly. The `data` flag contains the new users UID if successful.
        &#34;&#34;&#34;
        if self.get_user(username=username).success:
            return Result(success=False, message=ResultMessages.ALREADY_EXISTS)

        # new_user = User(username)
        # new_user.set_password(password)

        # Manually specific UID
        if uid:
            # Check if a user with the given UID already exists
            if self.get_user(uid=uid).success:
                return Result(success=False, message=ResultMessages.ALREADY_EXISTS)
            else:
                next_uid = uid
        # Auto-generate the UID (depending on the situation)
        else:
            # We&#39;re creating our root user, there isn&#39;t going to be a previous UID
            users = self.get_all_users().data
            if len(users) == 0:
                next_uid = 0
            else:
                # Get the UID from the previously created user
                last_uid = users[-1].uid
                if last_uid == 0:
                    next_uid = 1000
                else:
                    next_uid = last_uid + 1
                    user_with_next_uid = self.get_user(uid=next_uid)

                    while user_with_next_uid.success:
                        next_uid += 1
                        user_with_next_uid = self.get_user(uid=next_uid)

        # Hash the password before saving to the database
        hashed_password = md5(password.encode()).hexdigest() if plaintext else password

        # Create the new user
        self.database.execute(&#34;INSERT INTO blackhat_user (uid, username, password, computer_id) VALUES (?, ?, ?, ?)&#34;,
                              (next_uid, username, hashed_password, self.id))
        self.connection.commit()

        return Result(success=True, data=next_uid)

    def delete_user(self, username: str) -&gt; Result:
        &#34;&#34;&#34;
        Deletes a user from the system (by username)

        Args:
            username (str): The username of the user to delete

        Returns:
            Result: A `Result` instance with the `success` flag set accordingly.
        &#34;&#34;&#34;
        if self.get_user(username=username).success:
            self.database.execute(&#34;DELETE FROM blackhat_user WHERE computer_id=? and username=?&#34;, (self.id, username))
            self.connection.commit()
            return Result(success=True)

        return Result(success=False, message=ResultMessages.NOT_FOUND)

    def change_user_password(self, uid: int, new_password: str, plaintext=True) -&gt; Result:
        &#34;&#34;&#34;
        Change the password of the user by uid

        Args:
            uid (int): The UID of the `User` to change the password of
            new_password (str): The MD5 hash of the password
            plaintext (bool): If the given `new_password` is plain text or an MD5 hash

        Returns:
            Result: A `Result` with the `success` flag set accordingly.
        &#34;&#34;&#34;
        # Double check that the user with the given UID exists
        lookup_user = self.get_user(uid=uid)
        if not lookup_user.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        # Hash the plain text password
        password_hash = md5(new_password.encode()).hexdigest() if plaintext else new_password

        # Update the password in the database
        result = self.database.execute(&#34;UPDATE blackhat_user SET password=? WHERE uid=? AND computer_id=?&#34;,
                                       (password_hash, uid, self.id))
        self.connection.commit()
        return Result(success=True)

    def change_user_uid(self, uid: int, new_uid: int) -&gt; Result:
        &#34;&#34;&#34;
        Change the uid of the user by uid

        Args:
            uid (int): The UID of the `User` to change the uid of
            new_uid (int): The new uid of the given user

        Returns:
            Result: A `Result` with the `success` flag set accordingly.
        &#34;&#34;&#34;
        # Double check that the user with the given UID exists
        lookup_user = self.get_user(uid=uid)
        if not lookup_user.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        # Make sure that no other user has the given `new_uid`
        lookup_user = self.get_user(uid=new_uid)
        if lookup_user.success:
            return Result(success=False, message=ResultMessages.ALREADY_EXISTS)

        # Update the uid in the database
        result = self.database.execute(&#34;UPDATE blackhat_user SET uid=? WHERE uid=? AND computer_id=?&#34;,
                                       (new_uid, uid, self.id))
        self.connection.commit()

        # We need to update the UID of all sessions that this user has
        for session in self.sessions:
            if session.real_uid == uid:
                session.real_uid = new_uid

            if session.effective_uid == uid:
                session.effective_uid = new_uid

        # We also need to update the UID in the group membership records
        self.database.execute(&#34;UPDATE group_membership SET user_uid=? WHERE user_uid=? AND computer_id=?&#34;,
                              (new_uid, uid, self.id))

        return Result(success=True)

    def add_group(self, name: str, gid: Optional[int] = None) -&gt; Result:
        &#34;&#34;&#34;
        Add a new group to the system.
        This function also generates the GID for the new group (unless manually specified)

        Args:
            name (str): The name for the new group
            gid (int, optional): The GID of the new user

        Returns:
            Result: A `Result` instance with the `success` flag set accordingly. The `data` flag contains the GID if successful.
        &#34;&#34;&#34;
        if self.get_group(name=name).success:
            return Result(success=False, message=ResultMessages.ALREADY_EXISTS)

        if gid:
            # Check if a group with the given GID already exists
            if self.get_group(gid=gid, name=name).success:
                return Result(success=False, message=ResultMessages.ALREADY_EXISTS)
            else:
                next_gid = gid
        else:
            # Auto-generate the GID (depending on the situation)
            groups = self.get_all_groups().data
            if len(groups) == 0:
                next_gid = 0
            else:
                # Get the GID from the previously created group
                last_gid = groups[-1].gid
                if last_gid == 0:
                    next_gid = 1000
                else:
                    next_gid = last_gid + 1

        # Create the new group and commit
        self.database.execute(&#34;INSERT INTO blackhat_group (gid, name, computer_id) VALUES (?, ?, ?)&#34;,
                              (next_gid, name, self.id))
        self.connection.commit()

        return Result(success=True, data=next_gid)

    def delete_group(self, name: str) -&gt; Result:
        &#34;&#34;&#34;
        Deletes a group from the system (by name)

        Args:
            name (str): The name of the group to delete

        Returns:
            Result: A `Result` instance with the `success` flag set accordingly.
        &#34;&#34;&#34;
        if self.get_group(name=name).success:
            self.database.execute(&#34;DELETE FROM blackhat_group WHERE computer_id=? and name=?&#34;, (self.id, name))
            self.connection.commit()
            return Result(success=True)

        return Result(success=False, message=ResultMessages.NOT_FOUND)

    def add_user_to_group(self, uid: int, gid: int,
                          membership_type: Literal[&#34;primary&#34;, &#34;secondary&#34;] = &#34;secondary&#34;) -&gt; Result:
        &#34;&#34;&#34;
        Add a user to a group (by uid and gid)

        Args:
            uid (int): The UID of the user
            gid (int): The GID of the group to add the user to
            membership_type (str): The type of group relationship (primary, secondary)

        Returns:
            Result: A `Result` object with the `success` flag set accordingly
        &#34;&#34;&#34;
        # Confirm that both user and group exists
        if self.get_user(uid=uid).success and self.get_group(gid=gid).success:
            self.database.execute(
                &#34;INSERT INTO group_membership (computer_id, user_uid, group_gid, membership_type) VALUES (?, ?, ?, ?)&#34;,
                (self.id, uid, gid, membership_type))
            self.connection.commit()
            return Result(success=True)
        else:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

    def get_user_groups(self, uid: int) -&gt; Result:
        &#34;&#34;&#34;
        Get the list of `Group` GID&#39;s that the `User` belongs to (by UID)

        Args:
            uid (int): The UID of the user to lookup

        Returns:
            Result: A `Result` with the `data` flag containing a list of GIDs
        &#34;&#34;&#34;
        # Double check if the user exists
        if not self.get_user(uid=uid).success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)
        else:
            # Ask the database for the GIDs
            result = self.database.execute(&#34;SELECT group_gid FROM group_membership WHERE computer_id=? and user_uid=?;&#34;,
                                           (self.id, uid)).fetchall()
            return Result(success=True, data=[x[0] for x in result])

    def get_user_primary_group(self, uid: int) -&gt; Result:
        &#34;&#34;&#34;
        Get the `Group` GID&#39;s that is the `User`s primary `Group` (by UID)

        Args:
            uid (int): The UID of the user to lookup

        Returns:
            Result: A `Result` with the `data` flag containing a list of GIDs
        &#34;&#34;&#34;
        # Double check if the user exists
        if not self.get_user(uid=uid).success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)
        else:
            # Ask the database for the GIDs
            result = self.database.execute(
                &#34;SELECT group_gid FROM group_membership WHERE computer_id=? and user_uid=? and membership_type=?;&#34;,
                (self.id, uid, &#34;primary&#34;)).fetchone()
            return Result(success=True, data=[x for x in result])

    def get_users_in_group(self, gid: int) -&gt; Result:
        &#34;&#34;&#34;
        Get a list of user UIDs that are part of the given groups GID

        Args:
            gid (int): The GID of the group to search

        Returns:
            Result: A `Result` with the `data` flag containing a list of UIDs
        &#34;&#34;&#34;
        # Double check if the group exists
        if not self.get_group(gid=gid).success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)
        # Ask the database for the UIDs
        result = self.database.execute(
            &#34;SELECT uid FROM blackhat_user WHERE computer_id=? AND uid in (SELECT user_uid FROM group_membership WHERE computer_id=? AND group_gid=?)&#34;,
            (self.id, self.id, gid)).fetchall()

        return Result(success=True, data=[x for x in result])

    def remove_user_from_group(self, uid: int, gid: int) -&gt; Result:
        &#34;&#34;&#34;
        Remove a user from a group (by uid and gid)

        Args:
            uid (int): The UID of the user
            gid (int): The GID of the group to remove the user from

        Returns:
            Result: A `Result` object with the `success` flag set accordingly
        &#34;&#34;&#34;
        # Confirm that both user and group exists
        if self.get_user(uid=uid).success and self.get_group(gid=gid).success:
            self.database.execute(&#34;DELETE FROM group_membership WHERE computer_id=? AND user_uid=? AND group_gid=?&#34;,
                                  (self.id, uid, gid))
            self.connection.commit()
            return Result(success=True)
        else:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

    def get_user(self, uid: Optional[int] = None, username: Optional[str] = None) -&gt; Result:
        &#34;&#34;&#34;
        Find a user in the database by UID or username
        Args:
            uid (int, optional): The UID of the user to find
            username (str, optional): The username of the user to find

        Returns:
            Result: A `Result` with the `success` flag set accordingly. The `data` flag contains the user dict if found
        &#34;&#34;&#34;
        if uid is None and username is None:
            return Result(success=False, message=ResultMessages.NOT_FOUND)
        else:
            result = self.database.execute(&#34;SELECT * FROM blackhat_user WHERE (uid=? OR username=?) AND computer_id=?&#34;,
                                           (uid, username, self.id)).fetchone()
            if not result:
                return Result(success=False, message=ResultMessages.NOT_FOUND)

            return Result(success=True,
                          data=User(uid=result[1], username=result[2], password=result[3], full_name=result[4],
                                    room_number=result[5],
                                    work_phone=result[6], home_phone=result[7], other=result[8]))

    def get_group(self, gid: Optional[int] = None, name: Optional[str] = None) -&gt; Result:
        &#34;&#34;&#34;
        Find a group in the database by GID or name or both
        Args:
            gid (int, optional): The GID of the group to find
            name (str, optional): The name of the group to find

        Returns:
            Result: A `Result` with the `success` flag set accordingly. The `data` flag contains the group dict if found
        &#34;&#34;&#34;
        if gid is None and name is None:
            return Result(success=False, message=ResultMessages.NOT_FOUND)
        # We&#39;re looking by name AND gid
        elif gid is not None and name is not None:
            result = self.database.execute(&#34;SELECT * FROM blackhat_group WHERE (gid=? AND name=?) AND computer_id=?&#34;,
                                           (gid, name, self.id)).fetchone()
        else:
            result = self.database.execute(&#34;SELECT * FROM blackhat_group WHERE (gid=? OR name=?) AND computer_id=?&#34;,
                                           (gid, name, self.id)).fetchone()

        if not result:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        return Result(success=True, data=Group(gid=result[1], name=result[2]))

    def get_all_users(self) -&gt; Result:
        &#34;&#34;&#34;
        Get all users that exist in the given system in the given format:

        Returns:
            Result: A `Result` with the `data` flag containing the array of `User`s
        &#34;&#34;&#34;
        all_users = self.database.execute(&#34;SELECT * FROM blackhat_user WHERE computer_id=?&#34;,
                                          (self.id,)).fetchall()

        clean_users = []

        for user in all_users:
            clean_users.append(
                User(uid=user[1], username=user[2], password=user[3], full_name=user[4], room_number=user[5],
                     work_phone=user[6], home_phone=user[7], other=user[8]))
        return Result(success=True, data=clean_users)

    def get_all_groups(self) -&gt; Result:
        &#34;&#34;&#34;
        Get all groups that exist in the given system in the given format:

        Returns:
            Result: A `Result` with the `data` flag containing the array of `Group`s
        &#34;&#34;&#34;
        all_groups = self.database.execute(&#34;SELECT * FROM blackhat_group WHERE computer_id=?&#34;,
                                           (self.id,)).fetchall()

        clean_groups = []

        for group in all_groups:
            clean_groups.append(Group(gid=group[1], name=group[2]))
        return Result(success=True, data=clean_groups)

    def create_root_user(self) -&gt; None:
        &#34;&#34;&#34;
        Since the root user is different from &#34;standard&#34; users, and it must exist in any given system, it is manually
        created when the `Computer` is first initialized.

        Returns:
            None
        &#34;&#34;&#34;
        # Add the root user with a random password
        # self.add_user(&#34;root&#34;, &#39;&#39;.join([choice(ascii_uppercase + digits) for _ in range(16)]))
        self.add_user(&#34;root&#34;, &#34;password&#34;, uid=0)
        # Create the root group
        self.add_group(&#39;root&#39;, 0)

        # Add root to the root group
        self.add_user_to_group(0, 0, membership_type=&#34;primary&#34;)

    def get_env(self, key) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Get an environment variable from the current session

        Args:
            key (str): The env var to retrieve

        Returns:
            str, optional: The matching value of the given key if found, otherwise, None
        &#34;&#34;&#34;
        if len(self.sessions) == 0:
            return None
        else:
            return self.sessions[-1].env.get(key)

    def set_env(self, key: str, value: str) -&gt; Result:
        &#34;&#34;&#34;
        Set an environment variable to the current session

        Args:
            key (str): The env var to set
            value (str): The value of the new var to set

        Returns:
            Result: A `Result` object with the success flag set accordingly
        &#34;&#34;&#34;
        if len(self.sessions) == 0:
            return Result(success=False, message=ResultMessages.GENERIC)

        self.sessions[-1].env[key] = value
        return Result(success=True)

    def run_current_user_shellrc(self):
        &#34;&#34;&#34;
        Run the .shellrc file in the current user&#39;s home folder (/home/&lt;USERNAME&gt;/.shellrc)
        The &#34;.shellrc&#34; file is replicating the behavior of .bashrc/.bash_profile/.zshrc (since we&#39;re not replicating one specific piece of software)

        Returns:
            None
        &#34;&#34;&#34;
        current_username = self.get_user(self.sys_getuid()).data.username

        # Don&#39;t check /home/username, check /root for .shellrc
        if self.sys_getuid() == 0:
            shellrc_loc = &#34;/root/.shellrc&#34;
        else:
            shellrc_loc = f&#34;/home/{current_username}/.shellrc&#34;

        shellrc_lookup = self.fs.find(shellrc_loc)

        if shellrc_lookup.success:
            shellrc_lines = shellrc_lookup.data.read(self)

            if shellrc_lines.success:
                for line in shellrc_lines.data.split(&#34;\n&#34;):
                    if line != &#34;&#34;:
                        line = line.split()
                        # TODO: replace with execvp
                        result = self.run_command(line[0], line[1:], pipe=False)

    def save(self, output_file: str = &#34;blackhat.save&#34;) -&gt; bool:
        &#34;&#34;&#34;
        Serialize and dump the current `Computer` (and everything that&#39;s connected to it (`StandardFS`, `File`s, etc)) to a file
        Args:
            output_file (str, optional): The file to dump the contents to

        Returns:
            bool: `True` if the dump/save was successful, otherwise `False`
        &#34;&#34;&#34;
        # Temporary: Disable saving because it doesn&#39;t work anyway
        if True == False:
        # if os.getenv(&#34;DEBUGMODE&#34;) == &#34;false&#34;:
            try:
                with open(output_file, &#34;wb&#34;) as f:
                    pickle.dump(self, f, pickle.HIGHEST_PROTOCOL)
                return True
            except Exception as e:
                # TODO: Fix save bug (can&#39;t pickle `self.connection` and `self.database`)
                return False
        else:
            return True

    ##############
    # Networking #
    ##############

    def resolve_dns(self, domain: str, dns_server: Optional[str] = None) -&gt; Result:
        &#34;&#34;&#34;
        Check all DNS servers in the /etc/resolv.conf unless a `dns_server` is specified

        args:
            domain (str): The domain name to lookup
            dns_server (str, optional) The DNS server to use to lookup the domain

        Returns:
            Result: A `Result` object with the success and data flag set accordingly
        &#34;&#34;&#34;
        if dns_server:
            # We need to try to find the given dns server
            dns_servers = [dns_server]
        else:
            find_resolv_conf = self.fs.find(&#34;/etc/resolv.conf&#34;)
            dns_servers = []
            if find_resolv_conf.success:
                content = find_resolv_conf.data.content.split(&#34;\n&#34;)
                for line in content:
                    if line.startswith(&#34;nameserver &#34;):
                        dns_servers.append(line[11:])

        for server in dns_servers:
            # Establish that the server exists
            server_obj = self.parent.find_client(server, 53)
            if server_obj.success:
                packet_result = server_obj.data.main({&#34;domain&#34;: domain})

                if packet_result.success:
                    return Result(success=True, data=packet_result.data)

        return Result(success=False, message=ResultMessages.NOT_FOUND)

    ############
    # Syscalls #
    ############
    def sys_read(self, filepath: str) -&gt; Result:
        &#34;&#34;&#34;
        Try to read the content of the given `filepath`. Checks permissions

        Args:
            filepath (str): The path of the file to read

        Returns:
            Result: A `Result` object with the success flag set accordingly and the data flag containing the files
            if read was successful
        &#34;&#34;&#34;
        # Try to find the file
        find_file = self.fs.find(filepath)

        if not find_file.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        if find_file.data.is_directory():
            return Result(success=False, message=ResultMessages.IS_DIRECTORY)

        try_read_file = find_file.data.read(self)

        if not try_read_file.success:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED_READ)

        return Result(success=True, data=try_read_file.data)

    def sys_write(self, fd: Union[str, Socket], data: Union[str, dict]) -&gt; Result:
        &#34;&#34;&#34;
        Try to write to a given file descriptor. If `fd` is a file path, this function will try to write to a file
        (permission safe), however, if the fd is a `Socket`, this function will try to send the given `data` to the
        respective `Socket`&#39;s connected service (if connected).

        Args:
            fd (str or :obj:`Socket`): The filepath of the file or Socket to write to
            data (str or dict): The data to write to the file (if fd == str) or data to send to the socket (if fd == Socket)

        Returns:
            Result: A `Result` object with the success flag set accordingly
        &#34;&#34;&#34;
        if type(fd) == Socket:
            # We&#39;re &#39;writing&#39; to a network socket
            if not fd.client:
                return Result(success=False, message=ResultMessages.NOT_CONNECTED)

            if type(data) == str:
                return Result(success=False, message=ResultMessages.INVALID_ARGUMENT)

            return fd.client.main(data)
        else:
            # We&#39;re writing to a file
            # Try to find the file
            find_file = self.fs.find(fd)

            if not find_file.success:
                return Result(success=False, message=ResultMessages.NOT_FOUND)

            if find_file.data.is_directory():
                return Result(success=False, message=ResultMessages.IS_DIRECTORY)

            try_write_file = find_file.data.write(data, self)

            if not try_write_file.success:
                return Result(success=False, message=ResultMessages.NOT_ALLOWED_WRITE)

            return Result(success=True)

    def sys_chown(self, pathname: str, owner: int, group: int) -&gt; Result:
        &#34;&#34;&#34;
        Change the owner of the given `pathname` (if allowed)

        Notes:
            Only the owner or root is allowed to change the owner of a `File`/`Directory`

        Args:
            pathname (str): The file path of the `File`/`Directory` to change the owner of
            owner (int): The UID of the new owner
            group (int): The GID of the new owner

        Returns:
            Result: A `Result` object with the success flag set accordingly
        &#34;&#34;&#34;
        find_file = self.fs.find(pathname)

        if not find_file.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        file = find_file.data

        change_perms = file.change_owner(self, owner, group)

        if not change_perms.success:
            return Result(success=False, message=change_perms.message)

        return Result(success=True)

    def sys_chdir(self, pathname: str) -&gt; Result:
        &#34;&#34;&#34;
        Change the `current_dir` of the current `Session`

        Args:
            pathname (str): The file path of the directory to `cd` into

        Returns:
            Result: A `Result` object with the success flag set accordingly
        &#34;&#34;&#34;
        find_file = self.fs.find(pathname)

        if not find_file.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        # We need executable permissions to cd (???)
        check_perm = find_file.data.check_perm(&#34;execute&#34;, self)
        if not check_perm.success:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

        if find_file.data.is_file():
            return Result(success=False, message=ResultMessages.IS_FILE)

        self.sessions[-1].current_dir = find_file.data
        return Result(success=True)

    def sys_getuid(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the UID of the `Computer`&#39;s current user

        Returns:
            int: UID of the `Computers`&#39;s current user (from most recent session)
        &#34;&#34;&#34;
        if len(self.sessions) == 0:
            return 0

        return self.sessions[-1].effective_uid

    def sys_setuid(self, uid: int) -&gt; Result:
        &#34;&#34;&#34;
        Change current `Session`&#39;s effective UID to the given `UID`

        Notes:
            setuid() followed the current rules:
                * If the &#34;caller&#34; uid is root, change the uid to whatever is given
                * If the &#34;caller&#34; isn&#39;t root, BUT the setuid bit (not implement yet) is set, the UID can be set to the owner of the file
                * If the &#34;caller&#34; isn&#39;t root, and the setuid bit ISN&#39;T set, deny all changes

        Args:
            uid (int): The new UID to change to

        Returns:
            Result: A `Result` object with the success flag set accordingly
        &#34;&#34;&#34;
        # TODO: Implement a PROPER setuid
        # The way setuid should work:
        # If the &#34;caller&#34; uid is root, change the uid to whatever is given
        # If the &#34;caller&#34; isn&#39;t root, BUT the setuid bit (not implement yet) is set, the UID can be set to the owner of the file
        # If the &#34;caller&#34; isn&#39;t root, and the setuid bit ISN&#39;T set, deny all changes

        # if self.sys_getuid() == 0:
        self.sessions[-1].effective_uid = uid
        return Result(success=True)
        # else:
        #     return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    def sys_getgid(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the (primary) GID of the `Computer`&#39;s current user

        Returns:
            int: (primary) GID of the `Computers`&#39;s current user (from most recent session)
        &#34;&#34;&#34;
        current_uid = self.sys_getuid()
        result = self.database.execute(
            &#34;SELECT group_gid FROM group_membership WHERE computer_id=? AND user_uid=? AND membership_type=?&#34;,
            (self.id, current_uid, &#34;primary&#34;)).fetchone()

        if result:
            return result[0]
        else:
            # NOTE: possible exploit, but maybe we leave it here on purpose?
            # TODO: Write proof of concept exploit to exploit this exploit
            return 0

    def sys_sethostname(self, hostname: str) -&gt; Result:
        &#34;&#34;&#34;
        An easy function to update the hostname (also updates /etc/hostname)
        Args:
            hostname (str): The `Computer`&#39;s new hostname

        Returns:
            Result: A `Result` instance with the `success` flag set accordingly.
        &#34;&#34;&#34;
        # Try to find the hostname file
        if self.sys_getuid() != 0:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

        if not self.sys_stat(&#34;/etc/hostname&#34;).success:
            # Make sure we at least have the /etc/ dir so we can make /etc/hostname
            if not self.sys_stat(&#34;/etc/&#34;).success:
                return Result(success=False, message=ResultMessages.NOT_FOUND)
            # Create the /etc/hostname
            find_etc_dir = self.fs.find(&#34;/etc/&#34;)
            find_etc_dir.data.add_file(File(&#34;hostname&#34;, hostname, find_etc_dir.data, 0, 0))
        else:
            # Even though we should never get here unless we&#39;re root, I&#39;m gonna be a good boy and do this properly
            if not self.sys_write(&#34;/etc/hostname&#34;, hostname).success:
                return Result(success=False, message=ResultMessages.NOT_ALLOWED_WRITE)

        self.hostname = hostname
        return Result(success=True)

    def sys_gethostname(self) -&gt; str:
        &#34;&#34;&#34;
        Gets the current system hostname (from internal var, not /etc/hostname)

        Returns:
            str: &#34;localhost&#34; if the hostname isn&#39;t set, otherwise, the current `Computer`&#39;s hostname
        &#34;&#34;&#34;
        return &#34;localhost&#34; if not self.hostname else self.hostname

    def sys_getcwd(self) -&gt; FSBaseObject:
        &#34;&#34;&#34;
        Get current directory in the file system

        Returns:
            FSBaseObject: The  user&#39;s current directory
        &#34;&#34;&#34;
        if len(self.sessions) == 0:
            return self.fs.files
        else:
            return self.sessions[-1].current_dir

    def sys_access(self, pathname: str, mode: int) -&gt; Result:
        &#34;&#34;&#34;
        Check if the current effective UID has a given permission to the given `File`/`Directory`
        Possible modes are:
            * F_OK: File exists
            * R_OK: Read permission
            * W_OK: Write permissions
            * X_OK: Execute permission

        Args:
            pathname (str): The file path of the given `File`/`Directory` to check
            mode (int): Bitwise flags of the permissions to check

        Returns:
            Result: A `Result` object with the success flag set accordingly
        &#34;&#34;&#34;
        # We need to find the file no matter what we do, so lets just find it now
        find_file = self.fs.find(pathname)

        success = True

        if not find_file.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        file = find_file.data

        if AccessMode.R_OK in mode:
            if not file.check_perm(&#34;read&#34;, self).success:
                success = False

        if AccessMode.W_OK in mode:
            if not file.check_perm(&#34;write&#34;, self).success:
                success = False

        if AccessMode.X_OK in mode:
            if not file.check_perm(&#34;execute&#34;, self).success:
                success = False

        return Result(success=success)

    def sys_gettimeofday(self) -&gt; Result:
        &#34;&#34;&#34;
        Get the current time (host systems time)

        Returns:
            timeval: A `timeval` struct containing the current time in seconds
        &#34;&#34;&#34;
        # TODO: Add get time by timezone
        timestamp = time()
        seconds = int(timestamp)
        microseconds = int(str(timestamp - seconds).replace(&#34;0.&#34;, &#34;&#34;))

        return Result(success=True, data=timeval(seconds, microseconds))

    def sys_stat(self, path: str) -&gt; Result:
        &#34;&#34;&#34;
        Get information about a given file

        Args:
            path (str): The path of the given `File`/`Directory` to get info about

        Returns:
            Result: A `Result` object with the success flag set accordingly and the data flag containing a `stat_struct` object if successful
        &#34;&#34;&#34;
        find_file = self.fs.find(path)

        if not find_file.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        if not find_file.data.check_perm(&#34;read&#34;, self).success:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

        file = find_file.data

        is_file = file.is_file()

        # TODO: Find a less shit way to do this
        mode = [0, 0, 0]

        # Owner bit
        if &#34;owner&#34; in file.permissions[&#34;execute&#34;]:
            mode[0] += 1
        if &#34;owner&#34; in file.permissions[&#34;write&#34;]:
            mode[0] += 2
        if &#34;owner&#34; in file.permissions[&#34;read&#34;]:
            mode[0] += 4
        # Group bit
        if &#34;group&#34; in file.permissions[&#34;execute&#34;]:
            mode[1] += 1
        if &#34;group&#34; in file.permissions[&#34;write&#34;]:
            mode[1] += 2
        if &#34;group&#34; in file.permissions[&#34;read&#34;]:
            mode[1] += 4
        # Public bit
        if &#34;public&#34; in file.permissions[&#34;execute&#34;]:
            mode[2] += 1
        if &#34;public&#34; in file.permissions[&#34;write&#34;]:
            mode[2] += 2
        if &#34;public&#34; in file.permissions[&#34;read&#34;]:
            mode[2] += 4
        mode = int(&#34;&#34;.join([str(x) for x in mode]))

        nlink = 0
        uid = file.owner
        gid = file.group_owner
        size = file.size
        # TODO: Implement atime, mtime, and ctime
        atime = 0
        mtime = 0
        ctime = 0
        path = file.pwd()

        stat_result = stat_struct(is_file, mode, nlink, uid, gid, size, atime, mtime, ctime, path)

        return Result(success=True, data=stat_result)

    def sys_mkdir(self, pathname: str, mode: int) -&gt; Result:
        &#34;&#34;&#34;
        Make a directory

        Args:
            pathname (str): The path of the directory to make
            mode (int): Octal permissions of the new `Directory`

        Returns:
            Result: A `Result` object with the success flag set accordingly and the data flag containing the new `Directory` object if successful
        &#34;&#34;&#34;
        # Make sure it doesn&#39;t already exist
        find_dir = self.fs.find(pathname)

        if find_dir.success:
            return Result(success=False, message=ResultMessages.ALREADY_EXISTS)

        if &#34;/&#34; not in pathname:
            pathname = &#34;./&#34; + pathname

        # Make sure we have write permissions on the parent dir
        parent_path = &#34;/&#34;.join(pathname.split(&#34;/&#34;)[:-1])

        # Just in case
        find_parent = self.fs.find(parent_path)

        if not find_parent.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        if not find_parent.data.check_perm(&#34;write&#34;, self).success:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED_WRITE)

        new_dir = Directory(pathname.split(&#34;/&#34;)[-1], find_parent.data, owner=self.sys_getuid(),
                            group_owner=self.sys_getgid())

        add_file = find_parent.data.add_file(new_dir)

        if not self.sys_chmod(pathname, mode).success:
            # rwxr-xr-x
            new_dir.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;],
                                   &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}

        if not add_file.success:
            return Result(success=False, message=ResultMessages.GENERIC)

        return Result(success=True, data=new_dir)

    def sys_chmod(self, pathname: str, mode: int) -&gt; Result:
        &#34;&#34;&#34;
        Change the permission mode of a `File`/`Directory`

        Args:
            pathname (str): File path of the `File`/`Directory` to change mode of
            mode (int): Octal permissions of the given pathname

        Returns:
            Result: A `Result` instance with the `success` flag set accordingly.
        &#34;&#34;&#34;
        find_file = self.fs.find(pathname)

        if not find_file.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        # Only the owner can change chmod permissions
        if self.sys_getuid() not in [find_file.data.owner, 0]:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

        raw_mode = str(bin(mode)).replace(&#34;0b&#34;, &#34;&#34;)
        raw_mode = &#34;0&#34; * (9 - len(raw_mode)) + raw_mode

        chmod_bits = []
        for x in range(0, len(raw_mode), 3):
            chmod_bits.append(raw_mode[x: x + 3])

        perms = {&#34;read&#34;: [], &#34;write&#34;: [], &#34;execute&#34;: []}

        for x in range(3):
            bits = chmod_bits[x]
            scope = [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;][x]

            for y in range(3):
                bit = bits[y]
                perm_scope = [&#34;read&#34;, &#34;write&#34;, &#34;execute&#34;][y]

                if bit == &#34;1&#34;:
                    perms[perm_scope].append(scope)

        find_file.data.permissions = perms
        find_file.data.handle_event(&#34;change_perm&#34;)
        return Result(success=True)

    def sys_creat(self, pathname: str, mode: int) -&gt; Result:
        &#34;&#34;&#34;
        Make a file

        Args:
            pathname (str): The path of the file to make
            mode (int): Octal permissions of the new `File`

        Returns:
            Result: A `Result` object with the success flag set accordingly
        &#34;&#34;&#34;
        # Try to resolve the path
        find_file = self.fs.find(pathname)

        if find_file.success:
            return Result(success=False, message=ResultMessages.ALREADY_EXISTS)

        if &#34;/&#34; not in pathname:
            pathname = &#34;./&#34; + pathname

        # Make sure we have write permissions on the parent dir
        parent_path = &#34;/&#34;.join(pathname.split(&#34;/&#34;)[:-1])

        # Just in case
        find_parent = self.fs.find(parent_path)

        # Sanity check
        if not find_parent.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        # We need write permissions on the parent
        if not find_parent.data.check_perm(&#34;write&#34;, self).success:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

        new_file = File(pathname.split(&#34;/&#34;)[-1], &#34;&#34;, find_parent.data, self.sys_getuid(), self.sys_getgid())
        self.sys_chmod(pathname, mode)
        find_parent.data.add_file(new_file)

        return Result(success=True)

    def sys_rename(self, oldpath: str, newpath: str) -&gt; Result:
        &#34;&#34;&#34;
        Rename or move a file or directory

        Args:
            oldpath (str): The original file/directory path to rename
            newpath (str): The new path of the file/directory

        Returns:
            Result: A `Result` object with the success flag set accordingly
        &#34;&#34;&#34;
        find_old = self.fs.find(oldpath)

        if not find_old.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        if not find_old.data.check_owner(self).success or self.sys_getuid() != 0:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

        copy_result = copy(self, oldpath, newpath)

        if not copy_result.success:
            return copy_result

        # Rename means move, so delete the original
        delete_result = self.fs.find(oldpath).data.delete(self)

        if not delete_result.success:
            return delete_result

        return Result(success=True)

    def sys_exit(self, force=False) -&gt; None:
        &#34;&#34;&#34;
        Exit a session and return to the previous session. If a previous computer exists and no sessions exist,
        return to the previous computer. If no previous computer exists, exit the game.

        Args:
            force (bool): If a prev computer exists, exit to previous computer regardless of previous sessions. If no previous computers exist, exit the game.

        Returns:
            None
        &#34;&#34;&#34;
        if force:
            if len(self.shell.computers) == 1:
                self.save()
                exit(0)
            else:
                self.sessions = []
                self.shell.computers.pop()
        else:
            if len(self.shell.computers) == 1:
                if len(self.sessions) == 1:
                    self.save()
                    exit(0)
                else:
                    self.sessions.pop()
            else:
                self.shell.computers.pop()

    def sys_reboot(self, mode: int) -&gt; Result:
        &#34;&#34;&#34;
        Simulate a computer reboot. Clear all sessions and re-initialize the machine

        Args:
            mode (int: Bitwise flags of the operation to take

        Returns:
            Result: A `Result` object with the success flag set accordingly
        &#34;&#34;&#34;
        if self.sys_getuid() != 0:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

        if RebootMode.LINUX_REBOOT_CMD_POWER_OFF in mode:
            self.sys_exit(True)

        if RebootMode.LINUX_REBOOT_CMD_RESTART in mode:
            print(f&#34;Rebooting...&#34;)
            sleep(1)
            if system() == &#34;Windows&#34;:
                real_syscall(&#34;cls&#34;)
            else:
                real_syscall(&#34;clear&#34;)
            self.run_command(&#34;clear&#34;, [], pipe=True)
            self.init()
            while len(self.sessions) != 1:
                self.sys_exit()

        return Result(success=True)

    def sys_rmdir(self, pathname: str) -&gt; Result:
        &#34;&#34;&#34;
        Remove an empty directory

        Args:
            pathname (str): The file path of the empty `Directory` to remove

        Returns:
            Result: A `Result` object with the success flag set accordingly
        &#34;&#34;&#34;
        find_result = self.fs.find(pathname)

        if not find_result.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        if find_result.data.is_file():
            return Result(success=False, message=ResultMessages.IS_FILE)

        if len(find_result.data.files) &gt; 0:
            return Result(success=False, message=ResultMessages.NOT_EMPTY)

        delete_response = find_result.data.delete(self)

        if not delete_response.success:
            return delete_response

        return Result(success=True)

    def sys_execv(self, pathname: str, argv: list) -&gt; Result:
        &#34;&#34;&#34;
        Execute a file

        Args:
            pathname (str): The path name of the binary to execute
            argv (list): A list of arguments to pass to the binary

        Returns:
            Result: A `Result` arguments containing the output from the binary
        &#34;&#34;&#34;
        find_result = self.fs.find(pathname)

        if not find_result.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        if not find_result.data.check_perm(&#34;execute&#34;, self).success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        return self.run_command(pathname.split(&#34;/&#34;)[-1], argv, False)

    def sys_execvp(self, command: str, argv: list) -&gt; Result:
        &#34;&#34;&#34;
        Execute a command using the PATH rather than the full binary path. Does exactly what the system shell does.

        Args:
            command (str): The command to run
            argv (list): A list of arguments to pass to the binary

        Returns:
            Result: A `Result` arguments containing the output from the binary
        &#34;&#34;&#34;
        return self.run_command(command, argv, False)

    def sys_unlink(self, pathname: str) -&gt; Result:
        &#34;&#34;&#34;
        Removes a link to a file. If there are no links left, the file is removed.

        Args:
            pathname (str): The file path of the `File` to unlink

        Returns:
            Result: A `Result` arguments containing the output from the binary

        &#34;&#34;&#34;
        find_result = self.fs.find(pathname)

        if not find_result.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        if not find_result.data.check_perm(&#34;write&#34;, self) or not find_result.data.check_perm(&#34;execute&#34;, self):
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

        delete_result = find_result.data.delete(self)

        if not delete_result.success:
            return delete_result

        return Result(success=True)


class Router(Computer):
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        This special type of `Computer` is made for handling network traffic between computers in a LAN
        This class represents what a real router would be in real life
        &#34;&#34;&#34;
        super().__init__()
        self.clients = {}  # Format of clients: sorted by subnet then ID [1][2] (subnet 1 - ID 2)
        self.ip_pool: dict[int, list[str]] = {}
        self.wan = None
        self.lan = &#34;192.168.1.1&#34;
        self.port_forwarding = {}

    def dhcp(self, subnet: int) -&gt; Result:
        &#34;&#34;&#34;
        Distributes IP addresses to clients on the network

        Args:
            subnet (int): subnet id to assign the client to

        Returns:
            Result: A `Result` with the `success` flag set accordingly. The `data` flag contains the IP to assign to a given client.
        &#34;&#34;&#34;
        # Split the router&#39;s IP to get the first 16 bits
        ip_split = self.lan.split(&#34;.&#34;)
        network_prefix = f&#34;{ip_split[0]}.{ip_split[1]}.{subnet}&#34;

        # Check if the IP pool for that subnet was generated already
        try:
            len(self.ip_pool[subnet])
        # If `self.ip_pool[&lt;subnet&gt;]` returns a key error, it was never created before
        except KeyError:
            # Generate a list of ips that are &lt;NETWORK_PREFIX&gt;.&lt;subnet&gt;.1-256
            self.ip_pool[subnet] = [f&#34;{network_prefix}.{x}&#34; for x in range(1, 257)]

        # Check if we have IP&#39;s left
        if len(self.ip_pool[subnet]) == 0:
            return Result(success=False, message=ResultMessages.EMPTY)

        # Choose a random ip from the pool
        ip = choice(self.ip_pool[subnet])

        # Remove the IP from the pool since it&#39;s in use
        self.ip_pool[subnet].remove(ip)
        return Result(success=True, data=ip)

    def find_client(self, host: str, port: int) -&gt; Result:
        # Check if the given `host` belongs to us or its in an external lan
        prefix = &#34;.&#34;.join(self.lan.split(&#34;.&#34;)[0:2]) + &#34;.&#34;
        subnet = host.split(&#34;.&#34;)[2]

        if host == self.wan:
            if port in self.port_forwarding.keys():
                return Result(success=True, data=self.port_forwarding[port].services[port])
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        # We&#39;re finding one of our own
        if host.startswith(prefix):
            # Quick check, if subnet is empty, we don&#39;t have the client
            get_subnet = self.clients.get(int(subnet))
            if not get_subnet:
                return Result(success=False, message=ResultMessages.NOT_FOUND)
            # We can ignore the port because we don&#39;t need port forwarding in a lan
            client_result = next((x for x in get_subnet.values() if x.lan == host), None)
            if not client_result:
                return Result(success=False, message=ResultMessages.NOT_FOUND)

            # Now we need to check if the client has a service on that port
            # In real life, we wouldn&#39;t be able to make a connection if there is no service
            # on the given port
            if port not in client_result.services.keys():
                return Result(success=False, message=ResultMessages.NOT_FOUND)

            return Result(success=True, data=client_result.services.get(port))

        # We need to get the client from another lan, ask the ISP to handle it
        return self.parent.find_client(host, port)

    def add_new_client(self, client: Computer, subnet: int = 1) -&gt; Result:
        &#34;&#34;&#34;
        Connect a given `Computer` to the given `Router`&#39;s LAN.
        Also, assign an IP address using the `dhcp()` function.

        Args:
            client (:obj:`Computer`): The `Computer` instance to connect to the `Router`&#39;s LAN
            subnet (int, optional): The subnet id to assign the given `Computer` to

        Returns:
            Result: A `Result` with the `success` flag set accordingly. The `data` flag contains the `client`&#39;s newly assigned IP address if successful.
        &#34;&#34;&#34;
        # Generate an IP for the client
        generate_ip_status = self.dhcp(subnet)
        # We we&#39;re unable to generate an IP for the given client
        if not generate_ip_status:
            return generate_ip_status

        # Assign the IP
        client.lan = generate_ip_status.data

        # Append to client to our client list
        try:
            last_id = list(self.clients[subnet].keys())[-1]
        except KeyError:
            last_id = 0

        # Check if the client subnet exists
        try:
            len(self.clients[subnet])
        except KeyError:
            # Init the subnet (empty)
            self.clients[subnet] = {}

        self.clients[subnet][last_id + 1] = client

        client.parent = self

        return Result(success=True, data=client.lan)


class ISPRouter(Router):
    def __init__(self):
        &#34;&#34;&#34;
        An ISP router is just a router of routers
        &#34;&#34;&#34;
        super().__init__()
        self.wan = &#34;1.1.1.1&#34;
        self.used_ips = [&#34;1.1.1.1&#34;]

    def dhcp(self, **kwargs) -&gt; Result:
        &#34;&#34;&#34;
        Distributes IP addresses to clients on the network

        Returns:
            Result: A `Result` with the `success` flag set accordingly. The `data` flag contains the IP to assign to a given client.
        &#34;&#34;&#34;
        while True:
            ip = &#34;.&#34;.join(str(choice([x for x in range(1, 256) if x not in [192, 168]])) for _ in range(4))
            if ip not in self.used_ips:
                self.used_ips.append(ip)
                return Result(success=True, data=ip)

    def add_new_client(self, client: Router, **kwargs) -&gt; Result:
        &#34;&#34;&#34;
        Connect a given `Computer` to the given `ISPRouter`
        Also, assign an IP address using the `dhcp()` function.

        Args:
            client (:obj:`Computer`): The `Computer` instance to connect to the `ISPRouter`

        Returns:
            Result: A `Result` with the `success` flag set accordingly. The `data` flag contains the `client`&#39;s newly assigned IP address if successful.
        &#34;&#34;&#34;
        dhcp_result = self.dhcp()
        if dhcp_result.success:
            client.wan = dhcp_result.data
            client.parent = self
            self.clients[client.wan] = client
            return Result(success=True, data=client.wan)
        else:
            # Failed for some reason (DHCP will give us our error)
            return dhcp_result

    def find_client(self, host: str, port: int) -&gt; Result:
        if host == self.wan:
            if port in self.services.keys():
                return Result(success=True, data=self.services.get(port))
            else:
                return Result(success=False, message=ResultMessages.NOT_FOUND)
        else:
            find_client = next((x for x in self.clients.values() if x.wan == host), None)

            if find_client:
                return find_client.find_client(host, port)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="client.blackhat.computer.Computer"><code class="flex name class">
<span>class <span class="ident">Computer</span></span>
</code></dt>
<dd>
<div class="desc"><p>The class object representing a basic linux computer. This class is the base for all nodes on a network</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Computer:
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        The class object representing a basic linux computer. This class is the base for all nodes on a network
        &#34;&#34;&#34;
        self.connection = sqlite3.connect(&#34;blackhat.db&#34;)
        self.database = self.connection.cursor()
        self.boot_time = datetime.now()
        self.parent: Optional[Computer, Router, ISPRouter] = None  # Router
        self.hostname: Optional[str] = None
        self.users: Dict[int, User] = {}
        self.groups: Dict[int, Group] = {}
        self.sessions: List[Session] = []
        self.lan = None
        self.id = token_hex(8)
        self.shell = None
        # Root user needs to be created before the FS is initialized (FS needs root to have a password to create /etc/passwd)
        self.init()

        # self.create_root_user()

        self.fs: StandardFS = StandardFS(self)
        self.services: dict[int, Service] = {0: PingServer(self)}
        self.post_fs_init()

    ##################
    # Init functions #
    ##################

    def init(self) -&gt; None:
        &#34;&#34;&#34;
        Functions ran when a computer is booted (pre file-system setup/pre root user creation)

        Returns:
            None
        &#34;&#34;&#34;
        self.boot_time = datetime.now()
        # Try to setup the user, group, and group membership tables
        init_tables_file = open(&#34;blackhat/database/init_tables.sql&#34;)
        init_tables = init_tables_file.read()
        self.database.executescript(init_tables)

        # Check if the computer we&#39;re initializing already exists in the database (we&#39;re loading an existing save)
        result = self.database.execute(&#34;SELECT * FROM computer WHERE id=?&#34;, (self.id,)).fetchall()

        if len(result) == 0:
            # We&#39;re starting a new save, lets save a copy of this computers id in the database, along with create the root user
            self.database.execute(&#34;INSERT INTO computer VALUES (?)&#34;, (self.id,))
            self.create_root_user()
            self.connection.commit()

        init_tables_file.close()

    def post_fs_init(self) -&gt; None:
        &#34;&#34;&#34;
        Function ran after the file system and root user were initialized

        Returns:
            None
        &#34;&#34;&#34;
        self.sync_hostname()
        self.sync_user_and_group_files()

    def update_libs(self):
        &#34;&#34;&#34;
        The system libraries need access to the given `Computer` object, so before a command runs, we pass a reference
        to the current `Computer` object, so the binaries don&#39;t need `computer` in their arguments (prevents cheating in
        binaries). If commands had access to a `Computer` object, they could just read files without permission, access
        user passwords that they shouldn&#39;t, change current UID when they shouldn&#39;t, etc.

        Returns:
            None
        &#34;&#34;&#34;
        libs = [unistd, time, stat, stdlib, dirent, fcntl, inet, stdio, pwd, socket, ifaddrs, netdb]

        for lib in libs:
            lib.update(self)

    ##############
    # Sync files #
    ##############

    def sync_hostname(self) -&gt; None:
        &#34;&#34;&#34;
        Reads /etc/hostname and sets the system hostname accordingly
        If /etc/hostname doesn&#39;t exist, the hostname is set to &#34;localhost&#34;

        Returns:
            None
        &#34;&#34;&#34;
        # Note: We don&#39;t need to use the sethostname syscall because this is only if we updated the /etc/hostname file
        etc_dir: Directory = self.fs.files.find(&#34;etc&#34;)

        if not etc_dir:
            self.hostname = &#34;localhost&#34;

        else:
            hostname_file: File = etc_dir.find(&#34;hostname&#34;)

            if not hostname_file:
                self.hostname = &#34;localhost&#34;
            else:
                self.hostname = hostname_file.content.split(&#34;\n&#34;)[0]

    def sync_user_and_group_files(self) -&gt; Result:
        &#34;&#34;&#34;
        Makes sure that:
        /etc/passwd matches our internal user map
        /etc/shadow matches our internal user map
        /etc/group matches our internal group map

        Returns:
            None
        &#34;&#34;&#34;
        etc_dir: Directory = self.fs.files.find(&#34;etc&#34;)

        if not etc_dir:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        passwd_file: File = etc_dir.find(&#34;passwd&#34;)
        shadow_file: File = etc_dir.find(&#34;shadow&#34;)
        group_file: File = etc_dir.find(&#34;group&#34;)

        # TODO: Allow modification of home directory from here
        # passwd format: USERNAME:MD5_PASSWORD OR &#34;x&#34;:UID:PRIMARY_GID
        # shadow format: USERNAME:MD5_PASSWORD
        # group format: GROUP_NAME:x:GID:GROUP_USERS

        passwd_content = &#34;&#34;
        shadow_content = &#34;&#34;
        group_content = &#34;&#34;

        for user in self.get_all_users().data:
            # Find the &#34;primary&#34; group
            primary_group = self.get_user_primary_group(user.uid)
            if primary_group.success:
                if len(primary_group.data) &gt; 0:
                    primary_group = primary_group.data[0]
                else:
                    primary_group = &#34;?&#34;
            else:
                primary_group = &#34;?&#34;

            passwd_content += f&#34;{user.username}:x:{user.uid}:{primary_group}\n&#34;
            shadow_content += f&#34;{user.username}:{user.password}\n&#34;

        for group in self.get_all_groups().data:
            uids = self.get_users_in_group(group.gid).data
            usernames = &#34;&#34;
            for uid in uids:
                user_lookup = self.get_user(uid=uid[0])
                usernames += (&#34;?&#34; if not user_lookup.success else user_lookup.data.username) + &#34;,&#34;

            usernames = usernames[:-1]

            group_content += f&#34;{group.name}:x:{group.gid}:{usernames}\n&#34;
            # print(group_content, end=&#34;&#34;)

        if not passwd_file:
            # Create the /etc/passwd
            etc_dir.add_file(File(&#34;passwd&#34;, passwd_content, etc_dir, 0, 0))
        else:
            passwd_file.content = passwd_content

        if not shadow_file:
            # Create the /etc/shadow file and change its perms (rw-------)
            shadow_file = File(&#34;shadow&#34;, shadow_content, etc_dir, 0, 0)
            shadow_file.permissions = {&#34;read&#34;: [&#34;owner&#34;], &#34;write&#34;: [&#34;owner&#34;], &#34;execute&#34;: []}
            etc_dir.add_file(shadow_file)
        else:
            shadow_file.content = shadow_content

        if not group_file:
            # Create the /etc/group
            etc_dir.add_file(File(&#34;group&#34;, group_content, etc_dir, 0, 0))
        else:
            group_file.content = group_content

        return Result(success=True)

    def run_command(self, command: str, args: Union[str, List[str], None], pipe: bool) -&gt; Result:
        &#34;&#34;&#34;
        Runs a system binary or an external binary
        Args:
            command (str): The command or binary to run
            args (list): A list of arguments passed to the command or binary
            pipe (bool): If a pipe was used (used for routing input/output)
        Returns:
            SysCallStatus: A `SysCallStatus` object that contains a success status and some response data (changed on a case-by-case basis)
        &#34;&#34;&#34;
        # The way that the path works is that if there are 2 binaries with the same name in 2 different directories,
        # The one that matches first in the path gets run
        # For example, if ls is in /etc/ and in /bin/ and the path is PATH=/home:/bin:/etc, the one in bin will run
        # For example, if ls is in /etc/ and in /bin/ and the path is PATH=/home:/etc:/bin, the one in etc will run
        self.update_libs()
        try:
            bin_dirs_text = self.sessions[-1].env.get(&#34;PATH&#34;).split(&#34;:&#34;)
            bin_dirs = []

            for dir in bin_dirs_text:
                find_dir = self.fs.find(dir)
                if find_dir.success:
                    bin_dirs.append(find_dir.data)
        except AttributeError:
            find_bin = self.fs.find(&#34;/bin&#34;)
            if find_bin.success:
                bin_dirs = [find_bin.data]
            else:
                bin_dirs = []

        if len(bin_dirs) == 0:
            print(f&#34;{command}: command not found&#34;)
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        exists = False

        for dir in bin_dirs:
            if command in list(dir.files.keys()):
                to_run = True
                break
        else:
            print(f&#34;{command}: command not found&#34;)
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        try:
            module = importlib.import_module(f&#34;blackhat.bin.{command}&#34;)

        except ImportError:
            try:
                module = importlib.import_module(f&#34;blackhat.bin.installable.{command}&#34;)
            except ImportError:
                print(f&#34;There was an error when running command: {command}&#34;)
                return Result(success=False, message=ResultMessages.GENERIC)

        try:
            response = module.main(args, pipe)

        except Exception as e:
            import traceback
            traceback.print_exc()
            print(f&#34;{command}: Segmentation violation&#34;)
            return Result(success=False, message=ResultMessages.GENERIC)

        self.sessions[-1].effective_uid = self.sessions[-1].real_uid
        if os.getenv(&#34;DEBUGMODE&#34;) == &#34;false&#34;:
            self.save()

        return response

    #################
    # User + Groups #
    #################

    def add_user(self, username: str, password: str, uid: Optional[int] = None, plaintext=True) -&gt; Result:
        &#34;&#34;&#34;
        Add a new user to the system.
        This function also generates the UID for the new user (unless manually specified)

        Args:
            username (str): The username for the new user
            password (str): The plaintext password for the new user
            uid (int, optional): The UID of the new user
                        plaintext (bool): If the given `new_password` is plain text or an MD5 hash

        Returns:
            Result: A `Result` instance with the `success` flag set accordingly. The `data` flag contains the new users UID if successful.
        &#34;&#34;&#34;
        if self.get_user(username=username).success:
            return Result(success=False, message=ResultMessages.ALREADY_EXISTS)

        # new_user = User(username)
        # new_user.set_password(password)

        # Manually specific UID
        if uid:
            # Check if a user with the given UID already exists
            if self.get_user(uid=uid).success:
                return Result(success=False, message=ResultMessages.ALREADY_EXISTS)
            else:
                next_uid = uid
        # Auto-generate the UID (depending on the situation)
        else:
            # We&#39;re creating our root user, there isn&#39;t going to be a previous UID
            users = self.get_all_users().data
            if len(users) == 0:
                next_uid = 0
            else:
                # Get the UID from the previously created user
                last_uid = users[-1].uid
                if last_uid == 0:
                    next_uid = 1000
                else:
                    next_uid = last_uid + 1
                    user_with_next_uid = self.get_user(uid=next_uid)

                    while user_with_next_uid.success:
                        next_uid += 1
                        user_with_next_uid = self.get_user(uid=next_uid)

        # Hash the password before saving to the database
        hashed_password = md5(password.encode()).hexdigest() if plaintext else password

        # Create the new user
        self.database.execute(&#34;INSERT INTO blackhat_user (uid, username, password, computer_id) VALUES (?, ?, ?, ?)&#34;,
                              (next_uid, username, hashed_password, self.id))
        self.connection.commit()

        return Result(success=True, data=next_uid)

    def delete_user(self, username: str) -&gt; Result:
        &#34;&#34;&#34;
        Deletes a user from the system (by username)

        Args:
            username (str): The username of the user to delete

        Returns:
            Result: A `Result` instance with the `success` flag set accordingly.
        &#34;&#34;&#34;
        if self.get_user(username=username).success:
            self.database.execute(&#34;DELETE FROM blackhat_user WHERE computer_id=? and username=?&#34;, (self.id, username))
            self.connection.commit()
            return Result(success=True)

        return Result(success=False, message=ResultMessages.NOT_FOUND)

    def change_user_password(self, uid: int, new_password: str, plaintext=True) -&gt; Result:
        &#34;&#34;&#34;
        Change the password of the user by uid

        Args:
            uid (int): The UID of the `User` to change the password of
            new_password (str): The MD5 hash of the password
            plaintext (bool): If the given `new_password` is plain text or an MD5 hash

        Returns:
            Result: A `Result` with the `success` flag set accordingly.
        &#34;&#34;&#34;
        # Double check that the user with the given UID exists
        lookup_user = self.get_user(uid=uid)
        if not lookup_user.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        # Hash the plain text password
        password_hash = md5(new_password.encode()).hexdigest() if plaintext else new_password

        # Update the password in the database
        result = self.database.execute(&#34;UPDATE blackhat_user SET password=? WHERE uid=? AND computer_id=?&#34;,
                                       (password_hash, uid, self.id))
        self.connection.commit()
        return Result(success=True)

    def change_user_uid(self, uid: int, new_uid: int) -&gt; Result:
        &#34;&#34;&#34;
        Change the uid of the user by uid

        Args:
            uid (int): The UID of the `User` to change the uid of
            new_uid (int): The new uid of the given user

        Returns:
            Result: A `Result` with the `success` flag set accordingly.
        &#34;&#34;&#34;
        # Double check that the user with the given UID exists
        lookup_user = self.get_user(uid=uid)
        if not lookup_user.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        # Make sure that no other user has the given `new_uid`
        lookup_user = self.get_user(uid=new_uid)
        if lookup_user.success:
            return Result(success=False, message=ResultMessages.ALREADY_EXISTS)

        # Update the uid in the database
        result = self.database.execute(&#34;UPDATE blackhat_user SET uid=? WHERE uid=? AND computer_id=?&#34;,
                                       (new_uid, uid, self.id))
        self.connection.commit()

        # We need to update the UID of all sessions that this user has
        for session in self.sessions:
            if session.real_uid == uid:
                session.real_uid = new_uid

            if session.effective_uid == uid:
                session.effective_uid = new_uid

        # We also need to update the UID in the group membership records
        self.database.execute(&#34;UPDATE group_membership SET user_uid=? WHERE user_uid=? AND computer_id=?&#34;,
                              (new_uid, uid, self.id))

        return Result(success=True)

    def add_group(self, name: str, gid: Optional[int] = None) -&gt; Result:
        &#34;&#34;&#34;
        Add a new group to the system.
        This function also generates the GID for the new group (unless manually specified)

        Args:
            name (str): The name for the new group
            gid (int, optional): The GID of the new user

        Returns:
            Result: A `Result` instance with the `success` flag set accordingly. The `data` flag contains the GID if successful.
        &#34;&#34;&#34;
        if self.get_group(name=name).success:
            return Result(success=False, message=ResultMessages.ALREADY_EXISTS)

        if gid:
            # Check if a group with the given GID already exists
            if self.get_group(gid=gid, name=name).success:
                return Result(success=False, message=ResultMessages.ALREADY_EXISTS)
            else:
                next_gid = gid
        else:
            # Auto-generate the GID (depending on the situation)
            groups = self.get_all_groups().data
            if len(groups) == 0:
                next_gid = 0
            else:
                # Get the GID from the previously created group
                last_gid = groups[-1].gid
                if last_gid == 0:
                    next_gid = 1000
                else:
                    next_gid = last_gid + 1

        # Create the new group and commit
        self.database.execute(&#34;INSERT INTO blackhat_group (gid, name, computer_id) VALUES (?, ?, ?)&#34;,
                              (next_gid, name, self.id))
        self.connection.commit()

        return Result(success=True, data=next_gid)

    def delete_group(self, name: str) -&gt; Result:
        &#34;&#34;&#34;
        Deletes a group from the system (by name)

        Args:
            name (str): The name of the group to delete

        Returns:
            Result: A `Result` instance with the `success` flag set accordingly.
        &#34;&#34;&#34;
        if self.get_group(name=name).success:
            self.database.execute(&#34;DELETE FROM blackhat_group WHERE computer_id=? and name=?&#34;, (self.id, name))
            self.connection.commit()
            return Result(success=True)

        return Result(success=False, message=ResultMessages.NOT_FOUND)

    def add_user_to_group(self, uid: int, gid: int,
                          membership_type: Literal[&#34;primary&#34;, &#34;secondary&#34;] = &#34;secondary&#34;) -&gt; Result:
        &#34;&#34;&#34;
        Add a user to a group (by uid and gid)

        Args:
            uid (int): The UID of the user
            gid (int): The GID of the group to add the user to
            membership_type (str): The type of group relationship (primary, secondary)

        Returns:
            Result: A `Result` object with the `success` flag set accordingly
        &#34;&#34;&#34;
        # Confirm that both user and group exists
        if self.get_user(uid=uid).success and self.get_group(gid=gid).success:
            self.database.execute(
                &#34;INSERT INTO group_membership (computer_id, user_uid, group_gid, membership_type) VALUES (?, ?, ?, ?)&#34;,
                (self.id, uid, gid, membership_type))
            self.connection.commit()
            return Result(success=True)
        else:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

    def get_user_groups(self, uid: int) -&gt; Result:
        &#34;&#34;&#34;
        Get the list of `Group` GID&#39;s that the `User` belongs to (by UID)

        Args:
            uid (int): The UID of the user to lookup

        Returns:
            Result: A `Result` with the `data` flag containing a list of GIDs
        &#34;&#34;&#34;
        # Double check if the user exists
        if not self.get_user(uid=uid).success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)
        else:
            # Ask the database for the GIDs
            result = self.database.execute(&#34;SELECT group_gid FROM group_membership WHERE computer_id=? and user_uid=?;&#34;,
                                           (self.id, uid)).fetchall()
            return Result(success=True, data=[x[0] for x in result])

    def get_user_primary_group(self, uid: int) -&gt; Result:
        &#34;&#34;&#34;
        Get the `Group` GID&#39;s that is the `User`s primary `Group` (by UID)

        Args:
            uid (int): The UID of the user to lookup

        Returns:
            Result: A `Result` with the `data` flag containing a list of GIDs
        &#34;&#34;&#34;
        # Double check if the user exists
        if not self.get_user(uid=uid).success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)
        else:
            # Ask the database for the GIDs
            result = self.database.execute(
                &#34;SELECT group_gid FROM group_membership WHERE computer_id=? and user_uid=? and membership_type=?;&#34;,
                (self.id, uid, &#34;primary&#34;)).fetchone()
            return Result(success=True, data=[x for x in result])

    def get_users_in_group(self, gid: int) -&gt; Result:
        &#34;&#34;&#34;
        Get a list of user UIDs that are part of the given groups GID

        Args:
            gid (int): The GID of the group to search

        Returns:
            Result: A `Result` with the `data` flag containing a list of UIDs
        &#34;&#34;&#34;
        # Double check if the group exists
        if not self.get_group(gid=gid).success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)
        # Ask the database for the UIDs
        result = self.database.execute(
            &#34;SELECT uid FROM blackhat_user WHERE computer_id=? AND uid in (SELECT user_uid FROM group_membership WHERE computer_id=? AND group_gid=?)&#34;,
            (self.id, self.id, gid)).fetchall()

        return Result(success=True, data=[x for x in result])

    def remove_user_from_group(self, uid: int, gid: int) -&gt; Result:
        &#34;&#34;&#34;
        Remove a user from a group (by uid and gid)

        Args:
            uid (int): The UID of the user
            gid (int): The GID of the group to remove the user from

        Returns:
            Result: A `Result` object with the `success` flag set accordingly
        &#34;&#34;&#34;
        # Confirm that both user and group exists
        if self.get_user(uid=uid).success and self.get_group(gid=gid).success:
            self.database.execute(&#34;DELETE FROM group_membership WHERE computer_id=? AND user_uid=? AND group_gid=?&#34;,
                                  (self.id, uid, gid))
            self.connection.commit()
            return Result(success=True)
        else:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

    def get_user(self, uid: Optional[int] = None, username: Optional[str] = None) -&gt; Result:
        &#34;&#34;&#34;
        Find a user in the database by UID or username
        Args:
            uid (int, optional): The UID of the user to find
            username (str, optional): The username of the user to find

        Returns:
            Result: A `Result` with the `success` flag set accordingly. The `data` flag contains the user dict if found
        &#34;&#34;&#34;
        if uid is None and username is None:
            return Result(success=False, message=ResultMessages.NOT_FOUND)
        else:
            result = self.database.execute(&#34;SELECT * FROM blackhat_user WHERE (uid=? OR username=?) AND computer_id=?&#34;,
                                           (uid, username, self.id)).fetchone()
            if not result:
                return Result(success=False, message=ResultMessages.NOT_FOUND)

            return Result(success=True,
                          data=User(uid=result[1], username=result[2], password=result[3], full_name=result[4],
                                    room_number=result[5],
                                    work_phone=result[6], home_phone=result[7], other=result[8]))

    def get_group(self, gid: Optional[int] = None, name: Optional[str] = None) -&gt; Result:
        &#34;&#34;&#34;
        Find a group in the database by GID or name or both
        Args:
            gid (int, optional): The GID of the group to find
            name (str, optional): The name of the group to find

        Returns:
            Result: A `Result` with the `success` flag set accordingly. The `data` flag contains the group dict if found
        &#34;&#34;&#34;
        if gid is None and name is None:
            return Result(success=False, message=ResultMessages.NOT_FOUND)
        # We&#39;re looking by name AND gid
        elif gid is not None and name is not None:
            result = self.database.execute(&#34;SELECT * FROM blackhat_group WHERE (gid=? AND name=?) AND computer_id=?&#34;,
                                           (gid, name, self.id)).fetchone()
        else:
            result = self.database.execute(&#34;SELECT * FROM blackhat_group WHERE (gid=? OR name=?) AND computer_id=?&#34;,
                                           (gid, name, self.id)).fetchone()

        if not result:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        return Result(success=True, data=Group(gid=result[1], name=result[2]))

    def get_all_users(self) -&gt; Result:
        &#34;&#34;&#34;
        Get all users that exist in the given system in the given format:

        Returns:
            Result: A `Result` with the `data` flag containing the array of `User`s
        &#34;&#34;&#34;
        all_users = self.database.execute(&#34;SELECT * FROM blackhat_user WHERE computer_id=?&#34;,
                                          (self.id,)).fetchall()

        clean_users = []

        for user in all_users:
            clean_users.append(
                User(uid=user[1], username=user[2], password=user[3], full_name=user[4], room_number=user[5],
                     work_phone=user[6], home_phone=user[7], other=user[8]))
        return Result(success=True, data=clean_users)

    def get_all_groups(self) -&gt; Result:
        &#34;&#34;&#34;
        Get all groups that exist in the given system in the given format:

        Returns:
            Result: A `Result` with the `data` flag containing the array of `Group`s
        &#34;&#34;&#34;
        all_groups = self.database.execute(&#34;SELECT * FROM blackhat_group WHERE computer_id=?&#34;,
                                           (self.id,)).fetchall()

        clean_groups = []

        for group in all_groups:
            clean_groups.append(Group(gid=group[1], name=group[2]))
        return Result(success=True, data=clean_groups)

    def create_root_user(self) -&gt; None:
        &#34;&#34;&#34;
        Since the root user is different from &#34;standard&#34; users, and it must exist in any given system, it is manually
        created when the `Computer` is first initialized.

        Returns:
            None
        &#34;&#34;&#34;
        # Add the root user with a random password
        # self.add_user(&#34;root&#34;, &#39;&#39;.join([choice(ascii_uppercase + digits) for _ in range(16)]))
        self.add_user(&#34;root&#34;, &#34;password&#34;, uid=0)
        # Create the root group
        self.add_group(&#39;root&#39;, 0)

        # Add root to the root group
        self.add_user_to_group(0, 0, membership_type=&#34;primary&#34;)

    def get_env(self, key) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Get an environment variable from the current session

        Args:
            key (str): The env var to retrieve

        Returns:
            str, optional: The matching value of the given key if found, otherwise, None
        &#34;&#34;&#34;
        if len(self.sessions) == 0:
            return None
        else:
            return self.sessions[-1].env.get(key)

    def set_env(self, key: str, value: str) -&gt; Result:
        &#34;&#34;&#34;
        Set an environment variable to the current session

        Args:
            key (str): The env var to set
            value (str): The value of the new var to set

        Returns:
            Result: A `Result` object with the success flag set accordingly
        &#34;&#34;&#34;
        if len(self.sessions) == 0:
            return Result(success=False, message=ResultMessages.GENERIC)

        self.sessions[-1].env[key] = value
        return Result(success=True)

    def run_current_user_shellrc(self):
        &#34;&#34;&#34;
        Run the .shellrc file in the current user&#39;s home folder (/home/&lt;USERNAME&gt;/.shellrc)
        The &#34;.shellrc&#34; file is replicating the behavior of .bashrc/.bash_profile/.zshrc (since we&#39;re not replicating one specific piece of software)

        Returns:
            None
        &#34;&#34;&#34;
        current_username = self.get_user(self.sys_getuid()).data.username

        # Don&#39;t check /home/username, check /root for .shellrc
        if self.sys_getuid() == 0:
            shellrc_loc = &#34;/root/.shellrc&#34;
        else:
            shellrc_loc = f&#34;/home/{current_username}/.shellrc&#34;

        shellrc_lookup = self.fs.find(shellrc_loc)

        if shellrc_lookup.success:
            shellrc_lines = shellrc_lookup.data.read(self)

            if shellrc_lines.success:
                for line in shellrc_lines.data.split(&#34;\n&#34;):
                    if line != &#34;&#34;:
                        line = line.split()
                        # TODO: replace with execvp
                        result = self.run_command(line[0], line[1:], pipe=False)

    def save(self, output_file: str = &#34;blackhat.save&#34;) -&gt; bool:
        &#34;&#34;&#34;
        Serialize and dump the current `Computer` (and everything that&#39;s connected to it (`StandardFS`, `File`s, etc)) to a file
        Args:
            output_file (str, optional): The file to dump the contents to

        Returns:
            bool: `True` if the dump/save was successful, otherwise `False`
        &#34;&#34;&#34;
        # Temporary: Disable saving because it doesn&#39;t work anyway
        if True == False:
        # if os.getenv(&#34;DEBUGMODE&#34;) == &#34;false&#34;:
            try:
                with open(output_file, &#34;wb&#34;) as f:
                    pickle.dump(self, f, pickle.HIGHEST_PROTOCOL)
                return True
            except Exception as e:
                # TODO: Fix save bug (can&#39;t pickle `self.connection` and `self.database`)
                return False
        else:
            return True

    ##############
    # Networking #
    ##############

    def resolve_dns(self, domain: str, dns_server: Optional[str] = None) -&gt; Result:
        &#34;&#34;&#34;
        Check all DNS servers in the /etc/resolv.conf unless a `dns_server` is specified

        args:
            domain (str): The domain name to lookup
            dns_server (str, optional) The DNS server to use to lookup the domain

        Returns:
            Result: A `Result` object with the success and data flag set accordingly
        &#34;&#34;&#34;
        if dns_server:
            # We need to try to find the given dns server
            dns_servers = [dns_server]
        else:
            find_resolv_conf = self.fs.find(&#34;/etc/resolv.conf&#34;)
            dns_servers = []
            if find_resolv_conf.success:
                content = find_resolv_conf.data.content.split(&#34;\n&#34;)
                for line in content:
                    if line.startswith(&#34;nameserver &#34;):
                        dns_servers.append(line[11:])

        for server in dns_servers:
            # Establish that the server exists
            server_obj = self.parent.find_client(server, 53)
            if server_obj.success:
                packet_result = server_obj.data.main({&#34;domain&#34;: domain})

                if packet_result.success:
                    return Result(success=True, data=packet_result.data)

        return Result(success=False, message=ResultMessages.NOT_FOUND)

    ############
    # Syscalls #
    ############
    def sys_read(self, filepath: str) -&gt; Result:
        &#34;&#34;&#34;
        Try to read the content of the given `filepath`. Checks permissions

        Args:
            filepath (str): The path of the file to read

        Returns:
            Result: A `Result` object with the success flag set accordingly and the data flag containing the files
            if read was successful
        &#34;&#34;&#34;
        # Try to find the file
        find_file = self.fs.find(filepath)

        if not find_file.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        if find_file.data.is_directory():
            return Result(success=False, message=ResultMessages.IS_DIRECTORY)

        try_read_file = find_file.data.read(self)

        if not try_read_file.success:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED_READ)

        return Result(success=True, data=try_read_file.data)

    def sys_write(self, fd: Union[str, Socket], data: Union[str, dict]) -&gt; Result:
        &#34;&#34;&#34;
        Try to write to a given file descriptor. If `fd` is a file path, this function will try to write to a file
        (permission safe), however, if the fd is a `Socket`, this function will try to send the given `data` to the
        respective `Socket`&#39;s connected service (if connected).

        Args:
            fd (str or :obj:`Socket`): The filepath of the file or Socket to write to
            data (str or dict): The data to write to the file (if fd == str) or data to send to the socket (if fd == Socket)

        Returns:
            Result: A `Result` object with the success flag set accordingly
        &#34;&#34;&#34;
        if type(fd) == Socket:
            # We&#39;re &#39;writing&#39; to a network socket
            if not fd.client:
                return Result(success=False, message=ResultMessages.NOT_CONNECTED)

            if type(data) == str:
                return Result(success=False, message=ResultMessages.INVALID_ARGUMENT)

            return fd.client.main(data)
        else:
            # We&#39;re writing to a file
            # Try to find the file
            find_file = self.fs.find(fd)

            if not find_file.success:
                return Result(success=False, message=ResultMessages.NOT_FOUND)

            if find_file.data.is_directory():
                return Result(success=False, message=ResultMessages.IS_DIRECTORY)

            try_write_file = find_file.data.write(data, self)

            if not try_write_file.success:
                return Result(success=False, message=ResultMessages.NOT_ALLOWED_WRITE)

            return Result(success=True)

    def sys_chown(self, pathname: str, owner: int, group: int) -&gt; Result:
        &#34;&#34;&#34;
        Change the owner of the given `pathname` (if allowed)

        Notes:
            Only the owner or root is allowed to change the owner of a `File`/`Directory`

        Args:
            pathname (str): The file path of the `File`/`Directory` to change the owner of
            owner (int): The UID of the new owner
            group (int): The GID of the new owner

        Returns:
            Result: A `Result` object with the success flag set accordingly
        &#34;&#34;&#34;
        find_file = self.fs.find(pathname)

        if not find_file.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        file = find_file.data

        change_perms = file.change_owner(self, owner, group)

        if not change_perms.success:
            return Result(success=False, message=change_perms.message)

        return Result(success=True)

    def sys_chdir(self, pathname: str) -&gt; Result:
        &#34;&#34;&#34;
        Change the `current_dir` of the current `Session`

        Args:
            pathname (str): The file path of the directory to `cd` into

        Returns:
            Result: A `Result` object with the success flag set accordingly
        &#34;&#34;&#34;
        find_file = self.fs.find(pathname)

        if not find_file.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        # We need executable permissions to cd (???)
        check_perm = find_file.data.check_perm(&#34;execute&#34;, self)
        if not check_perm.success:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

        if find_file.data.is_file():
            return Result(success=False, message=ResultMessages.IS_FILE)

        self.sessions[-1].current_dir = find_file.data
        return Result(success=True)

    def sys_getuid(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the UID of the `Computer`&#39;s current user

        Returns:
            int: UID of the `Computers`&#39;s current user (from most recent session)
        &#34;&#34;&#34;
        if len(self.sessions) == 0:
            return 0

        return self.sessions[-1].effective_uid

    def sys_setuid(self, uid: int) -&gt; Result:
        &#34;&#34;&#34;
        Change current `Session`&#39;s effective UID to the given `UID`

        Notes:
            setuid() followed the current rules:
                * If the &#34;caller&#34; uid is root, change the uid to whatever is given
                * If the &#34;caller&#34; isn&#39;t root, BUT the setuid bit (not implement yet) is set, the UID can be set to the owner of the file
                * If the &#34;caller&#34; isn&#39;t root, and the setuid bit ISN&#39;T set, deny all changes

        Args:
            uid (int): The new UID to change to

        Returns:
            Result: A `Result` object with the success flag set accordingly
        &#34;&#34;&#34;
        # TODO: Implement a PROPER setuid
        # The way setuid should work:
        # If the &#34;caller&#34; uid is root, change the uid to whatever is given
        # If the &#34;caller&#34; isn&#39;t root, BUT the setuid bit (not implement yet) is set, the UID can be set to the owner of the file
        # If the &#34;caller&#34; isn&#39;t root, and the setuid bit ISN&#39;T set, deny all changes

        # if self.sys_getuid() == 0:
        self.sessions[-1].effective_uid = uid
        return Result(success=True)
        # else:
        #     return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    def sys_getgid(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the (primary) GID of the `Computer`&#39;s current user

        Returns:
            int: (primary) GID of the `Computers`&#39;s current user (from most recent session)
        &#34;&#34;&#34;
        current_uid = self.sys_getuid()
        result = self.database.execute(
            &#34;SELECT group_gid FROM group_membership WHERE computer_id=? AND user_uid=? AND membership_type=?&#34;,
            (self.id, current_uid, &#34;primary&#34;)).fetchone()

        if result:
            return result[0]
        else:
            # NOTE: possible exploit, but maybe we leave it here on purpose?
            # TODO: Write proof of concept exploit to exploit this exploit
            return 0

    def sys_sethostname(self, hostname: str) -&gt; Result:
        &#34;&#34;&#34;
        An easy function to update the hostname (also updates /etc/hostname)
        Args:
            hostname (str): The `Computer`&#39;s new hostname

        Returns:
            Result: A `Result` instance with the `success` flag set accordingly.
        &#34;&#34;&#34;
        # Try to find the hostname file
        if self.sys_getuid() != 0:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

        if not self.sys_stat(&#34;/etc/hostname&#34;).success:
            # Make sure we at least have the /etc/ dir so we can make /etc/hostname
            if not self.sys_stat(&#34;/etc/&#34;).success:
                return Result(success=False, message=ResultMessages.NOT_FOUND)
            # Create the /etc/hostname
            find_etc_dir = self.fs.find(&#34;/etc/&#34;)
            find_etc_dir.data.add_file(File(&#34;hostname&#34;, hostname, find_etc_dir.data, 0, 0))
        else:
            # Even though we should never get here unless we&#39;re root, I&#39;m gonna be a good boy and do this properly
            if not self.sys_write(&#34;/etc/hostname&#34;, hostname).success:
                return Result(success=False, message=ResultMessages.NOT_ALLOWED_WRITE)

        self.hostname = hostname
        return Result(success=True)

    def sys_gethostname(self) -&gt; str:
        &#34;&#34;&#34;
        Gets the current system hostname (from internal var, not /etc/hostname)

        Returns:
            str: &#34;localhost&#34; if the hostname isn&#39;t set, otherwise, the current `Computer`&#39;s hostname
        &#34;&#34;&#34;
        return &#34;localhost&#34; if not self.hostname else self.hostname

    def sys_getcwd(self) -&gt; FSBaseObject:
        &#34;&#34;&#34;
        Get current directory in the file system

        Returns:
            FSBaseObject: The  user&#39;s current directory
        &#34;&#34;&#34;
        if len(self.sessions) == 0:
            return self.fs.files
        else:
            return self.sessions[-1].current_dir

    def sys_access(self, pathname: str, mode: int) -&gt; Result:
        &#34;&#34;&#34;
        Check if the current effective UID has a given permission to the given `File`/`Directory`
        Possible modes are:
            * F_OK: File exists
            * R_OK: Read permission
            * W_OK: Write permissions
            * X_OK: Execute permission

        Args:
            pathname (str): The file path of the given `File`/`Directory` to check
            mode (int): Bitwise flags of the permissions to check

        Returns:
            Result: A `Result` object with the success flag set accordingly
        &#34;&#34;&#34;
        # We need to find the file no matter what we do, so lets just find it now
        find_file = self.fs.find(pathname)

        success = True

        if not find_file.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        file = find_file.data

        if AccessMode.R_OK in mode:
            if not file.check_perm(&#34;read&#34;, self).success:
                success = False

        if AccessMode.W_OK in mode:
            if not file.check_perm(&#34;write&#34;, self).success:
                success = False

        if AccessMode.X_OK in mode:
            if not file.check_perm(&#34;execute&#34;, self).success:
                success = False

        return Result(success=success)

    def sys_gettimeofday(self) -&gt; Result:
        &#34;&#34;&#34;
        Get the current time (host systems time)

        Returns:
            timeval: A `timeval` struct containing the current time in seconds
        &#34;&#34;&#34;
        # TODO: Add get time by timezone
        timestamp = time()
        seconds = int(timestamp)
        microseconds = int(str(timestamp - seconds).replace(&#34;0.&#34;, &#34;&#34;))

        return Result(success=True, data=timeval(seconds, microseconds))

    def sys_stat(self, path: str) -&gt; Result:
        &#34;&#34;&#34;
        Get information about a given file

        Args:
            path (str): The path of the given `File`/`Directory` to get info about

        Returns:
            Result: A `Result` object with the success flag set accordingly and the data flag containing a `stat_struct` object if successful
        &#34;&#34;&#34;
        find_file = self.fs.find(path)

        if not find_file.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        if not find_file.data.check_perm(&#34;read&#34;, self).success:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

        file = find_file.data

        is_file = file.is_file()

        # TODO: Find a less shit way to do this
        mode = [0, 0, 0]

        # Owner bit
        if &#34;owner&#34; in file.permissions[&#34;execute&#34;]:
            mode[0] += 1
        if &#34;owner&#34; in file.permissions[&#34;write&#34;]:
            mode[0] += 2
        if &#34;owner&#34; in file.permissions[&#34;read&#34;]:
            mode[0] += 4
        # Group bit
        if &#34;group&#34; in file.permissions[&#34;execute&#34;]:
            mode[1] += 1
        if &#34;group&#34; in file.permissions[&#34;write&#34;]:
            mode[1] += 2
        if &#34;group&#34; in file.permissions[&#34;read&#34;]:
            mode[1] += 4
        # Public bit
        if &#34;public&#34; in file.permissions[&#34;execute&#34;]:
            mode[2] += 1
        if &#34;public&#34; in file.permissions[&#34;write&#34;]:
            mode[2] += 2
        if &#34;public&#34; in file.permissions[&#34;read&#34;]:
            mode[2] += 4
        mode = int(&#34;&#34;.join([str(x) for x in mode]))

        nlink = 0
        uid = file.owner
        gid = file.group_owner
        size = file.size
        # TODO: Implement atime, mtime, and ctime
        atime = 0
        mtime = 0
        ctime = 0
        path = file.pwd()

        stat_result = stat_struct(is_file, mode, nlink, uid, gid, size, atime, mtime, ctime, path)

        return Result(success=True, data=stat_result)

    def sys_mkdir(self, pathname: str, mode: int) -&gt; Result:
        &#34;&#34;&#34;
        Make a directory

        Args:
            pathname (str): The path of the directory to make
            mode (int): Octal permissions of the new `Directory`

        Returns:
            Result: A `Result` object with the success flag set accordingly and the data flag containing the new `Directory` object if successful
        &#34;&#34;&#34;
        # Make sure it doesn&#39;t already exist
        find_dir = self.fs.find(pathname)

        if find_dir.success:
            return Result(success=False, message=ResultMessages.ALREADY_EXISTS)

        if &#34;/&#34; not in pathname:
            pathname = &#34;./&#34; + pathname

        # Make sure we have write permissions on the parent dir
        parent_path = &#34;/&#34;.join(pathname.split(&#34;/&#34;)[:-1])

        # Just in case
        find_parent = self.fs.find(parent_path)

        if not find_parent.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        if not find_parent.data.check_perm(&#34;write&#34;, self).success:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED_WRITE)

        new_dir = Directory(pathname.split(&#34;/&#34;)[-1], find_parent.data, owner=self.sys_getuid(),
                            group_owner=self.sys_getgid())

        add_file = find_parent.data.add_file(new_dir)

        if not self.sys_chmod(pathname, mode).success:
            # rwxr-xr-x
            new_dir.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;],
                                   &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}

        if not add_file.success:
            return Result(success=False, message=ResultMessages.GENERIC)

        return Result(success=True, data=new_dir)

    def sys_chmod(self, pathname: str, mode: int) -&gt; Result:
        &#34;&#34;&#34;
        Change the permission mode of a `File`/`Directory`

        Args:
            pathname (str): File path of the `File`/`Directory` to change mode of
            mode (int): Octal permissions of the given pathname

        Returns:
            Result: A `Result` instance with the `success` flag set accordingly.
        &#34;&#34;&#34;
        find_file = self.fs.find(pathname)

        if not find_file.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        # Only the owner can change chmod permissions
        if self.sys_getuid() not in [find_file.data.owner, 0]:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

        raw_mode = str(bin(mode)).replace(&#34;0b&#34;, &#34;&#34;)
        raw_mode = &#34;0&#34; * (9 - len(raw_mode)) + raw_mode

        chmod_bits = []
        for x in range(0, len(raw_mode), 3):
            chmod_bits.append(raw_mode[x: x + 3])

        perms = {&#34;read&#34;: [], &#34;write&#34;: [], &#34;execute&#34;: []}

        for x in range(3):
            bits = chmod_bits[x]
            scope = [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;][x]

            for y in range(3):
                bit = bits[y]
                perm_scope = [&#34;read&#34;, &#34;write&#34;, &#34;execute&#34;][y]

                if bit == &#34;1&#34;:
                    perms[perm_scope].append(scope)

        find_file.data.permissions = perms
        find_file.data.handle_event(&#34;change_perm&#34;)
        return Result(success=True)

    def sys_creat(self, pathname: str, mode: int) -&gt; Result:
        &#34;&#34;&#34;
        Make a file

        Args:
            pathname (str): The path of the file to make
            mode (int): Octal permissions of the new `File`

        Returns:
            Result: A `Result` object with the success flag set accordingly
        &#34;&#34;&#34;
        # Try to resolve the path
        find_file = self.fs.find(pathname)

        if find_file.success:
            return Result(success=False, message=ResultMessages.ALREADY_EXISTS)

        if &#34;/&#34; not in pathname:
            pathname = &#34;./&#34; + pathname

        # Make sure we have write permissions on the parent dir
        parent_path = &#34;/&#34;.join(pathname.split(&#34;/&#34;)[:-1])

        # Just in case
        find_parent = self.fs.find(parent_path)

        # Sanity check
        if not find_parent.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        # We need write permissions on the parent
        if not find_parent.data.check_perm(&#34;write&#34;, self).success:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

        new_file = File(pathname.split(&#34;/&#34;)[-1], &#34;&#34;, find_parent.data, self.sys_getuid(), self.sys_getgid())
        self.sys_chmod(pathname, mode)
        find_parent.data.add_file(new_file)

        return Result(success=True)

    def sys_rename(self, oldpath: str, newpath: str) -&gt; Result:
        &#34;&#34;&#34;
        Rename or move a file or directory

        Args:
            oldpath (str): The original file/directory path to rename
            newpath (str): The new path of the file/directory

        Returns:
            Result: A `Result` object with the success flag set accordingly
        &#34;&#34;&#34;
        find_old = self.fs.find(oldpath)

        if not find_old.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        if not find_old.data.check_owner(self).success or self.sys_getuid() != 0:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

        copy_result = copy(self, oldpath, newpath)

        if not copy_result.success:
            return copy_result

        # Rename means move, so delete the original
        delete_result = self.fs.find(oldpath).data.delete(self)

        if not delete_result.success:
            return delete_result

        return Result(success=True)

    def sys_exit(self, force=False) -&gt; None:
        &#34;&#34;&#34;
        Exit a session and return to the previous session. If a previous computer exists and no sessions exist,
        return to the previous computer. If no previous computer exists, exit the game.

        Args:
            force (bool): If a prev computer exists, exit to previous computer regardless of previous sessions. If no previous computers exist, exit the game.

        Returns:
            None
        &#34;&#34;&#34;
        if force:
            if len(self.shell.computers) == 1:
                self.save()
                exit(0)
            else:
                self.sessions = []
                self.shell.computers.pop()
        else:
            if len(self.shell.computers) == 1:
                if len(self.sessions) == 1:
                    self.save()
                    exit(0)
                else:
                    self.sessions.pop()
            else:
                self.shell.computers.pop()

    def sys_reboot(self, mode: int) -&gt; Result:
        &#34;&#34;&#34;
        Simulate a computer reboot. Clear all sessions and re-initialize the machine

        Args:
            mode (int: Bitwise flags of the operation to take

        Returns:
            Result: A `Result` object with the success flag set accordingly
        &#34;&#34;&#34;
        if self.sys_getuid() != 0:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

        if RebootMode.LINUX_REBOOT_CMD_POWER_OFF in mode:
            self.sys_exit(True)

        if RebootMode.LINUX_REBOOT_CMD_RESTART in mode:
            print(f&#34;Rebooting...&#34;)
            sleep(1)
            if system() == &#34;Windows&#34;:
                real_syscall(&#34;cls&#34;)
            else:
                real_syscall(&#34;clear&#34;)
            self.run_command(&#34;clear&#34;, [], pipe=True)
            self.init()
            while len(self.sessions) != 1:
                self.sys_exit()

        return Result(success=True)

    def sys_rmdir(self, pathname: str) -&gt; Result:
        &#34;&#34;&#34;
        Remove an empty directory

        Args:
            pathname (str): The file path of the empty `Directory` to remove

        Returns:
            Result: A `Result` object with the success flag set accordingly
        &#34;&#34;&#34;
        find_result = self.fs.find(pathname)

        if not find_result.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        if find_result.data.is_file():
            return Result(success=False, message=ResultMessages.IS_FILE)

        if len(find_result.data.files) &gt; 0:
            return Result(success=False, message=ResultMessages.NOT_EMPTY)

        delete_response = find_result.data.delete(self)

        if not delete_response.success:
            return delete_response

        return Result(success=True)

    def sys_execv(self, pathname: str, argv: list) -&gt; Result:
        &#34;&#34;&#34;
        Execute a file

        Args:
            pathname (str): The path name of the binary to execute
            argv (list): A list of arguments to pass to the binary

        Returns:
            Result: A `Result` arguments containing the output from the binary
        &#34;&#34;&#34;
        find_result = self.fs.find(pathname)

        if not find_result.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        if not find_result.data.check_perm(&#34;execute&#34;, self).success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        return self.run_command(pathname.split(&#34;/&#34;)[-1], argv, False)

    def sys_execvp(self, command: str, argv: list) -&gt; Result:
        &#34;&#34;&#34;
        Execute a command using the PATH rather than the full binary path. Does exactly what the system shell does.

        Args:
            command (str): The command to run
            argv (list): A list of arguments to pass to the binary

        Returns:
            Result: A `Result` arguments containing the output from the binary
        &#34;&#34;&#34;
        return self.run_command(command, argv, False)

    def sys_unlink(self, pathname: str) -&gt; Result:
        &#34;&#34;&#34;
        Removes a link to a file. If there are no links left, the file is removed.

        Args:
            pathname (str): The file path of the `File` to unlink

        Returns:
            Result: A `Result` arguments containing the output from the binary

        &#34;&#34;&#34;
        find_result = self.fs.find(pathname)

        if not find_result.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        if not find_result.data.check_perm(&#34;write&#34;, self) or not find_result.data.check_perm(&#34;execute&#34;, self):
            return Result(success=False, message=ResultMessages.NOT_ALLOWED)

        delete_result = find_result.data.delete(self)

        if not delete_result.success:
            return delete_result

        return Result(success=True)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="client.blackhat.computer.Router" href="#client.blackhat.computer.Router">Router</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="client.blackhat.computer.Computer.add_group"><code class="name flex">
<span>def <span class="ident">add_group</span></span>(<span>self, name:str, gid:Optional[int]=None) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Add a new group to the system.
This function also generates the GID for the new group (unless manually specified)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name for the new group</dd>
<dt><strong><code>gid</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The GID of the new user</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> instance with the <code>success</code> flag set accordingly. The <code>data</code> flag contains the GID if successful.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_group(self, name: str, gid: Optional[int] = None) -&gt; Result:
    &#34;&#34;&#34;
    Add a new group to the system.
    This function also generates the GID for the new group (unless manually specified)

    Args:
        name (str): The name for the new group
        gid (int, optional): The GID of the new user

    Returns:
        Result: A `Result` instance with the `success` flag set accordingly. The `data` flag contains the GID if successful.
    &#34;&#34;&#34;
    if self.get_group(name=name).success:
        return Result(success=False, message=ResultMessages.ALREADY_EXISTS)

    if gid:
        # Check if a group with the given GID already exists
        if self.get_group(gid=gid, name=name).success:
            return Result(success=False, message=ResultMessages.ALREADY_EXISTS)
        else:
            next_gid = gid
    else:
        # Auto-generate the GID (depending on the situation)
        groups = self.get_all_groups().data
        if len(groups) == 0:
            next_gid = 0
        else:
            # Get the GID from the previously created group
            last_gid = groups[-1].gid
            if last_gid == 0:
                next_gid = 1000
            else:
                next_gid = last_gid + 1

    # Create the new group and commit
    self.database.execute(&#34;INSERT INTO blackhat_group (gid, name, computer_id) VALUES (?, ?, ?)&#34;,
                          (next_gid, name, self.id))
    self.connection.commit()

    return Result(success=True, data=next_gid)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.add_user"><code class="name flex">
<span>def <span class="ident">add_user</span></span>(<span>self, username:str, password:str, uid:Optional[int]=None, plaintext=True) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Add a new user to the system.
This function also generates the UID for the new user (unless manually specified)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>username</code></strong> :&ensp;<code>str</code></dt>
<dd>The username for the new user</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>str</code></dt>
<dd>The plaintext password for the new user</dd>
<dt><strong><code>uid</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The UID of the new user
plaintext (bool): If the given <code>new_password</code> is plain text or an MD5 hash</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> instance with the <code>success</code> flag set accordingly. The <code>data</code> flag contains the new users UID if successful.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_user(self, username: str, password: str, uid: Optional[int] = None, plaintext=True) -&gt; Result:
    &#34;&#34;&#34;
    Add a new user to the system.
    This function also generates the UID for the new user (unless manually specified)

    Args:
        username (str): The username for the new user
        password (str): The plaintext password for the new user
        uid (int, optional): The UID of the new user
                    plaintext (bool): If the given `new_password` is plain text or an MD5 hash

    Returns:
        Result: A `Result` instance with the `success` flag set accordingly. The `data` flag contains the new users UID if successful.
    &#34;&#34;&#34;
    if self.get_user(username=username).success:
        return Result(success=False, message=ResultMessages.ALREADY_EXISTS)

    # new_user = User(username)
    # new_user.set_password(password)

    # Manually specific UID
    if uid:
        # Check if a user with the given UID already exists
        if self.get_user(uid=uid).success:
            return Result(success=False, message=ResultMessages.ALREADY_EXISTS)
        else:
            next_uid = uid
    # Auto-generate the UID (depending on the situation)
    else:
        # We&#39;re creating our root user, there isn&#39;t going to be a previous UID
        users = self.get_all_users().data
        if len(users) == 0:
            next_uid = 0
        else:
            # Get the UID from the previously created user
            last_uid = users[-1].uid
            if last_uid == 0:
                next_uid = 1000
            else:
                next_uid = last_uid + 1
                user_with_next_uid = self.get_user(uid=next_uid)

                while user_with_next_uid.success:
                    next_uid += 1
                    user_with_next_uid = self.get_user(uid=next_uid)

    # Hash the password before saving to the database
    hashed_password = md5(password.encode()).hexdigest() if plaintext else password

    # Create the new user
    self.database.execute(&#34;INSERT INTO blackhat_user (uid, username, password, computer_id) VALUES (?, ?, ?, ?)&#34;,
                          (next_uid, username, hashed_password, self.id))
    self.connection.commit()

    return Result(success=True, data=next_uid)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.add_user_to_group"><code class="name flex">
<span>def <span class="ident">add_user_to_group</span></span>(<span>self, uid:int, gid:int, membership_type:Literal['primary','secondary']='secondary') ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Add a user to a group (by uid and gid)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>uid</code></strong> :&ensp;<code>int</code></dt>
<dd>The UID of the user</dd>
<dt><strong><code>gid</code></strong> :&ensp;<code>int</code></dt>
<dd>The GID of the group to add the user to</dd>
<dt><strong><code>membership_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of group relationship (primary, secondary)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> object with the <code>success</code> flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_user_to_group(self, uid: int, gid: int,
                      membership_type: Literal[&#34;primary&#34;, &#34;secondary&#34;] = &#34;secondary&#34;) -&gt; Result:
    &#34;&#34;&#34;
    Add a user to a group (by uid and gid)

    Args:
        uid (int): The UID of the user
        gid (int): The GID of the group to add the user to
        membership_type (str): The type of group relationship (primary, secondary)

    Returns:
        Result: A `Result` object with the `success` flag set accordingly
    &#34;&#34;&#34;
    # Confirm that both user and group exists
    if self.get_user(uid=uid).success and self.get_group(gid=gid).success:
        self.database.execute(
            &#34;INSERT INTO group_membership (computer_id, user_uid, group_gid, membership_type) VALUES (?, ?, ?, ?)&#34;,
            (self.id, uid, gid, membership_type))
        self.connection.commit()
        return Result(success=True)
    else:
        return Result(success=False, message=ResultMessages.NOT_FOUND)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.change_user_password"><code class="name flex">
<span>def <span class="ident">change_user_password</span></span>(<span>self, uid:int, new_password:str, plaintext=True) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Change the password of the user by uid</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>uid</code></strong> :&ensp;<code>int</code></dt>
<dd>The UID of the <code>User</code> to change the password of</dd>
<dt><strong><code>new_password</code></strong> :&ensp;<code>str</code></dt>
<dd>The MD5 hash of the password</dd>
<dt><strong><code>plaintext</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the given <code>new_password</code> is plain text or an MD5 hash</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> with the <code>success</code> flag set accordingly.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_user_password(self, uid: int, new_password: str, plaintext=True) -&gt; Result:
    &#34;&#34;&#34;
    Change the password of the user by uid

    Args:
        uid (int): The UID of the `User` to change the password of
        new_password (str): The MD5 hash of the password
        plaintext (bool): If the given `new_password` is plain text or an MD5 hash

    Returns:
        Result: A `Result` with the `success` flag set accordingly.
    &#34;&#34;&#34;
    # Double check that the user with the given UID exists
    lookup_user = self.get_user(uid=uid)
    if not lookup_user.success:
        return Result(success=False, message=ResultMessages.NOT_FOUND)

    # Hash the plain text password
    password_hash = md5(new_password.encode()).hexdigest() if plaintext else new_password

    # Update the password in the database
    result = self.database.execute(&#34;UPDATE blackhat_user SET password=? WHERE uid=? AND computer_id=?&#34;,
                                   (password_hash, uid, self.id))
    self.connection.commit()
    return Result(success=True)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.change_user_uid"><code class="name flex">
<span>def <span class="ident">change_user_uid</span></span>(<span>self, uid:int, new_uid:int) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Change the uid of the user by uid</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>uid</code></strong> :&ensp;<code>int</code></dt>
<dd>The UID of the <code>User</code> to change the uid of</dd>
<dt><strong><code>new_uid</code></strong> :&ensp;<code>int</code></dt>
<dd>The new uid of the given user</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> with the <code>success</code> flag set accordingly.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_user_uid(self, uid: int, new_uid: int) -&gt; Result:
    &#34;&#34;&#34;
    Change the uid of the user by uid

    Args:
        uid (int): The UID of the `User` to change the uid of
        new_uid (int): The new uid of the given user

    Returns:
        Result: A `Result` with the `success` flag set accordingly.
    &#34;&#34;&#34;
    # Double check that the user with the given UID exists
    lookup_user = self.get_user(uid=uid)
    if not lookup_user.success:
        return Result(success=False, message=ResultMessages.NOT_FOUND)

    # Make sure that no other user has the given `new_uid`
    lookup_user = self.get_user(uid=new_uid)
    if lookup_user.success:
        return Result(success=False, message=ResultMessages.ALREADY_EXISTS)

    # Update the uid in the database
    result = self.database.execute(&#34;UPDATE blackhat_user SET uid=? WHERE uid=? AND computer_id=?&#34;,
                                   (new_uid, uid, self.id))
    self.connection.commit()

    # We need to update the UID of all sessions that this user has
    for session in self.sessions:
        if session.real_uid == uid:
            session.real_uid = new_uid

        if session.effective_uid == uid:
            session.effective_uid = new_uid

    # We also need to update the UID in the group membership records
    self.database.execute(&#34;UPDATE group_membership SET user_uid=? WHERE user_uid=? AND computer_id=?&#34;,
                          (new_uid, uid, self.id))

    return Result(success=True)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.create_root_user"><code class="name flex">
<span>def <span class="ident">create_root_user</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Since the root user is different from "standard" users, and it must exist in any given system, it is manually
created when the <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> is first initialized.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_root_user(self) -&gt; None:
    &#34;&#34;&#34;
    Since the root user is different from &#34;standard&#34; users, and it must exist in any given system, it is manually
    created when the `Computer` is first initialized.

    Returns:
        None
    &#34;&#34;&#34;
    # Add the root user with a random password
    # self.add_user(&#34;root&#34;, &#39;&#39;.join([choice(ascii_uppercase + digits) for _ in range(16)]))
    self.add_user(&#34;root&#34;, &#34;password&#34;, uid=0)
    # Create the root group
    self.add_group(&#39;root&#39;, 0)

    # Add root to the root group
    self.add_user_to_group(0, 0, membership_type=&#34;primary&#34;)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.delete_group"><code class="name flex">
<span>def <span class="ident">delete_group</span></span>(<span>self, name:str) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a group from the system (by name)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the group to delete</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> instance with the <code>success</code> flag set accordingly.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_group(self, name: str) -&gt; Result:
    &#34;&#34;&#34;
    Deletes a group from the system (by name)

    Args:
        name (str): The name of the group to delete

    Returns:
        Result: A `Result` instance with the `success` flag set accordingly.
    &#34;&#34;&#34;
    if self.get_group(name=name).success:
        self.database.execute(&#34;DELETE FROM blackhat_group WHERE computer_id=? and name=?&#34;, (self.id, name))
        self.connection.commit()
        return Result(success=True)

    return Result(success=False, message=ResultMessages.NOT_FOUND)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.delete_user"><code class="name flex">
<span>def <span class="ident">delete_user</span></span>(<span>self, username:str) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a user from the system (by username)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>username</code></strong> :&ensp;<code>str</code></dt>
<dd>The username of the user to delete</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> instance with the <code>success</code> flag set accordingly.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_user(self, username: str) -&gt; Result:
    &#34;&#34;&#34;
    Deletes a user from the system (by username)

    Args:
        username (str): The username of the user to delete

    Returns:
        Result: A `Result` instance with the `success` flag set accordingly.
    &#34;&#34;&#34;
    if self.get_user(username=username).success:
        self.database.execute(&#34;DELETE FROM blackhat_user WHERE computer_id=? and username=?&#34;, (self.id, username))
        self.connection.commit()
        return Result(success=True)

    return Result(success=False, message=ResultMessages.NOT_FOUND)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.get_all_groups"><code class="name flex">
<span>def <span class="ident">get_all_groups</span></span>(<span>self) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get all groups that exist in the given system in the given format:</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> with the <code>data</code> flag containing the array of <code>Group</code>s</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_groups(self) -&gt; Result:
    &#34;&#34;&#34;
    Get all groups that exist in the given system in the given format:

    Returns:
        Result: A `Result` with the `data` flag containing the array of `Group`s
    &#34;&#34;&#34;
    all_groups = self.database.execute(&#34;SELECT * FROM blackhat_group WHERE computer_id=?&#34;,
                                       (self.id,)).fetchall()

    clean_groups = []

    for group in all_groups:
        clean_groups.append(Group(gid=group[1], name=group[2]))
    return Result(success=True, data=clean_groups)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.get_all_users"><code class="name flex">
<span>def <span class="ident">get_all_users</span></span>(<span>self) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get all users that exist in the given system in the given format:</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> with the <code>data</code> flag containing the array of <code>User</code>s</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_users(self) -&gt; Result:
    &#34;&#34;&#34;
    Get all users that exist in the given system in the given format:

    Returns:
        Result: A `Result` with the `data` flag containing the array of `User`s
    &#34;&#34;&#34;
    all_users = self.database.execute(&#34;SELECT * FROM blackhat_user WHERE computer_id=?&#34;,
                                      (self.id,)).fetchall()

    clean_users = []

    for user in all_users:
        clean_users.append(
            User(uid=user[1], username=user[2], password=user[3], full_name=user[4], room_number=user[5],
                 work_phone=user[6], home_phone=user[7], other=user[8]))
    return Result(success=True, data=clean_users)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.get_env"><code class="name flex">
<span>def <span class="ident">get_env</span></span>(<span>self, key) >Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get an environment variable from the current session</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The env var to retrieve</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code>, optional</dt>
<dd>The matching value of the given key if found, otherwise, None</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_env(self, key) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Get an environment variable from the current session

    Args:
        key (str): The env var to retrieve

    Returns:
        str, optional: The matching value of the given key if found, otherwise, None
    &#34;&#34;&#34;
    if len(self.sessions) == 0:
        return None
    else:
        return self.sessions[-1].env.get(key)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.get_group"><code class="name flex">
<span>def <span class="ident">get_group</span></span>(<span>self, gid:Optional[int]=None, name:Optional[str]=None) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Find a group in the database by GID or name or both</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gid</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The GID of the group to find</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the group to find</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> with the <code>success</code> flag set accordingly. The <code>data</code> flag contains the group dict if found</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_group(self, gid: Optional[int] = None, name: Optional[str] = None) -&gt; Result:
    &#34;&#34;&#34;
    Find a group in the database by GID or name or both
    Args:
        gid (int, optional): The GID of the group to find
        name (str, optional): The name of the group to find

    Returns:
        Result: A `Result` with the `success` flag set accordingly. The `data` flag contains the group dict if found
    &#34;&#34;&#34;
    if gid is None and name is None:
        return Result(success=False, message=ResultMessages.NOT_FOUND)
    # We&#39;re looking by name AND gid
    elif gid is not None and name is not None:
        result = self.database.execute(&#34;SELECT * FROM blackhat_group WHERE (gid=? AND name=?) AND computer_id=?&#34;,
                                       (gid, name, self.id)).fetchone()
    else:
        result = self.database.execute(&#34;SELECT * FROM blackhat_group WHERE (gid=? OR name=?) AND computer_id=?&#34;,
                                       (gid, name, self.id)).fetchone()

    if not result:
        return Result(success=False, message=ResultMessages.NOT_FOUND)

    return Result(success=True, data=Group(gid=result[1], name=result[2]))</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.get_user"><code class="name flex">
<span>def <span class="ident">get_user</span></span>(<span>self, uid:Optional[int]=None, username:Optional[str]=None) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Find a user in the database by UID or username</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>uid</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The UID of the user to find</dd>
<dt><strong><code>username</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The username of the user to find</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> with the <code>success</code> flag set accordingly. The <code>data</code> flag contains the user dict if found</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user(self, uid: Optional[int] = None, username: Optional[str] = None) -&gt; Result:
    &#34;&#34;&#34;
    Find a user in the database by UID or username
    Args:
        uid (int, optional): The UID of the user to find
        username (str, optional): The username of the user to find

    Returns:
        Result: A `Result` with the `success` flag set accordingly. The `data` flag contains the user dict if found
    &#34;&#34;&#34;
    if uid is None and username is None:
        return Result(success=False, message=ResultMessages.NOT_FOUND)
    else:
        result = self.database.execute(&#34;SELECT * FROM blackhat_user WHERE (uid=? OR username=?) AND computer_id=?&#34;,
                                       (uid, username, self.id)).fetchone()
        if not result:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        return Result(success=True,
                      data=User(uid=result[1], username=result[2], password=result[3], full_name=result[4],
                                room_number=result[5],
                                work_phone=result[6], home_phone=result[7], other=result[8]))</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.get_user_groups"><code class="name flex">
<span>def <span class="ident">get_user_groups</span></span>(<span>self, uid:int) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get the list of <code>Group</code> GID's that the <code>User</code> belongs to (by UID)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>uid</code></strong> :&ensp;<code>int</code></dt>
<dd>The UID of the user to lookup</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> with the <code>data</code> flag containing a list of GIDs</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_groups(self, uid: int) -&gt; Result:
    &#34;&#34;&#34;
    Get the list of `Group` GID&#39;s that the `User` belongs to (by UID)

    Args:
        uid (int): The UID of the user to lookup

    Returns:
        Result: A `Result` with the `data` flag containing a list of GIDs
    &#34;&#34;&#34;
    # Double check if the user exists
    if not self.get_user(uid=uid).success:
        return Result(success=False, message=ResultMessages.NOT_FOUND)
    else:
        # Ask the database for the GIDs
        result = self.database.execute(&#34;SELECT group_gid FROM group_membership WHERE computer_id=? and user_uid=?;&#34;,
                                       (self.id, uid)).fetchall()
        return Result(success=True, data=[x[0] for x in result])</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.get_user_primary_group"><code class="name flex">
<span>def <span class="ident">get_user_primary_group</span></span>(<span>self, uid:int) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get the <code>Group</code> GID's that is the <code>User</code>s primary <code>Group</code> (by UID)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>uid</code></strong> :&ensp;<code>int</code></dt>
<dd>The UID of the user to lookup</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> with the <code>data</code> flag containing a list of GIDs</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_primary_group(self, uid: int) -&gt; Result:
    &#34;&#34;&#34;
    Get the `Group` GID&#39;s that is the `User`s primary `Group` (by UID)

    Args:
        uid (int): The UID of the user to lookup

    Returns:
        Result: A `Result` with the `data` flag containing a list of GIDs
    &#34;&#34;&#34;
    # Double check if the user exists
    if not self.get_user(uid=uid).success:
        return Result(success=False, message=ResultMessages.NOT_FOUND)
    else:
        # Ask the database for the GIDs
        result = self.database.execute(
            &#34;SELECT group_gid FROM group_membership WHERE computer_id=? and user_uid=? and membership_type=?;&#34;,
            (self.id, uid, &#34;primary&#34;)).fetchone()
        return Result(success=True, data=[x for x in result])</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.get_users_in_group"><code class="name flex">
<span>def <span class="ident">get_users_in_group</span></span>(<span>self, gid:int) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get a list of user UIDs that are part of the given groups GID</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gid</code></strong> :&ensp;<code>int</code></dt>
<dd>The GID of the group to search</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> with the <code>data</code> flag containing a list of UIDs</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_users_in_group(self, gid: int) -&gt; Result:
    &#34;&#34;&#34;
    Get a list of user UIDs that are part of the given groups GID

    Args:
        gid (int): The GID of the group to search

    Returns:
        Result: A `Result` with the `data` flag containing a list of UIDs
    &#34;&#34;&#34;
    # Double check if the group exists
    if not self.get_group(gid=gid).success:
        return Result(success=False, message=ResultMessages.NOT_FOUND)
    # Ask the database for the UIDs
    result = self.database.execute(
        &#34;SELECT uid FROM blackhat_user WHERE computer_id=? AND uid in (SELECT user_uid FROM group_membership WHERE computer_id=? AND group_gid=?)&#34;,
        (self.id, self.id, gid)).fetchall()

    return Result(success=True, data=[x for x in result])</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Functions ran when a computer is booted (pre file-system setup/pre root user creation)</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init(self) -&gt; None:
    &#34;&#34;&#34;
    Functions ran when a computer is booted (pre file-system setup/pre root user creation)

    Returns:
        None
    &#34;&#34;&#34;
    self.boot_time = datetime.now()
    # Try to setup the user, group, and group membership tables
    init_tables_file = open(&#34;blackhat/database/init_tables.sql&#34;)
    init_tables = init_tables_file.read()
    self.database.executescript(init_tables)

    # Check if the computer we&#39;re initializing already exists in the database (we&#39;re loading an existing save)
    result = self.database.execute(&#34;SELECT * FROM computer WHERE id=?&#34;, (self.id,)).fetchall()

    if len(result) == 0:
        # We&#39;re starting a new save, lets save a copy of this computers id in the database, along with create the root user
        self.database.execute(&#34;INSERT INTO computer VALUES (?)&#34;, (self.id,))
        self.create_root_user()
        self.connection.commit()

    init_tables_file.close()</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.post_fs_init"><code class="name flex">
<span>def <span class="ident">post_fs_init</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Function ran after the file system and root user were initialized</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_fs_init(self) -&gt; None:
    &#34;&#34;&#34;
    Function ran after the file system and root user were initialized

    Returns:
        None
    &#34;&#34;&#34;
    self.sync_hostname()
    self.sync_user_and_group_files()</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.remove_user_from_group"><code class="name flex">
<span>def <span class="ident">remove_user_from_group</span></span>(<span>self, uid:int, gid:int) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Remove a user from a group (by uid and gid)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>uid</code></strong> :&ensp;<code>int</code></dt>
<dd>The UID of the user</dd>
<dt><strong><code>gid</code></strong> :&ensp;<code>int</code></dt>
<dd>The GID of the group to remove the user from</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> object with the <code>success</code> flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_user_from_group(self, uid: int, gid: int) -&gt; Result:
    &#34;&#34;&#34;
    Remove a user from a group (by uid and gid)

    Args:
        uid (int): The UID of the user
        gid (int): The GID of the group to remove the user from

    Returns:
        Result: A `Result` object with the `success` flag set accordingly
    &#34;&#34;&#34;
    # Confirm that both user and group exists
    if self.get_user(uid=uid).success and self.get_group(gid=gid).success:
        self.database.execute(&#34;DELETE FROM group_membership WHERE computer_id=? AND user_uid=? AND group_gid=?&#34;,
                              (self.id, uid, gid))
        self.connection.commit()
        return Result(success=True)
    else:
        return Result(success=False, message=ResultMessages.NOT_FOUND)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.resolve_dns"><code class="name flex">
<span>def <span class="ident">resolve_dns</span></span>(<span>self, domain:str, dns_server:Optional[str]=None) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Check all DNS servers in the /etc/resolv.conf unless a <code>dns_server</code> is specified</p>
<p>args:
domain (str): The domain name to lookup
dns_server (str, optional) The DNS server to use to lookup the domain</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> object with the success and data flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_dns(self, domain: str, dns_server: Optional[str] = None) -&gt; Result:
    &#34;&#34;&#34;
    Check all DNS servers in the /etc/resolv.conf unless a `dns_server` is specified

    args:
        domain (str): The domain name to lookup
        dns_server (str, optional) The DNS server to use to lookup the domain

    Returns:
        Result: A `Result` object with the success and data flag set accordingly
    &#34;&#34;&#34;
    if dns_server:
        # We need to try to find the given dns server
        dns_servers = [dns_server]
    else:
        find_resolv_conf = self.fs.find(&#34;/etc/resolv.conf&#34;)
        dns_servers = []
        if find_resolv_conf.success:
            content = find_resolv_conf.data.content.split(&#34;\n&#34;)
            for line in content:
                if line.startswith(&#34;nameserver &#34;):
                    dns_servers.append(line[11:])

    for server in dns_servers:
        # Establish that the server exists
        server_obj = self.parent.find_client(server, 53)
        if server_obj.success:
            packet_result = server_obj.data.main({&#34;domain&#34;: domain})

            if packet_result.success:
                return Result(success=True, data=packet_result.data)

    return Result(success=False, message=ResultMessages.NOT_FOUND)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.run_command"><code class="name flex">
<span>def <span class="ident">run_command</span></span>(<span>self, command:str, args:Union[str,List[str],NoneType], pipe:bool) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Runs a system binary or an external binary</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong> :&ensp;<code>str</code></dt>
<dd>The command or binary to run</dd>
<dt><strong><code>args</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of arguments passed to the command or binary</dd>
<dt><strong><code>pipe</code></strong> :&ensp;<code>bool</code></dt>
<dd>If a pipe was used (used for routing input/output)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> object that contains a success status and some response data (changed on a case-by-case basis)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_command(self, command: str, args: Union[str, List[str], None], pipe: bool) -&gt; Result:
    &#34;&#34;&#34;
    Runs a system binary or an external binary
    Args:
        command (str): The command or binary to run
        args (list): A list of arguments passed to the command or binary
        pipe (bool): If a pipe was used (used for routing input/output)
    Returns:
        SysCallStatus: A `SysCallStatus` object that contains a success status and some response data (changed on a case-by-case basis)
    &#34;&#34;&#34;
    # The way that the path works is that if there are 2 binaries with the same name in 2 different directories,
    # The one that matches first in the path gets run
    # For example, if ls is in /etc/ and in /bin/ and the path is PATH=/home:/bin:/etc, the one in bin will run
    # For example, if ls is in /etc/ and in /bin/ and the path is PATH=/home:/etc:/bin, the one in etc will run
    self.update_libs()
    try:
        bin_dirs_text = self.sessions[-1].env.get(&#34;PATH&#34;).split(&#34;:&#34;)
        bin_dirs = []

        for dir in bin_dirs_text:
            find_dir = self.fs.find(dir)
            if find_dir.success:
                bin_dirs.append(find_dir.data)
    except AttributeError:
        find_bin = self.fs.find(&#34;/bin&#34;)
        if find_bin.success:
            bin_dirs = [find_bin.data]
        else:
            bin_dirs = []

    if len(bin_dirs) == 0:
        print(f&#34;{command}: command not found&#34;)
        return Result(success=False, message=ResultMessages.NOT_FOUND)

    exists = False

    for dir in bin_dirs:
        if command in list(dir.files.keys()):
            to_run = True
            break
    else:
        print(f&#34;{command}: command not found&#34;)
        return Result(success=False, message=ResultMessages.NOT_FOUND)

    try:
        module = importlib.import_module(f&#34;blackhat.bin.{command}&#34;)

    except ImportError:
        try:
            module = importlib.import_module(f&#34;blackhat.bin.installable.{command}&#34;)
        except ImportError:
            print(f&#34;There was an error when running command: {command}&#34;)
            return Result(success=False, message=ResultMessages.GENERIC)

    try:
        response = module.main(args, pipe)

    except Exception as e:
        import traceback
        traceback.print_exc()
        print(f&#34;{command}: Segmentation violation&#34;)
        return Result(success=False, message=ResultMessages.GENERIC)

    self.sessions[-1].effective_uid = self.sessions[-1].real_uid
    if os.getenv(&#34;DEBUGMODE&#34;) == &#34;false&#34;:
        self.save()

    return response</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.run_current_user_shellrc"><code class="name flex">
<span>def <span class="ident">run_current_user_shellrc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the .shellrc file in the current user's home folder (/home/<USERNAME>/.shellrc)
The ".shellrc" file is replicating the behavior of .bashrc/.bash_profile/.zshrc (since we're not replicating one specific piece of software)</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_current_user_shellrc(self):
    &#34;&#34;&#34;
    Run the .shellrc file in the current user&#39;s home folder (/home/&lt;USERNAME&gt;/.shellrc)
    The &#34;.shellrc&#34; file is replicating the behavior of .bashrc/.bash_profile/.zshrc (since we&#39;re not replicating one specific piece of software)

    Returns:
        None
    &#34;&#34;&#34;
    current_username = self.get_user(self.sys_getuid()).data.username

    # Don&#39;t check /home/username, check /root for .shellrc
    if self.sys_getuid() == 0:
        shellrc_loc = &#34;/root/.shellrc&#34;
    else:
        shellrc_loc = f&#34;/home/{current_username}/.shellrc&#34;

    shellrc_lookup = self.fs.find(shellrc_loc)

    if shellrc_lookup.success:
        shellrc_lines = shellrc_lookup.data.read(self)

        if shellrc_lines.success:
            for line in shellrc_lines.data.split(&#34;\n&#34;):
                if line != &#34;&#34;:
                    line = line.split()
                    # TODO: replace with execvp
                    result = self.run_command(line[0], line[1:], pipe=False)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, output_file:str='blackhat.save') >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize and dump the current <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> (and everything that's connected to it (<code>StandardFS</code>, <code>File</code>s, etc)) to a file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>output_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The file to dump the contents to</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if the dump/save was successful, otherwise <code>False</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, output_file: str = &#34;blackhat.save&#34;) -&gt; bool:
    &#34;&#34;&#34;
    Serialize and dump the current `Computer` (and everything that&#39;s connected to it (`StandardFS`, `File`s, etc)) to a file
    Args:
        output_file (str, optional): The file to dump the contents to

    Returns:
        bool: `True` if the dump/save was successful, otherwise `False`
    &#34;&#34;&#34;
    # Temporary: Disable saving because it doesn&#39;t work anyway
    if True == False:
    # if os.getenv(&#34;DEBUGMODE&#34;) == &#34;false&#34;:
        try:
            with open(output_file, &#34;wb&#34;) as f:
                pickle.dump(self, f, pickle.HIGHEST_PROTOCOL)
            return True
        except Exception as e:
            # TODO: Fix save bug (can&#39;t pickle `self.connection` and `self.database`)
            return False
    else:
        return True</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.set_env"><code class="name flex">
<span>def <span class="ident">set_env</span></span>(<span>self, key:str, value:str) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Set an environment variable to the current session</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The env var to set</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>The value of the new var to set</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> object with the success flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_env(self, key: str, value: str) -&gt; Result:
    &#34;&#34;&#34;
    Set an environment variable to the current session

    Args:
        key (str): The env var to set
        value (str): The value of the new var to set

    Returns:
        Result: A `Result` object with the success flag set accordingly
    &#34;&#34;&#34;
    if len(self.sessions) == 0:
        return Result(success=False, message=ResultMessages.GENERIC)

    self.sessions[-1].env[key] = value
    return Result(success=True)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sync_hostname"><code class="name flex">
<span>def <span class="ident">sync_hostname</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Reads /etc/hostname and sets the system hostname accordingly
If /etc/hostname doesn't exist, the hostname is set to "localhost"</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sync_hostname(self) -&gt; None:
    &#34;&#34;&#34;
    Reads /etc/hostname and sets the system hostname accordingly
    If /etc/hostname doesn&#39;t exist, the hostname is set to &#34;localhost&#34;

    Returns:
        None
    &#34;&#34;&#34;
    # Note: We don&#39;t need to use the sethostname syscall because this is only if we updated the /etc/hostname file
    etc_dir: Directory = self.fs.files.find(&#34;etc&#34;)

    if not etc_dir:
        self.hostname = &#34;localhost&#34;

    else:
        hostname_file: File = etc_dir.find(&#34;hostname&#34;)

        if not hostname_file:
            self.hostname = &#34;localhost&#34;
        else:
            self.hostname = hostname_file.content.split(&#34;\n&#34;)[0]</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sync_user_and_group_files"><code class="name flex">
<span>def <span class="ident">sync_user_and_group_files</span></span>(<span>self) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Makes sure that:
/etc/passwd matches our internal user map
/etc/shadow matches our internal user map
/etc/group matches our internal group map</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sync_user_and_group_files(self) -&gt; Result:
    &#34;&#34;&#34;
    Makes sure that:
    /etc/passwd matches our internal user map
    /etc/shadow matches our internal user map
    /etc/group matches our internal group map

    Returns:
        None
    &#34;&#34;&#34;
    etc_dir: Directory = self.fs.files.find(&#34;etc&#34;)

    if not etc_dir:
        return Result(success=False, message=ResultMessages.NOT_FOUND)

    passwd_file: File = etc_dir.find(&#34;passwd&#34;)
    shadow_file: File = etc_dir.find(&#34;shadow&#34;)
    group_file: File = etc_dir.find(&#34;group&#34;)

    # TODO: Allow modification of home directory from here
    # passwd format: USERNAME:MD5_PASSWORD OR &#34;x&#34;:UID:PRIMARY_GID
    # shadow format: USERNAME:MD5_PASSWORD
    # group format: GROUP_NAME:x:GID:GROUP_USERS

    passwd_content = &#34;&#34;
    shadow_content = &#34;&#34;
    group_content = &#34;&#34;

    for user in self.get_all_users().data:
        # Find the &#34;primary&#34; group
        primary_group = self.get_user_primary_group(user.uid)
        if primary_group.success:
            if len(primary_group.data) &gt; 0:
                primary_group = primary_group.data[0]
            else:
                primary_group = &#34;?&#34;
        else:
            primary_group = &#34;?&#34;

        passwd_content += f&#34;{user.username}:x:{user.uid}:{primary_group}\n&#34;
        shadow_content += f&#34;{user.username}:{user.password}\n&#34;

    for group in self.get_all_groups().data:
        uids = self.get_users_in_group(group.gid).data
        usernames = &#34;&#34;
        for uid in uids:
            user_lookup = self.get_user(uid=uid[0])
            usernames += (&#34;?&#34; if not user_lookup.success else user_lookup.data.username) + &#34;,&#34;

        usernames = usernames[:-1]

        group_content += f&#34;{group.name}:x:{group.gid}:{usernames}\n&#34;
        # print(group_content, end=&#34;&#34;)

    if not passwd_file:
        # Create the /etc/passwd
        etc_dir.add_file(File(&#34;passwd&#34;, passwd_content, etc_dir, 0, 0))
    else:
        passwd_file.content = passwd_content

    if not shadow_file:
        # Create the /etc/shadow file and change its perms (rw-------)
        shadow_file = File(&#34;shadow&#34;, shadow_content, etc_dir, 0, 0)
        shadow_file.permissions = {&#34;read&#34;: [&#34;owner&#34;], &#34;write&#34;: [&#34;owner&#34;], &#34;execute&#34;: []}
        etc_dir.add_file(shadow_file)
    else:
        shadow_file.content = shadow_content

    if not group_file:
        # Create the /etc/group
        etc_dir.add_file(File(&#34;group&#34;, group_content, etc_dir, 0, 0))
    else:
        group_file.content = group_content

    return Result(success=True)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_access"><code class="name flex">
<span>def <span class="ident">sys_access</span></span>(<span>self, pathname:str, mode:int) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Check if the current effective UID has a given permission to the given <code>File</code>/<code>Directory</code>
Possible modes are:
* F_OK: File exists
* R_OK: Read permission
* W_OK: Write permissions
* X_OK: Execute permission</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pathname</code></strong> :&ensp;<code>str</code></dt>
<dd>The file path of the given <code>File</code>/<code>Directory</code> to check</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>int</code></dt>
<dd>Bitwise flags of the permissions to check</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> object with the success flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_access(self, pathname: str, mode: int) -&gt; Result:
    &#34;&#34;&#34;
    Check if the current effective UID has a given permission to the given `File`/`Directory`
    Possible modes are:
        * F_OK: File exists
        * R_OK: Read permission
        * W_OK: Write permissions
        * X_OK: Execute permission

    Args:
        pathname (str): The file path of the given `File`/`Directory` to check
        mode (int): Bitwise flags of the permissions to check

    Returns:
        Result: A `Result` object with the success flag set accordingly
    &#34;&#34;&#34;
    # We need to find the file no matter what we do, so lets just find it now
    find_file = self.fs.find(pathname)

    success = True

    if not find_file.success:
        return Result(success=False, message=ResultMessages.NOT_FOUND)

    file = find_file.data

    if AccessMode.R_OK in mode:
        if not file.check_perm(&#34;read&#34;, self).success:
            success = False

    if AccessMode.W_OK in mode:
        if not file.check_perm(&#34;write&#34;, self).success:
            success = False

    if AccessMode.X_OK in mode:
        if not file.check_perm(&#34;execute&#34;, self).success:
            success = False

    return Result(success=success)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_chdir"><code class="name flex">
<span>def <span class="ident">sys_chdir</span></span>(<span>self, pathname:str) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Change the <code>current_dir</code> of the current <code>Session</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pathname</code></strong> :&ensp;<code>str</code></dt>
<dd>The file path of the directory to <code>cd</code> into</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> object with the success flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_chdir(self, pathname: str) -&gt; Result:
    &#34;&#34;&#34;
    Change the `current_dir` of the current `Session`

    Args:
        pathname (str): The file path of the directory to `cd` into

    Returns:
        Result: A `Result` object with the success flag set accordingly
    &#34;&#34;&#34;
    find_file = self.fs.find(pathname)

    if not find_file.success:
        return Result(success=False, message=ResultMessages.NOT_FOUND)

    # We need executable permissions to cd (???)
    check_perm = find_file.data.check_perm(&#34;execute&#34;, self)
    if not check_perm.success:
        return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    if find_file.data.is_file():
        return Result(success=False, message=ResultMessages.IS_FILE)

    self.sessions[-1].current_dir = find_file.data
    return Result(success=True)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_chmod"><code class="name flex">
<span>def <span class="ident">sys_chmod</span></span>(<span>self, pathname:str, mode:int) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Change the permission mode of a <code>File</code>/<code>Directory</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pathname</code></strong> :&ensp;<code>str</code></dt>
<dd>File path of the <code>File</code>/<code>Directory</code> to change mode of</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>int</code></dt>
<dd>Octal permissions of the given pathname</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> instance with the <code>success</code> flag set accordingly.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_chmod(self, pathname: str, mode: int) -&gt; Result:
    &#34;&#34;&#34;
    Change the permission mode of a `File`/`Directory`

    Args:
        pathname (str): File path of the `File`/`Directory` to change mode of
        mode (int): Octal permissions of the given pathname

    Returns:
        Result: A `Result` instance with the `success` flag set accordingly.
    &#34;&#34;&#34;
    find_file = self.fs.find(pathname)

    if not find_file.success:
        return Result(success=False, message=ResultMessages.NOT_FOUND)

    # Only the owner can change chmod permissions
    if self.sys_getuid() not in [find_file.data.owner, 0]:
        return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    raw_mode = str(bin(mode)).replace(&#34;0b&#34;, &#34;&#34;)
    raw_mode = &#34;0&#34; * (9 - len(raw_mode)) + raw_mode

    chmod_bits = []
    for x in range(0, len(raw_mode), 3):
        chmod_bits.append(raw_mode[x: x + 3])

    perms = {&#34;read&#34;: [], &#34;write&#34;: [], &#34;execute&#34;: []}

    for x in range(3):
        bits = chmod_bits[x]
        scope = [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;][x]

        for y in range(3):
            bit = bits[y]
            perm_scope = [&#34;read&#34;, &#34;write&#34;, &#34;execute&#34;][y]

            if bit == &#34;1&#34;:
                perms[perm_scope].append(scope)

    find_file.data.permissions = perms
    find_file.data.handle_event(&#34;change_perm&#34;)
    return Result(success=True)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_chown"><code class="name flex">
<span>def <span class="ident">sys_chown</span></span>(<span>self, pathname:str, owner:int, group:int) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Change the owner of the given <code>pathname</code> (if allowed)</p>
<h2 id="notes">Notes</h2>
<p>Only the owner or root is allowed to change the owner of a <code>File</code>/<code>Directory</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pathname</code></strong> :&ensp;<code>str</code></dt>
<dd>The file path of the <code>File</code>/<code>Directory</code> to change the owner of</dd>
<dt><strong><code>owner</code></strong> :&ensp;<code>int</code></dt>
<dd>The UID of the new owner</dd>
<dt><strong><code>group</code></strong> :&ensp;<code>int</code></dt>
<dd>The GID of the new owner</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> object with the success flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_chown(self, pathname: str, owner: int, group: int) -&gt; Result:
    &#34;&#34;&#34;
    Change the owner of the given `pathname` (if allowed)

    Notes:
        Only the owner or root is allowed to change the owner of a `File`/`Directory`

    Args:
        pathname (str): The file path of the `File`/`Directory` to change the owner of
        owner (int): The UID of the new owner
        group (int): The GID of the new owner

    Returns:
        Result: A `Result` object with the success flag set accordingly
    &#34;&#34;&#34;
    find_file = self.fs.find(pathname)

    if not find_file.success:
        return Result(success=False, message=ResultMessages.NOT_FOUND)

    file = find_file.data

    change_perms = file.change_owner(self, owner, group)

    if not change_perms.success:
        return Result(success=False, message=change_perms.message)

    return Result(success=True)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_creat"><code class="name flex">
<span>def <span class="ident">sys_creat</span></span>(<span>self, pathname:str, mode:int) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Make a file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pathname</code></strong> :&ensp;<code>str</code></dt>
<dd>The path of the file to make</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>int</code></dt>
<dd>Octal permissions of the new <code>File</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> object with the success flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_creat(self, pathname: str, mode: int) -&gt; Result:
    &#34;&#34;&#34;
    Make a file

    Args:
        pathname (str): The path of the file to make
        mode (int): Octal permissions of the new `File`

    Returns:
        Result: A `Result` object with the success flag set accordingly
    &#34;&#34;&#34;
    # Try to resolve the path
    find_file = self.fs.find(pathname)

    if find_file.success:
        return Result(success=False, message=ResultMessages.ALREADY_EXISTS)

    if &#34;/&#34; not in pathname:
        pathname = &#34;./&#34; + pathname

    # Make sure we have write permissions on the parent dir
    parent_path = &#34;/&#34;.join(pathname.split(&#34;/&#34;)[:-1])

    # Just in case
    find_parent = self.fs.find(parent_path)

    # Sanity check
    if not find_parent.success:
        return Result(success=False, message=ResultMessages.NOT_FOUND)

    # We need write permissions on the parent
    if not find_parent.data.check_perm(&#34;write&#34;, self).success:
        return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    new_file = File(pathname.split(&#34;/&#34;)[-1], &#34;&#34;, find_parent.data, self.sys_getuid(), self.sys_getgid())
    self.sys_chmod(pathname, mode)
    find_parent.data.add_file(new_file)

    return Result(success=True)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_execv"><code class="name flex">
<span>def <span class="ident">sys_execv</span></span>(<span>self, pathname:str, argv:list) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Execute a file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pathname</code></strong> :&ensp;<code>str</code></dt>
<dd>The path name of the binary to execute</dd>
<dt><strong><code>argv</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of arguments to pass to the binary</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> arguments containing the output from the binary</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_execv(self, pathname: str, argv: list) -&gt; Result:
    &#34;&#34;&#34;
    Execute a file

    Args:
        pathname (str): The path name of the binary to execute
        argv (list): A list of arguments to pass to the binary

    Returns:
        Result: A `Result` arguments containing the output from the binary
    &#34;&#34;&#34;
    find_result = self.fs.find(pathname)

    if not find_result.success:
        return Result(success=False, message=ResultMessages.NOT_FOUND)

    if not find_result.data.check_perm(&#34;execute&#34;, self).success:
        return Result(success=False, message=ResultMessages.NOT_FOUND)

    return self.run_command(pathname.split(&#34;/&#34;)[-1], argv, False)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_execvp"><code class="name flex">
<span>def <span class="ident">sys_execvp</span></span>(<span>self, command:str, argv:list) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Execute a command using the PATH rather than the full binary path. Does exactly what the system shell does.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong> :&ensp;<code>str</code></dt>
<dd>The command to run</dd>
<dt><strong><code>argv</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of arguments to pass to the binary</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> arguments containing the output from the binary</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_execvp(self, command: str, argv: list) -&gt; Result:
    &#34;&#34;&#34;
    Execute a command using the PATH rather than the full binary path. Does exactly what the system shell does.

    Args:
        command (str): The command to run
        argv (list): A list of arguments to pass to the binary

    Returns:
        Result: A `Result` arguments containing the output from the binary
    &#34;&#34;&#34;
    return self.run_command(command, argv, False)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_exit"><code class="name flex">
<span>def <span class="ident">sys_exit</span></span>(<span>self, force=False) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Exit a session and return to the previous session. If a previous computer exists and no sessions exist,
return to the previous computer. If no previous computer exists, exit the game.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>force</code></strong> :&ensp;<code>bool</code></dt>
<dd>If a prev computer exists, exit to previous computer regardless of previous sessions. If no previous computers exist, exit the game.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_exit(self, force=False) -&gt; None:
    &#34;&#34;&#34;
    Exit a session and return to the previous session. If a previous computer exists and no sessions exist,
    return to the previous computer. If no previous computer exists, exit the game.

    Args:
        force (bool): If a prev computer exists, exit to previous computer regardless of previous sessions. If no previous computers exist, exit the game.

    Returns:
        None
    &#34;&#34;&#34;
    if force:
        if len(self.shell.computers) == 1:
            self.save()
            exit(0)
        else:
            self.sessions = []
            self.shell.computers.pop()
    else:
        if len(self.shell.computers) == 1:
            if len(self.sessions) == 1:
                self.save()
                exit(0)
            else:
                self.sessions.pop()
        else:
            self.shell.computers.pop()</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_getcwd"><code class="name flex">
<span>def <span class="ident">sys_getcwd</span></span>(<span>self) ><a title="client.blackhat.fs.FSBaseObject" href="fs.html#client.blackhat.fs.FSBaseObject">FSBaseObject</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get current directory in the file system</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>FSBaseObject</code></dt>
<dd>The
user's current directory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_getcwd(self) -&gt; FSBaseObject:
    &#34;&#34;&#34;
    Get current directory in the file system

    Returns:
        FSBaseObject: The  user&#39;s current directory
    &#34;&#34;&#34;
    if len(self.sessions) == 0:
        return self.fs.files
    else:
        return self.sessions[-1].current_dir</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_getgid"><code class="name flex">
<span>def <span class="ident">sys_getgid</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the (primary) GID of the <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code>'s current user</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>(primary) GID of the <code>Computers</code>'s current user (from most recent session)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_getgid(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the (primary) GID of the `Computer`&#39;s current user

    Returns:
        int: (primary) GID of the `Computers`&#39;s current user (from most recent session)
    &#34;&#34;&#34;
    current_uid = self.sys_getuid()
    result = self.database.execute(
        &#34;SELECT group_gid FROM group_membership WHERE computer_id=? AND user_uid=? AND membership_type=?&#34;,
        (self.id, current_uid, &#34;primary&#34;)).fetchone()

    if result:
        return result[0]
    else:
        # NOTE: possible exploit, but maybe we leave it here on purpose?
        # TODO: Write proof of concept exploit to exploit this exploit
        return 0</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_gethostname"><code class="name flex">
<span>def <span class="ident">sys_gethostname</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the current system hostname (from internal var, not /etc/hostname)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>"localhost" if the hostname isn't set, otherwise, the current <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code>'s hostname</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_gethostname(self) -&gt; str:
    &#34;&#34;&#34;
    Gets the current system hostname (from internal var, not /etc/hostname)

    Returns:
        str: &#34;localhost&#34; if the hostname isn&#39;t set, otherwise, the current `Computer`&#39;s hostname
    &#34;&#34;&#34;
    return &#34;localhost&#34; if not self.hostname else self.hostname</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_gettimeofday"><code class="name flex">
<span>def <span class="ident">sys_gettimeofday</span></span>(<span>self) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get the current time (host systems time)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>timeval</code></dt>
<dd>A <code>timeval</code> struct containing the current time in seconds</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_gettimeofday(self) -&gt; Result:
    &#34;&#34;&#34;
    Get the current time (host systems time)

    Returns:
        timeval: A `timeval` struct containing the current time in seconds
    &#34;&#34;&#34;
    # TODO: Add get time by timezone
    timestamp = time()
    seconds = int(timestamp)
    microseconds = int(str(timestamp - seconds).replace(&#34;0.&#34;, &#34;&#34;))

    return Result(success=True, data=timeval(seconds, microseconds))</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_getuid"><code class="name flex">
<span>def <span class="ident">sys_getuid</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the UID of the <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code>'s current user</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>UID of the <code>Computers</code>'s current user (from most recent session)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_getuid(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the UID of the `Computer`&#39;s current user

    Returns:
        int: UID of the `Computers`&#39;s current user (from most recent session)
    &#34;&#34;&#34;
    if len(self.sessions) == 0:
        return 0

    return self.sessions[-1].effective_uid</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_mkdir"><code class="name flex">
<span>def <span class="ident">sys_mkdir</span></span>(<span>self, pathname:str, mode:int) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Make a directory</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pathname</code></strong> :&ensp;<code>str</code></dt>
<dd>The path of the directory to make</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>int</code></dt>
<dd>Octal permissions of the new <code>Directory</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> object with the success flag set accordingly and the data flag containing the new <code>Directory</code> object if successful</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_mkdir(self, pathname: str, mode: int) -&gt; Result:
    &#34;&#34;&#34;
    Make a directory

    Args:
        pathname (str): The path of the directory to make
        mode (int): Octal permissions of the new `Directory`

    Returns:
        Result: A `Result` object with the success flag set accordingly and the data flag containing the new `Directory` object if successful
    &#34;&#34;&#34;
    # Make sure it doesn&#39;t already exist
    find_dir = self.fs.find(pathname)

    if find_dir.success:
        return Result(success=False, message=ResultMessages.ALREADY_EXISTS)

    if &#34;/&#34; not in pathname:
        pathname = &#34;./&#34; + pathname

    # Make sure we have write permissions on the parent dir
    parent_path = &#34;/&#34;.join(pathname.split(&#34;/&#34;)[:-1])

    # Just in case
    find_parent = self.fs.find(parent_path)

    if not find_parent.success:
        return Result(success=False, message=ResultMessages.NOT_FOUND)

    if not find_parent.data.check_perm(&#34;write&#34;, self).success:
        return Result(success=False, message=ResultMessages.NOT_ALLOWED_WRITE)

    new_dir = Directory(pathname.split(&#34;/&#34;)[-1], find_parent.data, owner=self.sys_getuid(),
                        group_owner=self.sys_getgid())

    add_file = find_parent.data.add_file(new_dir)

    if not self.sys_chmod(pathname, mode).success:
        # rwxr-xr-x
        new_dir.permissions = {&#34;read&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;], &#34;write&#34;: [&#34;owner&#34;],
                               &#34;execute&#34;: [&#34;owner&#34;, &#34;group&#34;, &#34;public&#34;]}

    if not add_file.success:
        return Result(success=False, message=ResultMessages.GENERIC)

    return Result(success=True, data=new_dir)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_read"><code class="name flex">
<span>def <span class="ident">sys_read</span></span>(<span>self, filepath:str) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Try to read the content of the given <code>filepath</code>. Checks permissions</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code></dt>
<dd>The path of the file to read</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> object with the success flag set accordingly and the data flag containing the files</dd>
</dl>
<p>if read was successful</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_read(self, filepath: str) -&gt; Result:
    &#34;&#34;&#34;
    Try to read the content of the given `filepath`. Checks permissions

    Args:
        filepath (str): The path of the file to read

    Returns:
        Result: A `Result` object with the success flag set accordingly and the data flag containing the files
        if read was successful
    &#34;&#34;&#34;
    # Try to find the file
    find_file = self.fs.find(filepath)

    if not find_file.success:
        return Result(success=False, message=ResultMessages.NOT_FOUND)

    if find_file.data.is_directory():
        return Result(success=False, message=ResultMessages.IS_DIRECTORY)

    try_read_file = find_file.data.read(self)

    if not try_read_file.success:
        return Result(success=False, message=ResultMessages.NOT_ALLOWED_READ)

    return Result(success=True, data=try_read_file.data)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_reboot"><code class="name flex">
<span>def <span class="ident">sys_reboot</span></span>(<span>self, mode:int) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Simulate a computer reboot. Clear all sessions and re-initialize the machine</p>
<h2 id="args">Args</h2>
<p>mode (int: Bitwise flags of the operation to take</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> object with the success flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_reboot(self, mode: int) -&gt; Result:
    &#34;&#34;&#34;
    Simulate a computer reboot. Clear all sessions and re-initialize the machine

    Args:
        mode (int: Bitwise flags of the operation to take

    Returns:
        Result: A `Result` object with the success flag set accordingly
    &#34;&#34;&#34;
    if self.sys_getuid() != 0:
        return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    if RebootMode.LINUX_REBOOT_CMD_POWER_OFF in mode:
        self.sys_exit(True)

    if RebootMode.LINUX_REBOOT_CMD_RESTART in mode:
        print(f&#34;Rebooting...&#34;)
        sleep(1)
        if system() == &#34;Windows&#34;:
            real_syscall(&#34;cls&#34;)
        else:
            real_syscall(&#34;clear&#34;)
        self.run_command(&#34;clear&#34;, [], pipe=True)
        self.init()
        while len(self.sessions) != 1:
            self.sys_exit()

    return Result(success=True)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_rename"><code class="name flex">
<span>def <span class="ident">sys_rename</span></span>(<span>self, oldpath:str, newpath:str) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Rename or move a file or directory</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>oldpath</code></strong> :&ensp;<code>str</code></dt>
<dd>The original file/directory path to rename</dd>
<dt><strong><code>newpath</code></strong> :&ensp;<code>str</code></dt>
<dd>The new path of the file/directory</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> object with the success flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_rename(self, oldpath: str, newpath: str) -&gt; Result:
    &#34;&#34;&#34;
    Rename or move a file or directory

    Args:
        oldpath (str): The original file/directory path to rename
        newpath (str): The new path of the file/directory

    Returns:
        Result: A `Result` object with the success flag set accordingly
    &#34;&#34;&#34;
    find_old = self.fs.find(oldpath)

    if not find_old.success:
        return Result(success=False, message=ResultMessages.NOT_FOUND)

    if not find_old.data.check_owner(self).success or self.sys_getuid() != 0:
        return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    copy_result = copy(self, oldpath, newpath)

    if not copy_result.success:
        return copy_result

    # Rename means move, so delete the original
    delete_result = self.fs.find(oldpath).data.delete(self)

    if not delete_result.success:
        return delete_result

    return Result(success=True)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_rmdir"><code class="name flex">
<span>def <span class="ident">sys_rmdir</span></span>(<span>self, pathname:str) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Remove an empty directory</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pathname</code></strong> :&ensp;<code>str</code></dt>
<dd>The file path of the empty <code>Directory</code> to remove</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> object with the success flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_rmdir(self, pathname: str) -&gt; Result:
    &#34;&#34;&#34;
    Remove an empty directory

    Args:
        pathname (str): The file path of the empty `Directory` to remove

    Returns:
        Result: A `Result` object with the success flag set accordingly
    &#34;&#34;&#34;
    find_result = self.fs.find(pathname)

    if not find_result.success:
        return Result(success=False, message=ResultMessages.NOT_FOUND)

    if find_result.data.is_file():
        return Result(success=False, message=ResultMessages.IS_FILE)

    if len(find_result.data.files) &gt; 0:
        return Result(success=False, message=ResultMessages.NOT_EMPTY)

    delete_response = find_result.data.delete(self)

    if not delete_response.success:
        return delete_response

    return Result(success=True)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_sethostname"><code class="name flex">
<span>def <span class="ident">sys_sethostname</span></span>(<span>self, hostname:str) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>An easy function to update the hostname (also updates /etc/hostname)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hostname</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code>'s new hostname</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> instance with the <code>success</code> flag set accordingly.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_sethostname(self, hostname: str) -&gt; Result:
    &#34;&#34;&#34;
    An easy function to update the hostname (also updates /etc/hostname)
    Args:
        hostname (str): The `Computer`&#39;s new hostname

    Returns:
        Result: A `Result` instance with the `success` flag set accordingly.
    &#34;&#34;&#34;
    # Try to find the hostname file
    if self.sys_getuid() != 0:
        return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    if not self.sys_stat(&#34;/etc/hostname&#34;).success:
        # Make sure we at least have the /etc/ dir so we can make /etc/hostname
        if not self.sys_stat(&#34;/etc/&#34;).success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)
        # Create the /etc/hostname
        find_etc_dir = self.fs.find(&#34;/etc/&#34;)
        find_etc_dir.data.add_file(File(&#34;hostname&#34;, hostname, find_etc_dir.data, 0, 0))
    else:
        # Even though we should never get here unless we&#39;re root, I&#39;m gonna be a good boy and do this properly
        if not self.sys_write(&#34;/etc/hostname&#34;, hostname).success:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED_WRITE)

    self.hostname = hostname
    return Result(success=True)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_setuid"><code class="name flex">
<span>def <span class="ident">sys_setuid</span></span>(<span>self, uid:int) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Change current <code>Session</code>'s effective UID to the given <code>UID</code></p>
<h2 id="notes">Notes</h2>
<p>setuid() followed the current rules:
* If the "caller" uid is root, change the uid to whatever is given
* If the "caller" isn't root, BUT the setuid bit (not implement yet) is set, the UID can be set to the owner of the file
* If the "caller" isn't root, and the setuid bit ISN'T set, deny all changes</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>uid</code></strong> :&ensp;<code>int</code></dt>
<dd>The new UID to change to</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> object with the success flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_setuid(self, uid: int) -&gt; Result:
    &#34;&#34;&#34;
    Change current `Session`&#39;s effective UID to the given `UID`

    Notes:
        setuid() followed the current rules:
            * If the &#34;caller&#34; uid is root, change the uid to whatever is given
            * If the &#34;caller&#34; isn&#39;t root, BUT the setuid bit (not implement yet) is set, the UID can be set to the owner of the file
            * If the &#34;caller&#34; isn&#39;t root, and the setuid bit ISN&#39;T set, deny all changes

    Args:
        uid (int): The new UID to change to

    Returns:
        Result: A `Result` object with the success flag set accordingly
    &#34;&#34;&#34;
    # TODO: Implement a PROPER setuid
    # The way setuid should work:
    # If the &#34;caller&#34; uid is root, change the uid to whatever is given
    # If the &#34;caller&#34; isn&#39;t root, BUT the setuid bit (not implement yet) is set, the UID can be set to the owner of the file
    # If the &#34;caller&#34; isn&#39;t root, and the setuid bit ISN&#39;T set, deny all changes

    # if self.sys_getuid() == 0:
    self.sessions[-1].effective_uid = uid
    return Result(success=True)
    # else:
    #     return Result(success=False, message=ResultMessages.NOT_ALLOWED)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_stat"><code class="name flex">
<span>def <span class="ident">sys_stat</span></span>(<span>self, path:str) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get information about a given file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path of the given <code>File</code>/<code>Directory</code> to get info about</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> object with the success flag set accordingly and the data flag containing a <code>stat_struct</code> object if successful</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_stat(self, path: str) -&gt; Result:
    &#34;&#34;&#34;
    Get information about a given file

    Args:
        path (str): The path of the given `File`/`Directory` to get info about

    Returns:
        Result: A `Result` object with the success flag set accordingly and the data flag containing a `stat_struct` object if successful
    &#34;&#34;&#34;
    find_file = self.fs.find(path)

    if not find_file.success:
        return Result(success=False, message=ResultMessages.NOT_FOUND)

    if not find_file.data.check_perm(&#34;read&#34;, self).success:
        return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    file = find_file.data

    is_file = file.is_file()

    # TODO: Find a less shit way to do this
    mode = [0, 0, 0]

    # Owner bit
    if &#34;owner&#34; in file.permissions[&#34;execute&#34;]:
        mode[0] += 1
    if &#34;owner&#34; in file.permissions[&#34;write&#34;]:
        mode[0] += 2
    if &#34;owner&#34; in file.permissions[&#34;read&#34;]:
        mode[0] += 4
    # Group bit
    if &#34;group&#34; in file.permissions[&#34;execute&#34;]:
        mode[1] += 1
    if &#34;group&#34; in file.permissions[&#34;write&#34;]:
        mode[1] += 2
    if &#34;group&#34; in file.permissions[&#34;read&#34;]:
        mode[1] += 4
    # Public bit
    if &#34;public&#34; in file.permissions[&#34;execute&#34;]:
        mode[2] += 1
    if &#34;public&#34; in file.permissions[&#34;write&#34;]:
        mode[2] += 2
    if &#34;public&#34; in file.permissions[&#34;read&#34;]:
        mode[2] += 4
    mode = int(&#34;&#34;.join([str(x) for x in mode]))

    nlink = 0
    uid = file.owner
    gid = file.group_owner
    size = file.size
    # TODO: Implement atime, mtime, and ctime
    atime = 0
    mtime = 0
    ctime = 0
    path = file.pwd()

    stat_result = stat_struct(is_file, mode, nlink, uid, gid, size, atime, mtime, ctime, path)

    return Result(success=True, data=stat_result)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_unlink"><code class="name flex">
<span>def <span class="ident">sys_unlink</span></span>(<span>self, pathname:str) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Removes a link to a file. If there are no links left, the file is removed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pathname</code></strong> :&ensp;<code>str</code></dt>
<dd>The file path of the <code>File</code> to unlink</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> arguments containing the output from the binary</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_unlink(self, pathname: str) -&gt; Result:
    &#34;&#34;&#34;
    Removes a link to a file. If there are no links left, the file is removed.

    Args:
        pathname (str): The file path of the `File` to unlink

    Returns:
        Result: A `Result` arguments containing the output from the binary

    &#34;&#34;&#34;
    find_result = self.fs.find(pathname)

    if not find_result.success:
        return Result(success=False, message=ResultMessages.NOT_FOUND)

    if not find_result.data.check_perm(&#34;write&#34;, self) or not find_result.data.check_perm(&#34;execute&#34;, self):
        return Result(success=False, message=ResultMessages.NOT_ALLOWED)

    delete_result = find_result.data.delete(self)

    if not delete_result.success:
        return delete_result

    return Result(success=True)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.sys_write"><code class="name flex">
<span>def <span class="ident">sys_write</span></span>(<span>self, fd:Union[str,<a title="client.blackhat.lib.sys.socket.Socket" href="lib/sys/socket.html#client.blackhat.lib.sys.socket.Socket">Socket</a>], data:Union[str,dict]) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Try to write to a given file descriptor. If <code>fd</code> is a file path, this function will try to write to a file
(permission safe), however, if the fd is a <code>Socket</code>, this function will try to send the given <code>data</code> to the
respective <code>Socket</code>'s connected service (if connected).</p>
<h2 id="args">Args</h2>
<dl>
<dt>fd (str or :obj:<code>Socket</code>): The filepath of the file or Socket to write to</dt>
<dt><strong><code>data</code></strong> :&ensp;<code>str</code> or <code>dict</code></dt>
<dd>The data to write to the file (if fd == str) or data to send to the socket (if fd == Socket)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> object with the success flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sys_write(self, fd: Union[str, Socket], data: Union[str, dict]) -&gt; Result:
    &#34;&#34;&#34;
    Try to write to a given file descriptor. If `fd` is a file path, this function will try to write to a file
    (permission safe), however, if the fd is a `Socket`, this function will try to send the given `data` to the
    respective `Socket`&#39;s connected service (if connected).

    Args:
        fd (str or :obj:`Socket`): The filepath of the file or Socket to write to
        data (str or dict): The data to write to the file (if fd == str) or data to send to the socket (if fd == Socket)

    Returns:
        Result: A `Result` object with the success flag set accordingly
    &#34;&#34;&#34;
    if type(fd) == Socket:
        # We&#39;re &#39;writing&#39; to a network socket
        if not fd.client:
            return Result(success=False, message=ResultMessages.NOT_CONNECTED)

        if type(data) == str:
            return Result(success=False, message=ResultMessages.INVALID_ARGUMENT)

        return fd.client.main(data)
    else:
        # We&#39;re writing to a file
        # Try to find the file
        find_file = self.fs.find(fd)

        if not find_file.success:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        if find_file.data.is_directory():
            return Result(success=False, message=ResultMessages.IS_DIRECTORY)

        try_write_file = find_file.data.write(data, self)

        if not try_write_file.success:
            return Result(success=False, message=ResultMessages.NOT_ALLOWED_WRITE)

        return Result(success=True)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.update_libs"><code class="name flex">
<span>def <span class="ident">update_libs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The system libraries need access to the given <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> object, so before a command runs, we pass a reference
to the current <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> object, so the binaries don't need <code>computer</code> in their arguments (prevents cheating in
binaries). If commands had access to a <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> object, they could just read files without permission, access
user passwords that they shouldn't, change current UID when they shouldn't, etc.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_libs(self):
    &#34;&#34;&#34;
    The system libraries need access to the given `Computer` object, so before a command runs, we pass a reference
    to the current `Computer` object, so the binaries don&#39;t need `computer` in their arguments (prevents cheating in
    binaries). If commands had access to a `Computer` object, they could just read files without permission, access
    user passwords that they shouldn&#39;t, change current UID when they shouldn&#39;t, etc.

    Returns:
        None
    &#34;&#34;&#34;
    libs = [unistd, time, stat, stdlib, dirent, fcntl, inet, stdio, pwd, socket, ifaddrs, netdb]

    for lib in libs:
        lib.update(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="client.blackhat.computer.ISPRouter"><code class="flex name class">
<span>class <span class="ident">ISPRouter</span></span>
</code></dt>
<dd>
<div class="desc"><p>An ISP router is just a router of routers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ISPRouter(Router):
    def __init__(self):
        &#34;&#34;&#34;
        An ISP router is just a router of routers
        &#34;&#34;&#34;
        super().__init__()
        self.wan = &#34;1.1.1.1&#34;
        self.used_ips = [&#34;1.1.1.1&#34;]

    def dhcp(self, **kwargs) -&gt; Result:
        &#34;&#34;&#34;
        Distributes IP addresses to clients on the network

        Returns:
            Result: A `Result` with the `success` flag set accordingly. The `data` flag contains the IP to assign to a given client.
        &#34;&#34;&#34;
        while True:
            ip = &#34;.&#34;.join(str(choice([x for x in range(1, 256) if x not in [192, 168]])) for _ in range(4))
            if ip not in self.used_ips:
                self.used_ips.append(ip)
                return Result(success=True, data=ip)

    def add_new_client(self, client: Router, **kwargs) -&gt; Result:
        &#34;&#34;&#34;
        Connect a given `Computer` to the given `ISPRouter`
        Also, assign an IP address using the `dhcp()` function.

        Args:
            client (:obj:`Computer`): The `Computer` instance to connect to the `ISPRouter`

        Returns:
            Result: A `Result` with the `success` flag set accordingly. The `data` flag contains the `client`&#39;s newly assigned IP address if successful.
        &#34;&#34;&#34;
        dhcp_result = self.dhcp()
        if dhcp_result.success:
            client.wan = dhcp_result.data
            client.parent = self
            self.clients[client.wan] = client
            return Result(success=True, data=client.wan)
        else:
            # Failed for some reason (DHCP will give us our error)
            return dhcp_result

    def find_client(self, host: str, port: int) -&gt; Result:
        if host == self.wan:
            if port in self.services.keys():
                return Result(success=True, data=self.services.get(port))
            else:
                return Result(success=False, message=ResultMessages.NOT_FOUND)
        else:
            find_client = next((x for x in self.clients.values() if x.wan == host), None)

            if find_client:
                return find_client.find_client(host, port)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="client.blackhat.computer.Router" href="#client.blackhat.computer.Router">Router</a></li>
<li><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="client.blackhat.computer.ISPRouter.add_new_client"><code class="name flex">
<span>def <span class="ident">add_new_client</span></span>(<span>self, client:<a title="client.blackhat.computer.Router" href="#client.blackhat.computer.Router">Router</a>, **kwargs) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Connect a given <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> to the given <code><a title="client.blackhat.computer.ISPRouter" href="#client.blackhat.computer.ISPRouter">ISPRouter</a></code>
Also, assign an IP address using the <code>dhcp()</code> function.</p>
<h2 id="args">Args</h2>
<p>client (:obj:<code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code>): The <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> instance to connect to the <code><a title="client.blackhat.computer.ISPRouter" href="#client.blackhat.computer.ISPRouter">ISPRouter</a></code></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> with the <code>success</code> flag set accordingly. The <code>data</code> flag contains the <code>client</code>'s newly assigned IP address if successful.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_new_client(self, client: Router, **kwargs) -&gt; Result:
    &#34;&#34;&#34;
    Connect a given `Computer` to the given `ISPRouter`
    Also, assign an IP address using the `dhcp()` function.

    Args:
        client (:obj:`Computer`): The `Computer` instance to connect to the `ISPRouter`

    Returns:
        Result: A `Result` with the `success` flag set accordingly. The `data` flag contains the `client`&#39;s newly assigned IP address if successful.
    &#34;&#34;&#34;
    dhcp_result = self.dhcp()
    if dhcp_result.success:
        client.wan = dhcp_result.data
        client.parent = self
        self.clients[client.wan] = client
        return Result(success=True, data=client.wan)
    else:
        # Failed for some reason (DHCP will give us our error)
        return dhcp_result</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.ISPRouter.dhcp"><code class="name flex">
<span>def <span class="ident">dhcp</span></span>(<span>self, **kwargs) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Distributes IP addresses to clients on the network</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> with the <code>success</code> flag set accordingly. The <code>data</code> flag contains the IP to assign to a given client.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dhcp(self, **kwargs) -&gt; Result:
    &#34;&#34;&#34;
    Distributes IP addresses to clients on the network

    Returns:
        Result: A `Result` with the `success` flag set accordingly. The `data` flag contains the IP to assign to a given client.
    &#34;&#34;&#34;
    while True:
        ip = &#34;.&#34;.join(str(choice([x for x in range(1, 256) if x not in [192, 168]])) for _ in range(4))
        if ip not in self.used_ips:
            self.used_ips.append(ip)
            return Result(success=True, data=ip)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.ISPRouter.find_client"><code class="name flex">
<span>def <span class="ident">find_client</span></span>(<span>self, host:str, port:int) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_client(self, host: str, port: int) -&gt; Result:
    if host == self.wan:
        if port in self.services.keys():
            return Result(success=True, data=self.services.get(port))
        else:
            return Result(success=False, message=ResultMessages.NOT_FOUND)
    else:
        find_client = next((x for x in self.clients.values() if x.wan == host), None)

        if find_client:
            return find_client.find_client(host, port)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="client.blackhat.computer.Router" href="#client.blackhat.computer.Router">Router</a></b></code>:
<ul class="hlist">
<li><code><a title="client.blackhat.computer.Router.add_group" href="#client.blackhat.computer.Computer.add_group">add_group</a></code></li>
<li><code><a title="client.blackhat.computer.Router.add_user" href="#client.blackhat.computer.Computer.add_user">add_user</a></code></li>
<li><code><a title="client.blackhat.computer.Router.add_user_to_group" href="#client.blackhat.computer.Computer.add_user_to_group">add_user_to_group</a></code></li>
<li><code><a title="client.blackhat.computer.Router.change_user_password" href="#client.blackhat.computer.Computer.change_user_password">change_user_password</a></code></li>
<li><code><a title="client.blackhat.computer.Router.change_user_uid" href="#client.blackhat.computer.Computer.change_user_uid">change_user_uid</a></code></li>
<li><code><a title="client.blackhat.computer.Router.create_root_user" href="#client.blackhat.computer.Computer.create_root_user">create_root_user</a></code></li>
<li><code><a title="client.blackhat.computer.Router.delete_group" href="#client.blackhat.computer.Computer.delete_group">delete_group</a></code></li>
<li><code><a title="client.blackhat.computer.Router.delete_user" href="#client.blackhat.computer.Computer.delete_user">delete_user</a></code></li>
<li><code><a title="client.blackhat.computer.Router.get_all_groups" href="#client.blackhat.computer.Computer.get_all_groups">get_all_groups</a></code></li>
<li><code><a title="client.blackhat.computer.Router.get_all_users" href="#client.blackhat.computer.Computer.get_all_users">get_all_users</a></code></li>
<li><code><a title="client.blackhat.computer.Router.get_env" href="#client.blackhat.computer.Computer.get_env">get_env</a></code></li>
<li><code><a title="client.blackhat.computer.Router.get_group" href="#client.blackhat.computer.Computer.get_group">get_group</a></code></li>
<li><code><a title="client.blackhat.computer.Router.get_user" href="#client.blackhat.computer.Computer.get_user">get_user</a></code></li>
<li><code><a title="client.blackhat.computer.Router.get_user_groups" href="#client.blackhat.computer.Computer.get_user_groups">get_user_groups</a></code></li>
<li><code><a title="client.blackhat.computer.Router.get_user_primary_group" href="#client.blackhat.computer.Computer.get_user_primary_group">get_user_primary_group</a></code></li>
<li><code><a title="client.blackhat.computer.Router.get_users_in_group" href="#client.blackhat.computer.Computer.get_users_in_group">get_users_in_group</a></code></li>
<li><code><a title="client.blackhat.computer.Router.init" href="#client.blackhat.computer.Computer.init">init</a></code></li>
<li><code><a title="client.blackhat.computer.Router.post_fs_init" href="#client.blackhat.computer.Computer.post_fs_init">post_fs_init</a></code></li>
<li><code><a title="client.blackhat.computer.Router.remove_user_from_group" href="#client.blackhat.computer.Computer.remove_user_from_group">remove_user_from_group</a></code></li>
<li><code><a title="client.blackhat.computer.Router.resolve_dns" href="#client.blackhat.computer.Computer.resolve_dns">resolve_dns</a></code></li>
<li><code><a title="client.blackhat.computer.Router.run_command" href="#client.blackhat.computer.Computer.run_command">run_command</a></code></li>
<li><code><a title="client.blackhat.computer.Router.run_current_user_shellrc" href="#client.blackhat.computer.Computer.run_current_user_shellrc">run_current_user_shellrc</a></code></li>
<li><code><a title="client.blackhat.computer.Router.save" href="#client.blackhat.computer.Computer.save">save</a></code></li>
<li><code><a title="client.blackhat.computer.Router.set_env" href="#client.blackhat.computer.Computer.set_env">set_env</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sync_hostname" href="#client.blackhat.computer.Computer.sync_hostname">sync_hostname</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sync_user_and_group_files" href="#client.blackhat.computer.Computer.sync_user_and_group_files">sync_user_and_group_files</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_access" href="#client.blackhat.computer.Computer.sys_access">sys_access</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_chdir" href="#client.blackhat.computer.Computer.sys_chdir">sys_chdir</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_chmod" href="#client.blackhat.computer.Computer.sys_chmod">sys_chmod</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_chown" href="#client.blackhat.computer.Computer.sys_chown">sys_chown</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_creat" href="#client.blackhat.computer.Computer.sys_creat">sys_creat</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_execv" href="#client.blackhat.computer.Computer.sys_execv">sys_execv</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_execvp" href="#client.blackhat.computer.Computer.sys_execvp">sys_execvp</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_exit" href="#client.blackhat.computer.Computer.sys_exit">sys_exit</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_getcwd" href="#client.blackhat.computer.Computer.sys_getcwd">sys_getcwd</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_getgid" href="#client.blackhat.computer.Computer.sys_getgid">sys_getgid</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_gethostname" href="#client.blackhat.computer.Computer.sys_gethostname">sys_gethostname</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_gettimeofday" href="#client.blackhat.computer.Computer.sys_gettimeofday">sys_gettimeofday</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_getuid" href="#client.blackhat.computer.Computer.sys_getuid">sys_getuid</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_mkdir" href="#client.blackhat.computer.Computer.sys_mkdir">sys_mkdir</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_read" href="#client.blackhat.computer.Computer.sys_read">sys_read</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_reboot" href="#client.blackhat.computer.Computer.sys_reboot">sys_reboot</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_rename" href="#client.blackhat.computer.Computer.sys_rename">sys_rename</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_rmdir" href="#client.blackhat.computer.Computer.sys_rmdir">sys_rmdir</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_sethostname" href="#client.blackhat.computer.Computer.sys_sethostname">sys_sethostname</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_setuid" href="#client.blackhat.computer.Computer.sys_setuid">sys_setuid</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_stat" href="#client.blackhat.computer.Computer.sys_stat">sys_stat</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_unlink" href="#client.blackhat.computer.Computer.sys_unlink">sys_unlink</a></code></li>
<li><code><a title="client.blackhat.computer.Router.sys_write" href="#client.blackhat.computer.Computer.sys_write">sys_write</a></code></li>
<li><code><a title="client.blackhat.computer.Router.update_libs" href="#client.blackhat.computer.Computer.update_libs">update_libs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="client.blackhat.computer.Router"><code class="flex name class">
<span>class <span class="ident">Router</span></span>
</code></dt>
<dd>
<div class="desc"><p>This special type of <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> is made for handling network traffic between computers in a LAN
This class represents what a real router would be in real life</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Router(Computer):
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        This special type of `Computer` is made for handling network traffic between computers in a LAN
        This class represents what a real router would be in real life
        &#34;&#34;&#34;
        super().__init__()
        self.clients = {}  # Format of clients: sorted by subnet then ID [1][2] (subnet 1 - ID 2)
        self.ip_pool: dict[int, list[str]] = {}
        self.wan = None
        self.lan = &#34;192.168.1.1&#34;
        self.port_forwarding = {}

    def dhcp(self, subnet: int) -&gt; Result:
        &#34;&#34;&#34;
        Distributes IP addresses to clients on the network

        Args:
            subnet (int): subnet id to assign the client to

        Returns:
            Result: A `Result` with the `success` flag set accordingly. The `data` flag contains the IP to assign to a given client.
        &#34;&#34;&#34;
        # Split the router&#39;s IP to get the first 16 bits
        ip_split = self.lan.split(&#34;.&#34;)
        network_prefix = f&#34;{ip_split[0]}.{ip_split[1]}.{subnet}&#34;

        # Check if the IP pool for that subnet was generated already
        try:
            len(self.ip_pool[subnet])
        # If `self.ip_pool[&lt;subnet&gt;]` returns a key error, it was never created before
        except KeyError:
            # Generate a list of ips that are &lt;NETWORK_PREFIX&gt;.&lt;subnet&gt;.1-256
            self.ip_pool[subnet] = [f&#34;{network_prefix}.{x}&#34; for x in range(1, 257)]

        # Check if we have IP&#39;s left
        if len(self.ip_pool[subnet]) == 0:
            return Result(success=False, message=ResultMessages.EMPTY)

        # Choose a random ip from the pool
        ip = choice(self.ip_pool[subnet])

        # Remove the IP from the pool since it&#39;s in use
        self.ip_pool[subnet].remove(ip)
        return Result(success=True, data=ip)

    def find_client(self, host: str, port: int) -&gt; Result:
        # Check if the given `host` belongs to us or its in an external lan
        prefix = &#34;.&#34;.join(self.lan.split(&#34;.&#34;)[0:2]) + &#34;.&#34;
        subnet = host.split(&#34;.&#34;)[2]

        if host == self.wan:
            if port in self.port_forwarding.keys():
                return Result(success=True, data=self.port_forwarding[port].services[port])
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        # We&#39;re finding one of our own
        if host.startswith(prefix):
            # Quick check, if subnet is empty, we don&#39;t have the client
            get_subnet = self.clients.get(int(subnet))
            if not get_subnet:
                return Result(success=False, message=ResultMessages.NOT_FOUND)
            # We can ignore the port because we don&#39;t need port forwarding in a lan
            client_result = next((x for x in get_subnet.values() if x.lan == host), None)
            if not client_result:
                return Result(success=False, message=ResultMessages.NOT_FOUND)

            # Now we need to check if the client has a service on that port
            # In real life, we wouldn&#39;t be able to make a connection if there is no service
            # on the given port
            if port not in client_result.services.keys():
                return Result(success=False, message=ResultMessages.NOT_FOUND)

            return Result(success=True, data=client_result.services.get(port))

        # We need to get the client from another lan, ask the ISP to handle it
        return self.parent.find_client(host, port)

    def add_new_client(self, client: Computer, subnet: int = 1) -&gt; Result:
        &#34;&#34;&#34;
        Connect a given `Computer` to the given `Router`&#39;s LAN.
        Also, assign an IP address using the `dhcp()` function.

        Args:
            client (:obj:`Computer`): The `Computer` instance to connect to the `Router`&#39;s LAN
            subnet (int, optional): The subnet id to assign the given `Computer` to

        Returns:
            Result: A `Result` with the `success` flag set accordingly. The `data` flag contains the `client`&#39;s newly assigned IP address if successful.
        &#34;&#34;&#34;
        # Generate an IP for the client
        generate_ip_status = self.dhcp(subnet)
        # We we&#39;re unable to generate an IP for the given client
        if not generate_ip_status:
            return generate_ip_status

        # Assign the IP
        client.lan = generate_ip_status.data

        # Append to client to our client list
        try:
            last_id = list(self.clients[subnet].keys())[-1]
        except KeyError:
            last_id = 0

        # Check if the client subnet exists
        try:
            len(self.clients[subnet])
        except KeyError:
            # Init the subnet (empty)
            self.clients[subnet] = {}

        self.clients[subnet][last_id + 1] = client

        client.parent = self

        return Result(success=True, data=client.lan)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="client.blackhat.computer.ISPRouter" href="#client.blackhat.computer.ISPRouter">ISPRouter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="client.blackhat.computer.Router.add_new_client"><code class="name flex">
<span>def <span class="ident">add_new_client</span></span>(<span>self, client:<a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a>, subnet:int=1) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Connect a given <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> to the given <code><a title="client.blackhat.computer.Router" href="#client.blackhat.computer.Router">Router</a></code>'s LAN.
Also, assign an IP address using the <code>dhcp()</code> function.</p>
<h2 id="args">Args</h2>
<dl>
<dt>client (:obj:<code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code>): The <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> instance to connect to the <code><a title="client.blackhat.computer.Router" href="#client.blackhat.computer.Router">Router</a></code>'s LAN</dt>
<dt><strong><code>subnet</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The subnet id to assign the given <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> to</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> with the <code>success</code> flag set accordingly. The <code>data</code> flag contains the <code>client</code>'s newly assigned IP address if successful.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_new_client(self, client: Computer, subnet: int = 1) -&gt; Result:
    &#34;&#34;&#34;
    Connect a given `Computer` to the given `Router`&#39;s LAN.
    Also, assign an IP address using the `dhcp()` function.

    Args:
        client (:obj:`Computer`): The `Computer` instance to connect to the `Router`&#39;s LAN
        subnet (int, optional): The subnet id to assign the given `Computer` to

    Returns:
        Result: A `Result` with the `success` flag set accordingly. The `data` flag contains the `client`&#39;s newly assigned IP address if successful.
    &#34;&#34;&#34;
    # Generate an IP for the client
    generate_ip_status = self.dhcp(subnet)
    # We we&#39;re unable to generate an IP for the given client
    if not generate_ip_status:
        return generate_ip_status

    # Assign the IP
    client.lan = generate_ip_status.data

    # Append to client to our client list
    try:
        last_id = list(self.clients[subnet].keys())[-1]
    except KeyError:
        last_id = 0

    # Check if the client subnet exists
    try:
        len(self.clients[subnet])
    except KeyError:
        # Init the subnet (empty)
        self.clients[subnet] = {}

    self.clients[subnet][last_id + 1] = client

    client.parent = self

    return Result(success=True, data=client.lan)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Router.dhcp"><code class="name flex">
<span>def <span class="ident">dhcp</span></span>(<span>self, subnet:int) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Distributes IP addresses to clients on the network</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>subnet</code></strong> :&ensp;<code>int</code></dt>
<dd>subnet id to assign the client to</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>A <code>Result</code> with the <code>success</code> flag set accordingly. The <code>data</code> flag contains the IP to assign to a given client.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dhcp(self, subnet: int) -&gt; Result:
    &#34;&#34;&#34;
    Distributes IP addresses to clients on the network

    Args:
        subnet (int): subnet id to assign the client to

    Returns:
        Result: A `Result` with the `success` flag set accordingly. The `data` flag contains the IP to assign to a given client.
    &#34;&#34;&#34;
    # Split the router&#39;s IP to get the first 16 bits
    ip_split = self.lan.split(&#34;.&#34;)
    network_prefix = f&#34;{ip_split[0]}.{ip_split[1]}.{subnet}&#34;

    # Check if the IP pool for that subnet was generated already
    try:
        len(self.ip_pool[subnet])
    # If `self.ip_pool[&lt;subnet&gt;]` returns a key error, it was never created before
    except KeyError:
        # Generate a list of ips that are &lt;NETWORK_PREFIX&gt;.&lt;subnet&gt;.1-256
        self.ip_pool[subnet] = [f&#34;{network_prefix}.{x}&#34; for x in range(1, 257)]

    # Check if we have IP&#39;s left
    if len(self.ip_pool[subnet]) == 0:
        return Result(success=False, message=ResultMessages.EMPTY)

    # Choose a random ip from the pool
    ip = choice(self.ip_pool[subnet])

    # Remove the IP from the pool since it&#39;s in use
    self.ip_pool[subnet].remove(ip)
    return Result(success=True, data=ip)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Router.find_client"><code class="name flex">
<span>def <span class="ident">find_client</span></span>(<span>self, host:str, port:int) ><a title="client.blackhat.helpers.Result" href="helpers.html#client.blackhat.helpers.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_client(self, host: str, port: int) -&gt; Result:
    # Check if the given `host` belongs to us or its in an external lan
    prefix = &#34;.&#34;.join(self.lan.split(&#34;.&#34;)[0:2]) + &#34;.&#34;
    subnet = host.split(&#34;.&#34;)[2]

    if host == self.wan:
        if port in self.port_forwarding.keys():
            return Result(success=True, data=self.port_forwarding[port].services[port])
        return Result(success=False, message=ResultMessages.NOT_FOUND)

    # We&#39;re finding one of our own
    if host.startswith(prefix):
        # Quick check, if subnet is empty, we don&#39;t have the client
        get_subnet = self.clients.get(int(subnet))
        if not get_subnet:
            return Result(success=False, message=ResultMessages.NOT_FOUND)
        # We can ignore the port because we don&#39;t need port forwarding in a lan
        client_result = next((x for x in get_subnet.values() if x.lan == host), None)
        if not client_result:
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        # Now we need to check if the client has a service on that port
        # In real life, we wouldn&#39;t be able to make a connection if there is no service
        # on the given port
        if port not in client_result.services.keys():
            return Result(success=False, message=ResultMessages.NOT_FOUND)

        return Result(success=True, data=client_result.services.get(port))

    # We need to get the client from another lan, ask the ISP to handle it
    return self.parent.find_client(host, port)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></b></code>:
<ul class="hlist">
<li><code><a title="client.blackhat.computer.Computer.add_group" href="#client.blackhat.computer.Computer.add_group">add_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.add_user" href="#client.blackhat.computer.Computer.add_user">add_user</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.add_user_to_group" href="#client.blackhat.computer.Computer.add_user_to_group">add_user_to_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.change_user_password" href="#client.blackhat.computer.Computer.change_user_password">change_user_password</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.change_user_uid" href="#client.blackhat.computer.Computer.change_user_uid">change_user_uid</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.create_root_user" href="#client.blackhat.computer.Computer.create_root_user">create_root_user</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.delete_group" href="#client.blackhat.computer.Computer.delete_group">delete_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.delete_user" href="#client.blackhat.computer.Computer.delete_user">delete_user</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_all_groups" href="#client.blackhat.computer.Computer.get_all_groups">get_all_groups</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_all_users" href="#client.blackhat.computer.Computer.get_all_users">get_all_users</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_env" href="#client.blackhat.computer.Computer.get_env">get_env</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_group" href="#client.blackhat.computer.Computer.get_group">get_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_user" href="#client.blackhat.computer.Computer.get_user">get_user</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_user_groups" href="#client.blackhat.computer.Computer.get_user_groups">get_user_groups</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_user_primary_group" href="#client.blackhat.computer.Computer.get_user_primary_group">get_user_primary_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_users_in_group" href="#client.blackhat.computer.Computer.get_users_in_group">get_users_in_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.init" href="#client.blackhat.computer.Computer.init">init</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.post_fs_init" href="#client.blackhat.computer.Computer.post_fs_init">post_fs_init</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.remove_user_from_group" href="#client.blackhat.computer.Computer.remove_user_from_group">remove_user_from_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.resolve_dns" href="#client.blackhat.computer.Computer.resolve_dns">resolve_dns</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.run_command" href="#client.blackhat.computer.Computer.run_command">run_command</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.run_current_user_shellrc" href="#client.blackhat.computer.Computer.run_current_user_shellrc">run_current_user_shellrc</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.save" href="#client.blackhat.computer.Computer.save">save</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.set_env" href="#client.blackhat.computer.Computer.set_env">set_env</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sync_hostname" href="#client.blackhat.computer.Computer.sync_hostname">sync_hostname</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sync_user_and_group_files" href="#client.blackhat.computer.Computer.sync_user_and_group_files">sync_user_and_group_files</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_access" href="#client.blackhat.computer.Computer.sys_access">sys_access</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_chdir" href="#client.blackhat.computer.Computer.sys_chdir">sys_chdir</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_chmod" href="#client.blackhat.computer.Computer.sys_chmod">sys_chmod</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_chown" href="#client.blackhat.computer.Computer.sys_chown">sys_chown</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_creat" href="#client.blackhat.computer.Computer.sys_creat">sys_creat</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_execv" href="#client.blackhat.computer.Computer.sys_execv">sys_execv</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_execvp" href="#client.blackhat.computer.Computer.sys_execvp">sys_execvp</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_exit" href="#client.blackhat.computer.Computer.sys_exit">sys_exit</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_getcwd" href="#client.blackhat.computer.Computer.sys_getcwd">sys_getcwd</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_getgid" href="#client.blackhat.computer.Computer.sys_getgid">sys_getgid</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_gethostname" href="#client.blackhat.computer.Computer.sys_gethostname">sys_gethostname</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_gettimeofday" href="#client.blackhat.computer.Computer.sys_gettimeofday">sys_gettimeofday</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_getuid" href="#client.blackhat.computer.Computer.sys_getuid">sys_getuid</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_mkdir" href="#client.blackhat.computer.Computer.sys_mkdir">sys_mkdir</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_read" href="#client.blackhat.computer.Computer.sys_read">sys_read</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_reboot" href="#client.blackhat.computer.Computer.sys_reboot">sys_reboot</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_rename" href="#client.blackhat.computer.Computer.sys_rename">sys_rename</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_rmdir" href="#client.blackhat.computer.Computer.sys_rmdir">sys_rmdir</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_sethostname" href="#client.blackhat.computer.Computer.sys_sethostname">sys_sethostname</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_setuid" href="#client.blackhat.computer.Computer.sys_setuid">sys_setuid</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_stat" href="#client.blackhat.computer.Computer.sys_stat">sys_stat</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_unlink" href="#client.blackhat.computer.Computer.sys_unlink">sys_unlink</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_write" href="#client.blackhat.computer.Computer.sys_write">sys_write</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.update_libs" href="#client.blackhat.computer.Computer.update_libs">update_libs</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="client.blackhat" href="index.html">client.blackhat</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code></h4>
<ul class="">
<li><code><a title="client.blackhat.computer.Computer.add_group" href="#client.blackhat.computer.Computer.add_group">add_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.add_user" href="#client.blackhat.computer.Computer.add_user">add_user</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.add_user_to_group" href="#client.blackhat.computer.Computer.add_user_to_group">add_user_to_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.change_user_password" href="#client.blackhat.computer.Computer.change_user_password">change_user_password</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.change_user_uid" href="#client.blackhat.computer.Computer.change_user_uid">change_user_uid</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.create_root_user" href="#client.blackhat.computer.Computer.create_root_user">create_root_user</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.delete_group" href="#client.blackhat.computer.Computer.delete_group">delete_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.delete_user" href="#client.blackhat.computer.Computer.delete_user">delete_user</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_all_groups" href="#client.blackhat.computer.Computer.get_all_groups">get_all_groups</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_all_users" href="#client.blackhat.computer.Computer.get_all_users">get_all_users</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_env" href="#client.blackhat.computer.Computer.get_env">get_env</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_group" href="#client.blackhat.computer.Computer.get_group">get_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_user" href="#client.blackhat.computer.Computer.get_user">get_user</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_user_groups" href="#client.blackhat.computer.Computer.get_user_groups">get_user_groups</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_user_primary_group" href="#client.blackhat.computer.Computer.get_user_primary_group">get_user_primary_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_users_in_group" href="#client.blackhat.computer.Computer.get_users_in_group">get_users_in_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.init" href="#client.blackhat.computer.Computer.init">init</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.post_fs_init" href="#client.blackhat.computer.Computer.post_fs_init">post_fs_init</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.remove_user_from_group" href="#client.blackhat.computer.Computer.remove_user_from_group">remove_user_from_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.resolve_dns" href="#client.blackhat.computer.Computer.resolve_dns">resolve_dns</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.run_command" href="#client.blackhat.computer.Computer.run_command">run_command</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.run_current_user_shellrc" href="#client.blackhat.computer.Computer.run_current_user_shellrc">run_current_user_shellrc</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.save" href="#client.blackhat.computer.Computer.save">save</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.set_env" href="#client.blackhat.computer.Computer.set_env">set_env</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sync_hostname" href="#client.blackhat.computer.Computer.sync_hostname">sync_hostname</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sync_user_and_group_files" href="#client.blackhat.computer.Computer.sync_user_and_group_files">sync_user_and_group_files</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_access" href="#client.blackhat.computer.Computer.sys_access">sys_access</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_chdir" href="#client.blackhat.computer.Computer.sys_chdir">sys_chdir</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_chmod" href="#client.blackhat.computer.Computer.sys_chmod">sys_chmod</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_chown" href="#client.blackhat.computer.Computer.sys_chown">sys_chown</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_creat" href="#client.blackhat.computer.Computer.sys_creat">sys_creat</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_execv" href="#client.blackhat.computer.Computer.sys_execv">sys_execv</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_execvp" href="#client.blackhat.computer.Computer.sys_execvp">sys_execvp</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_exit" href="#client.blackhat.computer.Computer.sys_exit">sys_exit</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_getcwd" href="#client.blackhat.computer.Computer.sys_getcwd">sys_getcwd</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_getgid" href="#client.blackhat.computer.Computer.sys_getgid">sys_getgid</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_gethostname" href="#client.blackhat.computer.Computer.sys_gethostname">sys_gethostname</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_gettimeofday" href="#client.blackhat.computer.Computer.sys_gettimeofday">sys_gettimeofday</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_getuid" href="#client.blackhat.computer.Computer.sys_getuid">sys_getuid</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_mkdir" href="#client.blackhat.computer.Computer.sys_mkdir">sys_mkdir</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_read" href="#client.blackhat.computer.Computer.sys_read">sys_read</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_reboot" href="#client.blackhat.computer.Computer.sys_reboot">sys_reboot</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_rename" href="#client.blackhat.computer.Computer.sys_rename">sys_rename</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_rmdir" href="#client.blackhat.computer.Computer.sys_rmdir">sys_rmdir</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_sethostname" href="#client.blackhat.computer.Computer.sys_sethostname">sys_sethostname</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_setuid" href="#client.blackhat.computer.Computer.sys_setuid">sys_setuid</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_stat" href="#client.blackhat.computer.Computer.sys_stat">sys_stat</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_unlink" href="#client.blackhat.computer.Computer.sys_unlink">sys_unlink</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.sys_write" href="#client.blackhat.computer.Computer.sys_write">sys_write</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.update_libs" href="#client.blackhat.computer.Computer.update_libs">update_libs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="client.blackhat.computer.ISPRouter" href="#client.blackhat.computer.ISPRouter">ISPRouter</a></code></h4>
<ul class="">
<li><code><a title="client.blackhat.computer.ISPRouter.add_new_client" href="#client.blackhat.computer.ISPRouter.add_new_client">add_new_client</a></code></li>
<li><code><a title="client.blackhat.computer.ISPRouter.dhcp" href="#client.blackhat.computer.ISPRouter.dhcp">dhcp</a></code></li>
<li><code><a title="client.blackhat.computer.ISPRouter.find_client" href="#client.blackhat.computer.ISPRouter.find_client">find_client</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="client.blackhat.computer.Router" href="#client.blackhat.computer.Router">Router</a></code></h4>
<ul class="">
<li><code><a title="client.blackhat.computer.Router.add_new_client" href="#client.blackhat.computer.Router.add_new_client">add_new_client</a></code></li>
<li><code><a title="client.blackhat.computer.Router.dhcp" href="#client.blackhat.computer.Router.dhcp">dhcp</a></code></li>
<li><code><a title="client.blackhat.computer.Router.find_client" href="#client.blackhat.computer.Router.find_client">find_client</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html><style>body {
    background-color: #121212;
    color: white;
}

#sidebar {
    background-color: #242424;
}

#sidebar code {
    background-color: #282828 !important;
}


a {
    color: #8c00f7 !important;
}

.name {
    background-color: #1a1a1a !important;
}

code {
    background-color: #1a1a1a !important;
}

pre {
    background-color: #242424 !important;
    border-top: #242424 !important;
    border-bottom: #242424 !important;
    overflow-x: hidden !important;
}


h1:target, h2:target, h3:target, h4:target, h5:target, h6:target{
    background: #8c00f7
}

/* Modify color syntax highlighting */
.hljs {
    display: block;
    overflow-x: auto;
    padding: .5em;
    color: white !important;
    background: #f8f8f8
}

.hljs-comment,
.hljs-quote {
    color: #998;
    font-style: italic
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-subst {
    color: dodgerblue !important;
    font-weight: 700
}

.hljs-literal,
.hljs-number,
.hljs-tag .hljs-attr,
.hljs-template-variable,
.hljs-variable {
    color: teal
}

.hljs-doctag,
.hljs-string {
    color: #d14
}

.hljs-section,
.hljs-selector-id,
.hljs-title {
    color: #900;
    font-weight: 700
}

.hljs-subst {
    font-weight: 400
}

.hljs-class .hljs-title,
.hljs-type {
    color: #458;
    font-weight: 700
}

.hljs-attribute,
.hljs-name,
.hljs-tag {
    color: navy;
    font-weight: 400
}

.hljs-link,
.hljs-regexp {
    color: #009926
}

.hljs-bullet,
.hljs-symbol {
    color: #990073
}

.hljs-built_in,
.hljs-builtin-name {
    color: #0086b3
}

.hljs-meta {
    color: #999;
    font-weight: 700
}

.hljs-deletion {
    background: #fdd
}

.hljs-addition {
    background: #dfd
}

.hljs-emphasis {
    font-style: italic
}

.hljs-strong {
    font-weight: 700
}

/* Custom scrollbar */
/* width */
::-webkit-scrollbar {
    width: 10px;
}

/* Track */
::-webkit-scrollbar-track {
    box-shadow: inset 0 0 2.5px grey;
    border-radius: 5px;
}

/* Handle */
::-webkit-scrollbar-thumb {
    background: gray;
    border-radius: 5px;
}

/* Handle on hover */
::-webkit-scrollbar-thumb:hover {
    background: #6b6b6b;
}

@media only screen and (max-width: 600px) {
    pre {
        overflow: scroll !important;
    }

    pre::-webkit-scrollbar {
        display: none !important;
    }
}</style>
