<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>client.blackhat.computer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>client.blackhat.computer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import importlib
import ipaddress
import os
import pickle
import sqlite3
from hashlib import md5
from random import choice, randint
from secrets import token_hex
from time import perf_counter
from typing import Optional, Dict, Union, List, Literal

from .fs import Directory, File, StandardFS
from .helpers import SysCallStatus, SysCallMessages
from .services.service import Service
from .session import Session
from .user import User, Group


class Computer:
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        The class object representing a basic linux computer. This class is the base for all nodes on a network
        &#34;&#34;&#34;
        self.connection = sqlite3.connect(&#34;blackhat.db&#34;)
        self.database = self.connection.cursor()
        self.boot_time = perf_counter()
        self.parent: Optional[Computer, Router, ISPRouter] = None  # Router
        self.hostname: Optional[str] = None
        self.users: Dict[int, User] = {}
        self.groups: Dict[int, Group] = {}
        self.sessions: List[Session] = []
        self.lan = None
        self.id = token_hex(8)
        self.shell = None
        # Root user needs to be created before the FS is initialized (FS needs root to have a password to create /etc/passwd)
        self.init()

        # self.create_root_user()

        self.fs: StandardFS = StandardFS(self)
        self.services: dict[int, Service] = {}
        self.post_fs_init()

    def init(self) -&gt; None:
        &#34;&#34;&#34;
        Functions ran when a computer is booted (pre file-system setup/pre root user creation)

        Returns:
            None
        &#34;&#34;&#34;
        # Try to setup the user, group, and group membership tables
        init_tables = open(&#34;blackhat/database/init_tables.sql&#34;).read()
        self.database.executescript(init_tables)

        # Check if the computer we&#39;re initializing already exists in the database (we&#39;re loading an existing save)
        result = self.database.execute(&#34;SELECT * FROM computer WHERE id=?&#34;, (self.id,)).fetchall()

        if len(result) == 0:
            # We&#39;re starting a new save, lets save a copy of this computers id in the database, along with create the root user
            self.database.execute(&#34;INSERT INTO computer VALUES (?)&#34;, (self.id,))
            self.create_root_user()
            self.connection.commit()

    def post_fs_init(self) -&gt; None:
        &#34;&#34;&#34;
        Function ran after the file system and root user were initialized

        Returns:
            None
        &#34;&#34;&#34;
        self.update_hostname()
        self.update_passwd()
        self.update_groups()

    def run_command(self, command: str, args: Union[str, List[str], None], pipe: bool) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Runs a system binary or an external binary

        Args:
            command (str): The command or binary to run
            args (list): A list of arguments passed to the command or binary
            pipe (bool): If a pipe was used (used for routing input/output)

        Returns:
            SysCallStatus: A `SysCallStatus` object that contains a success status and some response data (changed on a case-by-case basis)
        &#34;&#34;&#34;
        # TODO: Instead of checking the bin_dir, check the `PATH` environment var (split by :) (do the same in `run_binary`)
        # The way that the path works is that if there are 2 binaries with the same name in 2 different directories,
        # The one that matches first in the path gets run
        # For example, if ls is in /etc/ and in /bin/ and the path is PATH=/home:/bin:/etc, the one in bin will run
        # For example, if ls is in /etc/ and in /bin/ and the path is PATH=/home:/etc:/bin, the one in etc will run
        bin_dir = self.fs.files.find(&#34;bin&#34;)
        if not bin_dir:
            print(f&#34;{command}: command not found&#34;)
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

        if command not in list(bin_dir.files.keys()):
            print(f&#34;{command}: command not found&#34;)
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

        try:
            module = importlib.import_module(f&#34;blackhat.bin.{command}&#34;)
            response = module.main(self, args, pipe)
            if os.getenv(&#34;DEBUGMODE&#34;) == &#34;false&#34;:
                self.save()

            return response
        except ImportError as e:
            print(f&#34;There was an error when running command: {command}&#34;)
            return SysCallStatus(success=False, message=SysCallMessages.GENERIC)

    def update_hostname(self) -&gt; None:
        &#34;&#34;&#34;
        Reads /etc/hostname and sets the system hostname accordingly
        If /etc/hostname doesn&#39;t exist, the hostname is set to &#34;localhost&#34;

        Returns:
            None
        &#34;&#34;&#34;
        etc_dir: Directory = self.fs.files.find(&#34;etc&#34;)

        if not etc_dir:
            self.hostname = &#34;localhost&#34;

        else:
            hostname_file: File = etc_dir.find(&#34;hostname&#34;)

            if not hostname_file:
                self.hostname = &#34;localhost&#34;
            else:
                self.hostname = hostname_file.content.split(&#34;\n&#34;)[0]

    def add_user(self, username: str, password: str, uid: Optional[int] = None) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Add a new user to the system.
        This function also generates the UID for the new user (unless manually specified)

        Args:
            username (str): The username for the new user
            password (str): The plaintext password for the new user
            uid (int, optional): The UID of the new user

        Returns:
            SysCallStatus: A `SysCallStatus` instance with the `success` flag set appropriately. The `data` flag contains the new users UID if successful.
        &#34;&#34;&#34;
        if self.find_user(username=username).success:
            return SysCallStatus(success=False, message=SysCallMessages.ALREADY_EXISTS)

        # new_user = User(username)
        # new_user.set_password(password)

        # Manually specific UID
        if uid:
            # Check if a user with the given UID already exists
            if self.find_user(uid=uid).success:
                return SysCallStatus(success=False, message=SysCallMessages.ALREADY_EXISTS)
            else:
                next_uid = uid
        # Auto-generate the UID (depending on the situation)
        else:
            # We&#39;re creating our root user, there isn&#39;t going to be a previous UID
            users = self.get_all_users().data
            if len(users) == 0:
                next_uid = 0
            else:
                # Get the UID from the previously created user
                last_uid = users[-1].uid
                if last_uid == 0:
                    next_uid = 1000
                else:
                    next_uid = last_uid + 1

        # Hash the password before saving to the database
        hashed_password = md5(password.encode()).hexdigest()

        # Create the new user
        self.database.execute(&#34;INSERT INTO blackhat_user (uid, username, password, computer_id) VALUES (?, ?, ?, ?)&#34;,
                              (next_uid, username, hashed_password, self.id))
        self.connection.commit()

        return SysCallStatus(success=True, data=next_uid)

    def delete_user(self, username: str) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Deletes a user from the system (by username)

        Args:
            username (str): The username of the user to delete

        Returns:
            SysCallStatus: A `SysCallStatus` instance with the `success` flag set appropriately.
        &#34;&#34;&#34;
        if self.find_user(username=username).success:
            self.database.execute(&#34;DELETE FROM blackhat_user WHERE computer_id=? and username=?&#34;, (self.id, username))
            self.connection.commit()
            return SysCallStatus(success=True)

        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    def change_user_password(self, uid: int, new_password: str) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Change the password of the user by uid

        Args:
            uid (int): The UID of the `User` to change the password of
            new_password (str): The MD5 hash of the password

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set accordingly.
        &#34;&#34;&#34;
        # Double check that the user with the given UID exists
        lookup_user = self.find_user(uid=uid)
        if not lookup_user.success:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

        # Hash the plain text password
        password_hash = md5(new_password.encode()).hexdigest()

        # Update the password in the database
        result = self.database.execute(&#34;UPDATE blackhat_user SET password=? WHERE uid=? AND computer_id=?&#34;,
                                       (password_hash, uid, self.id))
        self.connection.commit()
        return SysCallStatus(success=True)

    def add_group(self, name: str, gid: Optional[int] = None) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Add a new group to the system.
        This function also generates the GID for the new group (unless manually specified)

        Args:
            name (str): The name for the new group
            gid (int, optional): The GID of the new user

        Returns:
            SysCallStatus: A `SysCallStatus` instance with the `success` flag set appropriately. The `data` flag contains the GID if successful.
        &#34;&#34;&#34;
        if self.find_group(name=name).success:
            return SysCallStatus(success=False, message=SysCallMessages.ALREADY_EXISTS)

        if gid:
            # Check if a group with the given GID already exists
            if self.find_group(gid=gid, name=name).success:
                return SysCallStatus(success=False, message=SysCallMessages.ALREADY_EXISTS)
            else:
                next_gid = gid
        else:
            # Auto-generate the GID (depending on the situation)
            groups = self.get_all_groups().data
            if len(groups) == 0:
                next_gid = 0
            else:
                # Get the GID from the previously created group
                last_gid = groups[-1].gid
                if last_gid == 0:
                    next_gid = 1000
                else:
                    next_gid = last_gid + 1

        # Create the new group and commit
        self.database.execute(&#34;INSERT INTO blackhat_group (gid, name, computer_id) VALUES (?, ?, ?)&#34;,
                              (next_gid, name, self.id))
        self.connection.commit()

        return SysCallStatus(success=True, data=next_gid)

    def delete_group(self, name: str) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Deletes a group from the system (by name)

        Args:
            name (str): The name of the group to delete

        Returns:
            SysCallStatus: A `SysCallStatus` instance with the `success` flag set appropriately.
        &#34;&#34;&#34;
        if self.find_group(name=name).success:
            self.database.execute(&#34;DELETE FROM blackhat_group WHERE computer_id=? and name=?&#34;, (self.id, name))
            self.connection.commit()
            return SysCallStatus(success=True)

        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    def add_user_to_group(self, uid: int, gid: int,
                          membership_type: Literal[&#34;primary&#34;, &#34;secondary&#34;] = &#34;secondary&#34;) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Add a user to a group (by uid and gid)

        Args:
            uid (int): The UID of the user
            gid (int): The GID of the group to add the user to
            membership_type (str): The type of group relationship (primary, secondary)

        Returns:
            SysCallStatus: A `SysCallStatus` object with the `success` flag set accordingly
        &#34;&#34;&#34;
        # Confirm that both user and group exists
        if self.find_user(uid=uid).success and self.find_group(gid=gid).success:
            self.database.execute(
                &#34;INSERT INTO group_membership (computer_id, user_uid, group_gid, membership_type) VALUES (?, ?, ?, ?)&#34;,
                (self.id, uid, gid, membership_type))
            self.connection.commit()
            return SysCallStatus(success=True)
        else:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    def find_user_groups(self, uid: int) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Get the list of `Group` GID&#39;s that the `User` belongs to (by UID)

        Args:
            uid (int): The UID of the user to lookup

        Returns:
            SysCallStatus: A `SysCallStatus` with the `data` flag containing a list of GIDs
        &#34;&#34;&#34;
        # Double check if the user exists
        if not self.find_user(uid=uid).success:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)
        else:
            # Ask the database for the GIDs
            result = self.database.execute(&#34;SELECT group_gid FROM group_membership WHERE computer_id=? and user_uid=?;&#34;,
                                           (self.id, uid)).fetchall()
            return SysCallStatus(success=True, data=[x[0] for x in result])

    def remove_user_from_group(self, uid: int, gid: int) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Remove a user from a group (by uid and gid)

        Args:
            uid (int): The UID of the user
            gid (int): The GID of the group to remove the user from

        Returns:
            SysCallStatus: A `SysCallStatus` object with the `success` flag set accordingly
        &#34;&#34;&#34;
        # Confirm that both user and group exists
        if self.find_user(uid=uid).success and self.find_group(gid=gid).success:
            self.database.execute(&#34;DELETE FROM group_membership WHERE computer_id=? AND user_uid=? and group_gid=?&#34;,
                                  (self.id, uid, gid))
            self.connection.commit()
            return SysCallStatus(success=True)
        else:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    def find_user(self, uid: Optional[int] = None, username: Optional[str] = None) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Find a user in the database by UID or username
        Args:
            uid (int, optional): The UID of the user to find
            username (str, optional): The username of the user to find

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set accordingly. The `data` flag contains the user dict if found
        &#34;&#34;&#34;
        if uid is None and username is None:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)
        else:
            result = self.database.execute(&#34;SELECT * FROM blackhat_user WHERE (uid=? OR username=?) AND computer_id=?&#34;,
                                           (uid, username, self.id)).fetchone()
            if not result:
                return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

            return SysCallStatus(success=True,
                                 data=User(uid=result[1], username=result[2], password=result[3], full_name=result[4],
                                           room_number=result[5],
                                           work_phone=result[6], home_phone=result[7], other=result[8]))

    def find_group(self, gid: Optional[int] = None, name: Optional[str] = None) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Find a group in the database by GID or name or both
        Args:
            gid (int, optional): The GID of the group to find
            name (str, optional): The name of the group to find

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set accordingly. The `data` flag contains the group dict if found
        &#34;&#34;&#34;
        if gid is None and name is None:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)
        # We&#39;re looking by name AND gid
        elif gid is not None and name is not None:
            result = self.database.execute(&#34;SELECT * FROM blackhat_group WHERE (gid=? AND name=?) AND computer_id=?&#34;,
                                           (gid, name, self.id)).fetchone()
        else:
            result = self.database.execute(&#34;SELECT * FROM blackhat_group WHERE (gid=? OR name=?) AND computer_id=?&#34;,
                                           (gid, name, self.id)).fetchone()

        if not result:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

        return SysCallStatus(success=True, data=Group(gid=result[1], name=result[2]))

    def get_all_users(self) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Get all users that exist in the given system in the given format:

        Returns:
            SysCallStatus: A `SysCallStatus` with the `data` flag containing the array of `User`s
        &#34;&#34;&#34;
        all_users = self.database.execute(&#34;SELECT * FROM blackhat_user WHERE computer_id=?&#34;,
                                          (self.id,)).fetchall()

        clean_users = []

        for user in all_users:
            clean_users.append(
                User(uid=user[1], username=user[2], password=user[3], full_name=user[4], room_number=user[5],
                     work_phone=user[6], home_phone=user[7], other=user[8]))
        return SysCallStatus(success=True, data=clean_users)

    def get_all_groups(self) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Get all groups that exist in the given system in the given format:

        Returns:
            SysCallStatus: A `SysCallStatus` with the `data` flag containing the array of `Group`s
        &#34;&#34;&#34;
        all_groups = self.database.execute(&#34;SELECT * FROM blackhat_group WHERE computer_id=?&#34;,
                                           (self.id,)).fetchall()

        clean_groups = []

        for group in all_groups:
            clean_groups.append(Group(gid=group[1], name=group[2]))
        return SysCallStatus(success=True, data=clean_groups)

    def create_root_user(self) -&gt; None:
        &#34;&#34;&#34;
        Since the root user is different from &#34;standard&#34; users, and it must exist in any given system, it is manually
        created when the `Computer` is first initialized.

        Returns:
            None
        &#34;&#34;&#34;
        # Add the root user with a random password
        # self.add_user(&#34;root&#34;, &#39;&#39;.join([choice(ascii_uppercase + digits) for _ in range(16)]))
        self.add_user(&#34;root&#34;, &#34;password&#34;, uid=0)
        # Create the root group
        self.add_group(&#39;root&#39;, 0)

        # Add root to the root group
        self.add_user_to_group(0, 0, membership_type=&#34;primary&#34;)

    def update_passwd(self) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Makes sure that /etc/passwd matches our internal user map

        Returns:
            None
        &#34;&#34;&#34;
        etc_dir: Directory = self.fs.files.find(&#34;etc&#34;)

        if not etc_dir:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

        passwd_file: File = etc_dir.find(&#34;passwd&#34;)

        passwd_content = &#34;&#34;

        for user in self.get_all_users().data:
            # Find the &#34;primary&#34; group
            passwd_content += f&#34;{user.username}:{user.password}:{user.uid}\n&#34;

        if not passwd_file:
            # Create the /etc/passwd
            etc_dir.add_file(File(&#34;passwd&#34;, passwd_content, etc_dir, 0, 0))
        else:
            passwd_file.content = passwd_content

        return SysCallStatus(success=True)

    def update_groups(self) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Makes sure that /etc/group matches our internal groups map

        Returns:
            None
        &#34;&#34;&#34;
        etc_dir: Directory = self.fs.files.find(&#34;etc&#34;)

        if not etc_dir:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

        group_file: File = etc_dir.find(&#34;group&#34;)

        group_content = &#34;&#34;

        for group in self.get_all_groups().data:
            group_content += f&#34;{group.name}:x:{group.gid}\n&#34;

        if not group_file:
            # Create the /etc/groups
            etc_dir.add_file(File(&#34;group&#34;, group_content, etc_dir, 0, 0))
        else:
            group_file.content = group_content

        return SysCallStatus(success=True)

    def get_uid(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the UID of the `Computer`&#39;s current user
        Returns:
            int: UID of the `Computers`&#39;s current user (from most recent session)
        &#34;&#34;&#34;
        return self.sessions[-1].effective_uid

    def get_gid(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the (primary) GID of the `Computer`&#39;s current user
        Returns:
            int: (primary) GID of the `Computers`&#39;s current user (from most recent session)
        &#34;&#34;&#34;
        current_uid = self.get_uid()
        result = self.database.execute(
            &#34;SELECT group_gid FROM group_membership WHERE computer_id=? AND user_uid=? AND membership_type=?&#34;,
            (self.id, current_uid, &#34;primary&#34;)).fetchone()

        if result:
            return result[0]
        else:
            # NOTE: possible exploit, but maybe we leave it here on purpose?
            # TODO: Write proof of concept exploit to exploit this exploit
            return 0

    def run_current_user_shellrc(self):
        &#34;&#34;&#34;
        Run the .shellrc file in the current user&#39;s home folder (/home/&lt;USERNAME&gt;/.shellrc)
        The &#34;.shellrc&#34; file is replicating the behavior of .bashrc/.bash_profile/.zshrc (since we&#39;re not replicating one specific piece of software)

        Returns:
            None
        &#34;&#34;&#34;
        current_username = self.find_user(self.get_uid()).data.username

        # Don&#39;t check /home/username, check /root for .shellrc
        if self.get_uid() == 0:
            shellrc_loc = &#34;/root/.shellrc&#34;
        else:
            shellrc_loc = f&#34;/home/{current_username}/.shellrc&#34;

        shellrc_lookup = self.fs.find(shellrc_loc)

        if shellrc_lookup.success:
            shellrc_lines = shellrc_lookup.data.read(self.get_uid(), self)

            if shellrc_lines.success:
                for line in shellrc_lines.data.split(&#34;\n&#34;):
                    if line != &#34;&#34;:
                        line = line.split()
                        result = self.run_command(line[0], line[1:], pipe=False)

    def save(self, output_file: str = &#34;blackhat.save&#34;) -&gt; bool:
        &#34;&#34;&#34;
        Serialize and dump the current `Computer` (and everything that&#39;s connected to it (`StandardFS`, `File`s, etc)) to a file
        Args:
            output_file (str, optional): The file to dump the contents to

        Returns:
            bool: `True` if the dump/save was successful, otherwise `False`
        &#34;&#34;&#34;
        if os.getenv(&#34;DEBUGMODE&#34;) == &#34;false&#34;:
            try:
                with open(output_file, &#34;wb&#34;) as f:
                    pickle.dump(self, f, pickle.HIGHEST_PROTOCOL)
                return True
            except Exception as e:
                # TODO: Fix save bug (can&#39;t pickle `self.connection` and `self.database`)
                return False
        else:
            return True

    def handle_tcp_connection(self, host: str, port: int, args: dict) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Route network traffic to a `Service` on the local `Computer`

        Args:
            host (str): The IP of the `Computer`
            port (int): The port the given `Service` in running on
            args (dict): A map of arguments to pass to the given `Service`

        Returns:
            SysCallMessage: A response generate by the `Service` or an error if no such `Service` exists.
        &#34;&#34;&#34;
        if port in self.services.keys():
            return self.services[port].main(args)

        return SysCallStatus(success=False, message=SysCallMessages.GENERIC_NETWORK)

    def send_tcp(self, host: str, port: int, args: dict) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Pass a network connection to the router to route (either within the LAN or to an external LAN)

        Args:
            host (str): The IP address of the host to send the given `args` to
            port (int): The port on the given `host` in which the `Service` runs on
            args (dict): The data to send to the given `host` (processed by the `Service` on the other end)

        Returns:
            SysCallMessage: A response generate by the `Service` or an error if no such `Service` exists.
        &#34;&#34;&#34;
        return self.parent.handle_tcp_connection(host, port, args)


class Router(Computer):
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        This special type of `Computer` is made for handling network traffic between computers in a LAN
        This class represents what a real router would be in real life
        &#34;&#34;&#34;
        super().__init__()
        self.clients = {}  # Format of clients: sorted by VLAN then ID [1][2] (VLAN 1 - ID 2)
        self.ip_pool: dict[int, list[str]] = {}
        self.wan = None
        self.lan = &#34;192.168.1.1&#34;
        self.port_forwarding = {}

    def dhcp(self, vlan: int) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Distributes IP addresses to clients on the network

        Args:
            vlan (int): VLAN id to assign the client to

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the IP to assign to a given client.
        &#34;&#34;&#34;
        # Split the router&#39;s IP to get the first 16 bits
        ip_split = self.lan.split(&#34;.&#34;)
        network_prefix = f&#34;{ip_split[0]}.{ip_split[1]}.{vlan}&#34;

        # Check if the IP pool for that VLAN was generated already
        try:
            len(self.ip_pool[vlan])
        # If `self.ip_pool[&lt;VLAN&gt;]` returns a key error, it was never created before
        except KeyError:
            # Generate a list of ips that are &lt;NETWORK_PREFIX&gt;.&lt;VLAN&gt;.1-256
            self.ip_pool[vlan] = [f&#34;{network_prefix}.{x}&#34; for x in range(1, 257)]

        # Check if we have IP&#39;s left
        if len(self.ip_pool[vlan]) == 0:
            return SysCallStatus(success=False, message=SysCallMessages.EMPTY)

        # Choose a random ip from the pool
        ip = choice(self.ip_pool[vlan])

        # Remove the IP from the pool since it&#39;s in use
        self.ip_pool[vlan].remove(ip)
        return SysCallStatus(success=True, data=ip)

    def find_local_client(self, ip: str) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Finds a client (`Computer` object) in the local network by IP address

        Args:
            ip (str): The &#34;private&#34; IP of the client `Computer` to find

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the `Computer` object if found.
        &#34;&#34;&#34;
        vlan = ip.split(&#34;.&#34;)[2]
        for client in self.clients[int(vlan)].values():
            if client.lan == ip:
                return SysCallStatus(success=True, data=client)

        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    def find_client(self, ip: str, port: Optional[int] = None) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        A more &#34;general&#34; version of the `find_local_client()` function. This function determines if the given router will
        ask the `ISPRouter` for the given IP address or if the client is within the `Router`&#39;s LAN

        Args:
            ip (str): The IP of the client `Computer` to find
            port (int, optional): The open port on the given client (find `Computer` behind another `Router` in an external LAN)

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the `Computer` object if found.
        &#34;&#34;&#34;
        # Check if the client belongs to ourselves (don&#39;t ask isp)
        ip_split = self.lan.split(&#34;.&#34;)
        network_prefix = f&#34;{ip_split[0]}.{ip_split[1]}&#34;

        # First check if we&#39;re looking for one of our own hosts
        if ip.startswith(network_prefix):
            # We&#39;re looking for ourselves
            if ip == self.lan:
                return SysCallStatus(success=True, data=self)
            else:
                client_ip_split = ip.split(&#34;.&#34;)
                vlan = client_ip_split[2]
                vlan_result = self.clients.get(vlan)
                if vlan_result:
                    client_result = vlan_result.get(ip)

                    if client_result:
                        return SysCallStatus(success=True, data=client_result)

                return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)
        else:

            # If the given ip is our wan address, another router is asking for a client
            if ip == self.wan:
                # If there is no port, we want the router (ourselves)
                if not port:
                    return SysCallStatus(success=True, data=self)
                else:
                    # We want a host at a specific open port
                    return self.find_client_by_port(port)
            # We&#39;re trying to find a client on another router, we do this by asking our router (the isp)
            else:
                # Ask the ISP for the router
                wan_client = self.parent.find_client(ip, port)
                if wan_client.success:
                    # We found the other router
                    # If there&#39;s no port, we&#39;re done (we wanted the router not a host behind the router)
                    if not port:
                        return SysCallStatus(success=True, data=wan_client)
                    else:
                        # If there is a port, we want to ask the external router for the client behind that port
                        # We can ask that router directly
                        return wan_client.data.find_client_by_port(port)
                else:
                    # Even the ISP couldn&#39;t find that router, it must not exist
                    return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    def find_client_by_port(self, port: int) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Find a client in the given `Router`&#39;s LAN by open port.
        Primarily used for finding the `Computer` hosting a given `Service` through an open port in the given `Router`

        Args:
            port (int): The port number (1-65535) of the given `Computer`

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the `Computer` object if found.
        &#34;&#34;&#34;

        ip_to_find = self.port_forwarding.get(port, None)
        if not ip_to_find:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)
        else:
            return SysCallStatus(success=True, data=ip_to_find)

    def add_new_client(self, client: Computer, vlan: int = 1) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Connect a given `Computer` to the given `Router`&#39;s LAN.
        Also, assign an IP address using the `dhcp()` function.

        Args:
            client (Computer): The `Computer` instance to connect to the `Router`&#39;s LAN
            vlan (int, optional): The VLAN id to assign the given `Computer` to

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the `client`&#39;s newly assigned IP address if successful.
        &#34;&#34;&#34;
        # Generate an IP for the client
        generate_ip_status = self.dhcp(vlan)
        # We we&#39;re unable to generate an IP for the given client
        if not generate_ip_status:
            return generate_ip_status

        # Assign the IP
        client.lan = generate_ip_status.data

        # Append to client to our client list
        try:
            last_id = list(self.clients[vlan].keys())[-1]
        except KeyError:
            last_id = 0

        # Check if the client vlan exists
        try:
            len(self.clients[vlan])
        except KeyError:
            # Init the vlan (empty)
            self.clients[vlan] = {}

        self.clients[vlan][last_id + 1] = client

        client.parent = self

        return SysCallStatus(success=True, data=client.lan)

    def resolve_dns(self, domain_name: str) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Ask the ISP to resolve a dns domain name to an IP address

        Args:
            domain_name (str): The domain name to resolve

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the IP of the given `domain_name` if found.
        &#34;&#34;&#34;
        # Ask our parent (ISP router) to resolve a dns record
        return self.parent.resolve_dns(domain_name)

    def handle_tcp_connection(self, host: str, port: int, args: dict) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Handle network traffic routing within the `Router`&#39;s LAN and between LANs

        Args:
            host (str): The IP address of the host to send the given `args` to
            port (int): The port on the given `host` in which the `Service` runs on
            args (dict): The data to send to the given `host` (processed by the `Service` on the other end)

        Returns:
            SysCallStatus: A `SysCallStatus` instance containing results about the connection (successful or not) and a response from the `Service` (if successful)
        &#34;&#34;&#34;
        # If we don&#39;t manually check for our own ip, we end up in an infinite loop of trying to handle tcp connections
        if host == self.lan:
            if port in self.services.keys():
                return self.services[port].main(args)
            else:
                return SysCallStatus(success=False, message=SysCallMessages.GENERIC_NETWORK)
        client = self.find_client(host, port)
        if not client.success:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)
        else:
            return client.data.handle_tcp_connection(host, port, args)


class ISPRouter(Router):
    def __init__(self):
        &#34;&#34;&#34;
        An ISP router is just a router of routers
        &#34;&#34;&#34;
        super().__init__()
        # We&#39;re 1.1.1.1
        self.used_ips = [&#34;1.1.1.1&#34;]
        self.dns_records = {}

    def dhcp(self, **kwargs) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Distributes IP addresses to clients on the network

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the IP to assign to a given client.
        &#34;&#34;&#34;
        while True:
            ip = &#34;.&#34;.join([str(randint(1, 256)) for _ in range(4)])
            if ip not in self.used_ips:
                self.used_ips.append(ip)
                return SysCallStatus(success=True, data=ip)

    def find_client(self, ip: str, port: Optional[int] = None) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Finds a client `Computer` in connected to the given `ISPRouter`

        Args:
            ip (str): The IP of the client `Computer` to find
            port (int, optional): The open port on the given client (find `Computer` behind another `Router` in an external LAN)

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the `Computer` object if found.
        &#34;&#34;&#34;
        # Check if the computer we&#39;re looking for is ourselves (isp)
        if ip == self.lan:
            return SysCallStatus(success=True, data=self)

        # Check if the client is an IP or a domain
        try:
            is_ipv4 = ipaddress.ip_address(ip)
        except ValueError:
            is_ipv4 = False

        if not is_ipv4:
            # Try to resolve the given dns record
            dns_result = self.resolve_dns(ip)

            if not dns_result.success:
                return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)
            else:
                ip = dns_result.data

        find_client = next((x for x in self.clients.values() if x.wan == ip), None)
        if find_client:
            return SysCallStatus(success=True, data=find_client)

        # Client not found
        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    def add_new_client(self, client: Router, **kwargs) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Connect a given `Computer` to the given `ISPRouter`
        Also, assign an IP address using the `dhcp()` function.

        Args:
            client (Computer): The `Computer` instance to connect to the `ISPRouter`

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the `client`&#39;s newly assigned IP address if successful.
        &#34;&#34;&#34;
        dhcp_result = self.dhcp()
        if dhcp_result.success:
            client.wan = dhcp_result.data
            client.parent = self
            self.clients[client.wan] = client
            return SysCallStatus(success=True, data=client.wan)
        else:
            # Failed for some reason (DHCP will give us our error)
            return dhcp_result

    def add_dns_record(self, domain_name: str, ip: str) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Add a new record to the given `ISPRouters` DNS records table

        Args:
            domain_name (str): The domain name of the record
            ip (str): The IP address that the given `domain_name` should resolve to

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately.
        &#34;&#34;&#34;
        if domain_name in self.dns_records.keys():
            return SysCallStatus(success=False, message=SysCallMessages.ALREADY_EXISTS)

        self.dns_records[domain_name] = ip
        return SysCallStatus(success=True)

    def remove_dns_record(self, domain_name):
        &#34;&#34;&#34;
        Remove an existing record from the given `ISPRouters` DNS records table

        Args:
            domain_name (str): The domain name of the record to be removed

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately.
        &#34;&#34;&#34;
        if domain_name in self.dns_records.keys():
            del self.dns_records[domain_name]
            return SysCallStatus(success=True)

        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    def resolve_dns(self, domain_name: str) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Find the IP address linked to the given `domain_name`

        Args:
            domain_name (str): The domain name to resolve

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the resolved IP address if found.
        &#34;&#34;&#34;
        dns_record = self.dns_records.get(domain_name, None)
        if dns_record:
            return SysCallStatus(success=True, data=dns_record)

        # Failed to find
        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="client.blackhat.computer.Computer"><code class="flex name class">
<span>class <span class="ident">Computer</span></span>
</code></dt>
<dd>
<div class="desc"><p>The class object representing a basic linux computer. This class is the base for all nodes on a network</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Computer:
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        The class object representing a basic linux computer. This class is the base for all nodes on a network
        &#34;&#34;&#34;
        self.connection = sqlite3.connect(&#34;blackhat.db&#34;)
        self.database = self.connection.cursor()
        self.boot_time = perf_counter()
        self.parent: Optional[Computer, Router, ISPRouter] = None  # Router
        self.hostname: Optional[str] = None
        self.users: Dict[int, User] = {}
        self.groups: Dict[int, Group] = {}
        self.sessions: List[Session] = []
        self.lan = None
        self.id = token_hex(8)
        self.shell = None
        # Root user needs to be created before the FS is initialized (FS needs root to have a password to create /etc/passwd)
        self.init()

        # self.create_root_user()

        self.fs: StandardFS = StandardFS(self)
        self.services: dict[int, Service] = {}
        self.post_fs_init()

    def init(self) -&gt; None:
        &#34;&#34;&#34;
        Functions ran when a computer is booted (pre file-system setup/pre root user creation)

        Returns:
            None
        &#34;&#34;&#34;
        # Try to setup the user, group, and group membership tables
        init_tables = open(&#34;blackhat/database/init_tables.sql&#34;).read()
        self.database.executescript(init_tables)

        # Check if the computer we&#39;re initializing already exists in the database (we&#39;re loading an existing save)
        result = self.database.execute(&#34;SELECT * FROM computer WHERE id=?&#34;, (self.id,)).fetchall()

        if len(result) == 0:
            # We&#39;re starting a new save, lets save a copy of this computers id in the database, along with create the root user
            self.database.execute(&#34;INSERT INTO computer VALUES (?)&#34;, (self.id,))
            self.create_root_user()
            self.connection.commit()

    def post_fs_init(self) -&gt; None:
        &#34;&#34;&#34;
        Function ran after the file system and root user were initialized

        Returns:
            None
        &#34;&#34;&#34;
        self.update_hostname()
        self.update_passwd()
        self.update_groups()

    def run_command(self, command: str, args: Union[str, List[str], None], pipe: bool) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Runs a system binary or an external binary

        Args:
            command (str): The command or binary to run
            args (list): A list of arguments passed to the command or binary
            pipe (bool): If a pipe was used (used for routing input/output)

        Returns:
            SysCallStatus: A `SysCallStatus` object that contains a success status and some response data (changed on a case-by-case basis)
        &#34;&#34;&#34;
        # TODO: Instead of checking the bin_dir, check the `PATH` environment var (split by :) (do the same in `run_binary`)
        # The way that the path works is that if there are 2 binaries with the same name in 2 different directories,
        # The one that matches first in the path gets run
        # For example, if ls is in /etc/ and in /bin/ and the path is PATH=/home:/bin:/etc, the one in bin will run
        # For example, if ls is in /etc/ and in /bin/ and the path is PATH=/home:/etc:/bin, the one in etc will run
        bin_dir = self.fs.files.find(&#34;bin&#34;)
        if not bin_dir:
            print(f&#34;{command}: command not found&#34;)
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

        if command not in list(bin_dir.files.keys()):
            print(f&#34;{command}: command not found&#34;)
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

        try:
            module = importlib.import_module(f&#34;blackhat.bin.{command}&#34;)
            response = module.main(self, args, pipe)
            if os.getenv(&#34;DEBUGMODE&#34;) == &#34;false&#34;:
                self.save()

            return response
        except ImportError as e:
            print(f&#34;There was an error when running command: {command}&#34;)
            return SysCallStatus(success=False, message=SysCallMessages.GENERIC)

    def update_hostname(self) -&gt; None:
        &#34;&#34;&#34;
        Reads /etc/hostname and sets the system hostname accordingly
        If /etc/hostname doesn&#39;t exist, the hostname is set to &#34;localhost&#34;

        Returns:
            None
        &#34;&#34;&#34;
        etc_dir: Directory = self.fs.files.find(&#34;etc&#34;)

        if not etc_dir:
            self.hostname = &#34;localhost&#34;

        else:
            hostname_file: File = etc_dir.find(&#34;hostname&#34;)

            if not hostname_file:
                self.hostname = &#34;localhost&#34;
            else:
                self.hostname = hostname_file.content.split(&#34;\n&#34;)[0]

    def add_user(self, username: str, password: str, uid: Optional[int] = None) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Add a new user to the system.
        This function also generates the UID for the new user (unless manually specified)

        Args:
            username (str): The username for the new user
            password (str): The plaintext password for the new user
            uid (int, optional): The UID of the new user

        Returns:
            SysCallStatus: A `SysCallStatus` instance with the `success` flag set appropriately. The `data` flag contains the new users UID if successful.
        &#34;&#34;&#34;
        if self.find_user(username=username).success:
            return SysCallStatus(success=False, message=SysCallMessages.ALREADY_EXISTS)

        # new_user = User(username)
        # new_user.set_password(password)

        # Manually specific UID
        if uid:
            # Check if a user with the given UID already exists
            if self.find_user(uid=uid).success:
                return SysCallStatus(success=False, message=SysCallMessages.ALREADY_EXISTS)
            else:
                next_uid = uid
        # Auto-generate the UID (depending on the situation)
        else:
            # We&#39;re creating our root user, there isn&#39;t going to be a previous UID
            users = self.get_all_users().data
            if len(users) == 0:
                next_uid = 0
            else:
                # Get the UID from the previously created user
                last_uid = users[-1].uid
                if last_uid == 0:
                    next_uid = 1000
                else:
                    next_uid = last_uid + 1

        # Hash the password before saving to the database
        hashed_password = md5(password.encode()).hexdigest()

        # Create the new user
        self.database.execute(&#34;INSERT INTO blackhat_user (uid, username, password, computer_id) VALUES (?, ?, ?, ?)&#34;,
                              (next_uid, username, hashed_password, self.id))
        self.connection.commit()

        return SysCallStatus(success=True, data=next_uid)

    def delete_user(self, username: str) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Deletes a user from the system (by username)

        Args:
            username (str): The username of the user to delete

        Returns:
            SysCallStatus: A `SysCallStatus` instance with the `success` flag set appropriately.
        &#34;&#34;&#34;
        if self.find_user(username=username).success:
            self.database.execute(&#34;DELETE FROM blackhat_user WHERE computer_id=? and username=?&#34;, (self.id, username))
            self.connection.commit()
            return SysCallStatus(success=True)

        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    def change_user_password(self, uid: int, new_password: str) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Change the password of the user by uid

        Args:
            uid (int): The UID of the `User` to change the password of
            new_password (str): The MD5 hash of the password

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set accordingly.
        &#34;&#34;&#34;
        # Double check that the user with the given UID exists
        lookup_user = self.find_user(uid=uid)
        if not lookup_user.success:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

        # Hash the plain text password
        password_hash = md5(new_password.encode()).hexdigest()

        # Update the password in the database
        result = self.database.execute(&#34;UPDATE blackhat_user SET password=? WHERE uid=? AND computer_id=?&#34;,
                                       (password_hash, uid, self.id))
        self.connection.commit()
        return SysCallStatus(success=True)

    def add_group(self, name: str, gid: Optional[int] = None) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Add a new group to the system.
        This function also generates the GID for the new group (unless manually specified)

        Args:
            name (str): The name for the new group
            gid (int, optional): The GID of the new user

        Returns:
            SysCallStatus: A `SysCallStatus` instance with the `success` flag set appropriately. The `data` flag contains the GID if successful.
        &#34;&#34;&#34;
        if self.find_group(name=name).success:
            return SysCallStatus(success=False, message=SysCallMessages.ALREADY_EXISTS)

        if gid:
            # Check if a group with the given GID already exists
            if self.find_group(gid=gid, name=name).success:
                return SysCallStatus(success=False, message=SysCallMessages.ALREADY_EXISTS)
            else:
                next_gid = gid
        else:
            # Auto-generate the GID (depending on the situation)
            groups = self.get_all_groups().data
            if len(groups) == 0:
                next_gid = 0
            else:
                # Get the GID from the previously created group
                last_gid = groups[-1].gid
                if last_gid == 0:
                    next_gid = 1000
                else:
                    next_gid = last_gid + 1

        # Create the new group and commit
        self.database.execute(&#34;INSERT INTO blackhat_group (gid, name, computer_id) VALUES (?, ?, ?)&#34;,
                              (next_gid, name, self.id))
        self.connection.commit()

        return SysCallStatus(success=True, data=next_gid)

    def delete_group(self, name: str) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Deletes a group from the system (by name)

        Args:
            name (str): The name of the group to delete

        Returns:
            SysCallStatus: A `SysCallStatus` instance with the `success` flag set appropriately.
        &#34;&#34;&#34;
        if self.find_group(name=name).success:
            self.database.execute(&#34;DELETE FROM blackhat_group WHERE computer_id=? and name=?&#34;, (self.id, name))
            self.connection.commit()
            return SysCallStatus(success=True)

        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    def add_user_to_group(self, uid: int, gid: int,
                          membership_type: Literal[&#34;primary&#34;, &#34;secondary&#34;] = &#34;secondary&#34;) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Add a user to a group (by uid and gid)

        Args:
            uid (int): The UID of the user
            gid (int): The GID of the group to add the user to
            membership_type (str): The type of group relationship (primary, secondary)

        Returns:
            SysCallStatus: A `SysCallStatus` object with the `success` flag set accordingly
        &#34;&#34;&#34;
        # Confirm that both user and group exists
        if self.find_user(uid=uid).success and self.find_group(gid=gid).success:
            self.database.execute(
                &#34;INSERT INTO group_membership (computer_id, user_uid, group_gid, membership_type) VALUES (?, ?, ?, ?)&#34;,
                (self.id, uid, gid, membership_type))
            self.connection.commit()
            return SysCallStatus(success=True)
        else:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    def find_user_groups(self, uid: int) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Get the list of `Group` GID&#39;s that the `User` belongs to (by UID)

        Args:
            uid (int): The UID of the user to lookup

        Returns:
            SysCallStatus: A `SysCallStatus` with the `data` flag containing a list of GIDs
        &#34;&#34;&#34;
        # Double check if the user exists
        if not self.find_user(uid=uid).success:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)
        else:
            # Ask the database for the GIDs
            result = self.database.execute(&#34;SELECT group_gid FROM group_membership WHERE computer_id=? and user_uid=?;&#34;,
                                           (self.id, uid)).fetchall()
            return SysCallStatus(success=True, data=[x[0] for x in result])

    def remove_user_from_group(self, uid: int, gid: int) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Remove a user from a group (by uid and gid)

        Args:
            uid (int): The UID of the user
            gid (int): The GID of the group to remove the user from

        Returns:
            SysCallStatus: A `SysCallStatus` object with the `success` flag set accordingly
        &#34;&#34;&#34;
        # Confirm that both user and group exists
        if self.find_user(uid=uid).success and self.find_group(gid=gid).success:
            self.database.execute(&#34;DELETE FROM group_membership WHERE computer_id=? AND user_uid=? and group_gid=?&#34;,
                                  (self.id, uid, gid))
            self.connection.commit()
            return SysCallStatus(success=True)
        else:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    def find_user(self, uid: Optional[int] = None, username: Optional[str] = None) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Find a user in the database by UID or username
        Args:
            uid (int, optional): The UID of the user to find
            username (str, optional): The username of the user to find

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set accordingly. The `data` flag contains the user dict if found
        &#34;&#34;&#34;
        if uid is None and username is None:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)
        else:
            result = self.database.execute(&#34;SELECT * FROM blackhat_user WHERE (uid=? OR username=?) AND computer_id=?&#34;,
                                           (uid, username, self.id)).fetchone()
            if not result:
                return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

            return SysCallStatus(success=True,
                                 data=User(uid=result[1], username=result[2], password=result[3], full_name=result[4],
                                           room_number=result[5],
                                           work_phone=result[6], home_phone=result[7], other=result[8]))

    def find_group(self, gid: Optional[int] = None, name: Optional[str] = None) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Find a group in the database by GID or name or both
        Args:
            gid (int, optional): The GID of the group to find
            name (str, optional): The name of the group to find

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set accordingly. The `data` flag contains the group dict if found
        &#34;&#34;&#34;
        if gid is None and name is None:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)
        # We&#39;re looking by name AND gid
        elif gid is not None and name is not None:
            result = self.database.execute(&#34;SELECT * FROM blackhat_group WHERE (gid=? AND name=?) AND computer_id=?&#34;,
                                           (gid, name, self.id)).fetchone()
        else:
            result = self.database.execute(&#34;SELECT * FROM blackhat_group WHERE (gid=? OR name=?) AND computer_id=?&#34;,
                                           (gid, name, self.id)).fetchone()

        if not result:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

        return SysCallStatus(success=True, data=Group(gid=result[1], name=result[2]))

    def get_all_users(self) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Get all users that exist in the given system in the given format:

        Returns:
            SysCallStatus: A `SysCallStatus` with the `data` flag containing the array of `User`s
        &#34;&#34;&#34;
        all_users = self.database.execute(&#34;SELECT * FROM blackhat_user WHERE computer_id=?&#34;,
                                          (self.id,)).fetchall()

        clean_users = []

        for user in all_users:
            clean_users.append(
                User(uid=user[1], username=user[2], password=user[3], full_name=user[4], room_number=user[5],
                     work_phone=user[6], home_phone=user[7], other=user[8]))
        return SysCallStatus(success=True, data=clean_users)

    def get_all_groups(self) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Get all groups that exist in the given system in the given format:

        Returns:
            SysCallStatus: A `SysCallStatus` with the `data` flag containing the array of `Group`s
        &#34;&#34;&#34;
        all_groups = self.database.execute(&#34;SELECT * FROM blackhat_group WHERE computer_id=?&#34;,
                                           (self.id,)).fetchall()

        clean_groups = []

        for group in all_groups:
            clean_groups.append(Group(gid=group[1], name=group[2]))
        return SysCallStatus(success=True, data=clean_groups)

    def create_root_user(self) -&gt; None:
        &#34;&#34;&#34;
        Since the root user is different from &#34;standard&#34; users, and it must exist in any given system, it is manually
        created when the `Computer` is first initialized.

        Returns:
            None
        &#34;&#34;&#34;
        # Add the root user with a random password
        # self.add_user(&#34;root&#34;, &#39;&#39;.join([choice(ascii_uppercase + digits) for _ in range(16)]))
        self.add_user(&#34;root&#34;, &#34;password&#34;, uid=0)
        # Create the root group
        self.add_group(&#39;root&#39;, 0)

        # Add root to the root group
        self.add_user_to_group(0, 0, membership_type=&#34;primary&#34;)

    def update_passwd(self) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Makes sure that /etc/passwd matches our internal user map

        Returns:
            None
        &#34;&#34;&#34;
        etc_dir: Directory = self.fs.files.find(&#34;etc&#34;)

        if not etc_dir:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

        passwd_file: File = etc_dir.find(&#34;passwd&#34;)

        passwd_content = &#34;&#34;

        for user in self.get_all_users().data:
            # Find the &#34;primary&#34; group
            passwd_content += f&#34;{user.username}:{user.password}:{user.uid}\n&#34;

        if not passwd_file:
            # Create the /etc/passwd
            etc_dir.add_file(File(&#34;passwd&#34;, passwd_content, etc_dir, 0, 0))
        else:
            passwd_file.content = passwd_content

        return SysCallStatus(success=True)

    def update_groups(self) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Makes sure that /etc/group matches our internal groups map

        Returns:
            None
        &#34;&#34;&#34;
        etc_dir: Directory = self.fs.files.find(&#34;etc&#34;)

        if not etc_dir:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

        group_file: File = etc_dir.find(&#34;group&#34;)

        group_content = &#34;&#34;

        for group in self.get_all_groups().data:
            group_content += f&#34;{group.name}:x:{group.gid}\n&#34;

        if not group_file:
            # Create the /etc/groups
            etc_dir.add_file(File(&#34;group&#34;, group_content, etc_dir, 0, 0))
        else:
            group_file.content = group_content

        return SysCallStatus(success=True)

    def get_uid(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the UID of the `Computer`&#39;s current user
        Returns:
            int: UID of the `Computers`&#39;s current user (from most recent session)
        &#34;&#34;&#34;
        return self.sessions[-1].effective_uid

    def get_gid(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the (primary) GID of the `Computer`&#39;s current user
        Returns:
            int: (primary) GID of the `Computers`&#39;s current user (from most recent session)
        &#34;&#34;&#34;
        current_uid = self.get_uid()
        result = self.database.execute(
            &#34;SELECT group_gid FROM group_membership WHERE computer_id=? AND user_uid=? AND membership_type=?&#34;,
            (self.id, current_uid, &#34;primary&#34;)).fetchone()

        if result:
            return result[0]
        else:
            # NOTE: possible exploit, but maybe we leave it here on purpose?
            # TODO: Write proof of concept exploit to exploit this exploit
            return 0

    def run_current_user_shellrc(self):
        &#34;&#34;&#34;
        Run the .shellrc file in the current user&#39;s home folder (/home/&lt;USERNAME&gt;/.shellrc)
        The &#34;.shellrc&#34; file is replicating the behavior of .bashrc/.bash_profile/.zshrc (since we&#39;re not replicating one specific piece of software)

        Returns:
            None
        &#34;&#34;&#34;
        current_username = self.find_user(self.get_uid()).data.username

        # Don&#39;t check /home/username, check /root for .shellrc
        if self.get_uid() == 0:
            shellrc_loc = &#34;/root/.shellrc&#34;
        else:
            shellrc_loc = f&#34;/home/{current_username}/.shellrc&#34;

        shellrc_lookup = self.fs.find(shellrc_loc)

        if shellrc_lookup.success:
            shellrc_lines = shellrc_lookup.data.read(self.get_uid(), self)

            if shellrc_lines.success:
                for line in shellrc_lines.data.split(&#34;\n&#34;):
                    if line != &#34;&#34;:
                        line = line.split()
                        result = self.run_command(line[0], line[1:], pipe=False)

    def save(self, output_file: str = &#34;blackhat.save&#34;) -&gt; bool:
        &#34;&#34;&#34;
        Serialize and dump the current `Computer` (and everything that&#39;s connected to it (`StandardFS`, `File`s, etc)) to a file
        Args:
            output_file (str, optional): The file to dump the contents to

        Returns:
            bool: `True` if the dump/save was successful, otherwise `False`
        &#34;&#34;&#34;
        if os.getenv(&#34;DEBUGMODE&#34;) == &#34;false&#34;:
            try:
                with open(output_file, &#34;wb&#34;) as f:
                    pickle.dump(self, f, pickle.HIGHEST_PROTOCOL)
                return True
            except Exception as e:
                # TODO: Fix save bug (can&#39;t pickle `self.connection` and `self.database`)
                return False
        else:
            return True

    def handle_tcp_connection(self, host: str, port: int, args: dict) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Route network traffic to a `Service` on the local `Computer`

        Args:
            host (str): The IP of the `Computer`
            port (int): The port the given `Service` in running on
            args (dict): A map of arguments to pass to the given `Service`

        Returns:
            SysCallMessage: A response generate by the `Service` or an error if no such `Service` exists.
        &#34;&#34;&#34;
        if port in self.services.keys():
            return self.services[port].main(args)

        return SysCallStatus(success=False, message=SysCallMessages.GENERIC_NETWORK)

    def send_tcp(self, host: str, port: int, args: dict) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Pass a network connection to the router to route (either within the LAN or to an external LAN)

        Args:
            host (str): The IP address of the host to send the given `args` to
            port (int): The port on the given `host` in which the `Service` runs on
            args (dict): The data to send to the given `host` (processed by the `Service` on the other end)

        Returns:
            SysCallMessage: A response generate by the `Service` or an error if no such `Service` exists.
        &#34;&#34;&#34;
        return self.parent.handle_tcp_connection(host, port, args)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="client.blackhat.computer.Router" href="#client.blackhat.computer.Router">Router</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="client.blackhat.computer.Computer.add_group"><code class="name flex">
<span>def <span class="ident">add_group</span></span>(<span>self, name:str, gid:Optional[int]=None) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Add a new group to the system.
This function also generates the GID for the new group (unless manually specified)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name for the new group</dd>
<dt><strong><code>gid</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The GID of the new user</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> instance with the <code>success</code> flag set appropriately. The <code>data</code> flag contains the GID if successful.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_group(self, name: str, gid: Optional[int] = None) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Add a new group to the system.
    This function also generates the GID for the new group (unless manually specified)

    Args:
        name (str): The name for the new group
        gid (int, optional): The GID of the new user

    Returns:
        SysCallStatus: A `SysCallStatus` instance with the `success` flag set appropriately. The `data` flag contains the GID if successful.
    &#34;&#34;&#34;
    if self.find_group(name=name).success:
        return SysCallStatus(success=False, message=SysCallMessages.ALREADY_EXISTS)

    if gid:
        # Check if a group with the given GID already exists
        if self.find_group(gid=gid, name=name).success:
            return SysCallStatus(success=False, message=SysCallMessages.ALREADY_EXISTS)
        else:
            next_gid = gid
    else:
        # Auto-generate the GID (depending on the situation)
        groups = self.get_all_groups().data
        if len(groups) == 0:
            next_gid = 0
        else:
            # Get the GID from the previously created group
            last_gid = groups[-1].gid
            if last_gid == 0:
                next_gid = 1000
            else:
                next_gid = last_gid + 1

    # Create the new group and commit
    self.database.execute(&#34;INSERT INTO blackhat_group (gid, name, computer_id) VALUES (?, ?, ?)&#34;,
                          (next_gid, name, self.id))
    self.connection.commit()

    return SysCallStatus(success=True, data=next_gid)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.add_user"><code class="name flex">
<span>def <span class="ident">add_user</span></span>(<span>self, username:str, password:str, uid:Optional[int]=None) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Add a new user to the system.
This function also generates the UID for the new user (unless manually specified)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>username</code></strong> :&ensp;<code>str</code></dt>
<dd>The username for the new user</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>str</code></dt>
<dd>The plaintext password for the new user</dd>
<dt><strong><code>uid</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The UID of the new user</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> instance with the <code>success</code> flag set appropriately. The <code>data</code> flag contains the new users UID if successful.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_user(self, username: str, password: str, uid: Optional[int] = None) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Add a new user to the system.
    This function also generates the UID for the new user (unless manually specified)

    Args:
        username (str): The username for the new user
        password (str): The plaintext password for the new user
        uid (int, optional): The UID of the new user

    Returns:
        SysCallStatus: A `SysCallStatus` instance with the `success` flag set appropriately. The `data` flag contains the new users UID if successful.
    &#34;&#34;&#34;
    if self.find_user(username=username).success:
        return SysCallStatus(success=False, message=SysCallMessages.ALREADY_EXISTS)

    # new_user = User(username)
    # new_user.set_password(password)

    # Manually specific UID
    if uid:
        # Check if a user with the given UID already exists
        if self.find_user(uid=uid).success:
            return SysCallStatus(success=False, message=SysCallMessages.ALREADY_EXISTS)
        else:
            next_uid = uid
    # Auto-generate the UID (depending on the situation)
    else:
        # We&#39;re creating our root user, there isn&#39;t going to be a previous UID
        users = self.get_all_users().data
        if len(users) == 0:
            next_uid = 0
        else:
            # Get the UID from the previously created user
            last_uid = users[-1].uid
            if last_uid == 0:
                next_uid = 1000
            else:
                next_uid = last_uid + 1

    # Hash the password before saving to the database
    hashed_password = md5(password.encode()).hexdigest()

    # Create the new user
    self.database.execute(&#34;INSERT INTO blackhat_user (uid, username, password, computer_id) VALUES (?, ?, ?, ?)&#34;,
                          (next_uid, username, hashed_password, self.id))
    self.connection.commit()

    return SysCallStatus(success=True, data=next_uid)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.add_user_to_group"><code class="name flex">
<span>def <span class="ident">add_user_to_group</span></span>(<span>self, uid:int, gid:int, membership_type:Literal['primary','secondary']='secondary') ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Add a user to a group (by uid and gid)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>uid</code></strong> :&ensp;<code>int</code></dt>
<dd>The UID of the user</dd>
<dt><strong><code>gid</code></strong> :&ensp;<code>int</code></dt>
<dd>The GID of the group to add the user to</dd>
<dt><strong><code>membership_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of group relationship (primary, secondary)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> object with the <code>success</code> flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_user_to_group(self, uid: int, gid: int,
                      membership_type: Literal[&#34;primary&#34;, &#34;secondary&#34;] = &#34;secondary&#34;) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Add a user to a group (by uid and gid)

    Args:
        uid (int): The UID of the user
        gid (int): The GID of the group to add the user to
        membership_type (str): The type of group relationship (primary, secondary)

    Returns:
        SysCallStatus: A `SysCallStatus` object with the `success` flag set accordingly
    &#34;&#34;&#34;
    # Confirm that both user and group exists
    if self.find_user(uid=uid).success and self.find_group(gid=gid).success:
        self.database.execute(
            &#34;INSERT INTO group_membership (computer_id, user_uid, group_gid, membership_type) VALUES (?, ?, ?, ?)&#34;,
            (self.id, uid, gid, membership_type))
        self.connection.commit()
        return SysCallStatus(success=True)
    else:
        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.change_user_password"><code class="name flex">
<span>def <span class="ident">change_user_password</span></span>(<span>self, uid:int, new_password:str) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Change the password of the user by uid</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>uid</code></strong> :&ensp;<code>int</code></dt>
<dd>The UID of the <code>User</code> to change the password of</dd>
<dt><strong><code>new_password</code></strong> :&ensp;<code>str</code></dt>
<dd>The MD5 hash of the password</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> with the <code>success</code> flag set accordingly.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_user_password(self, uid: int, new_password: str) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Change the password of the user by uid

    Args:
        uid (int): The UID of the `User` to change the password of
        new_password (str): The MD5 hash of the password

    Returns:
        SysCallStatus: A `SysCallStatus` with the `success` flag set accordingly.
    &#34;&#34;&#34;
    # Double check that the user with the given UID exists
    lookup_user = self.find_user(uid=uid)
    if not lookup_user.success:
        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    # Hash the plain text password
    password_hash = md5(new_password.encode()).hexdigest()

    # Update the password in the database
    result = self.database.execute(&#34;UPDATE blackhat_user SET password=? WHERE uid=? AND computer_id=?&#34;,
                                   (password_hash, uid, self.id))
    self.connection.commit()
    return SysCallStatus(success=True)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.create_root_user"><code class="name flex">
<span>def <span class="ident">create_root_user</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Since the root user is different from "standard" users, and it must exist in any given system, it is manually
created when the <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> is first initialized.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_root_user(self) -&gt; None:
    &#34;&#34;&#34;
    Since the root user is different from &#34;standard&#34; users, and it must exist in any given system, it is manually
    created when the `Computer` is first initialized.

    Returns:
        None
    &#34;&#34;&#34;
    # Add the root user with a random password
    # self.add_user(&#34;root&#34;, &#39;&#39;.join([choice(ascii_uppercase + digits) for _ in range(16)]))
    self.add_user(&#34;root&#34;, &#34;password&#34;, uid=0)
    # Create the root group
    self.add_group(&#39;root&#39;, 0)

    # Add root to the root group
    self.add_user_to_group(0, 0, membership_type=&#34;primary&#34;)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.delete_group"><code class="name flex">
<span>def <span class="ident">delete_group</span></span>(<span>self, name:str) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a group from the system (by name)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the group to delete</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> instance with the <code>success</code> flag set appropriately.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_group(self, name: str) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Deletes a group from the system (by name)

    Args:
        name (str): The name of the group to delete

    Returns:
        SysCallStatus: A `SysCallStatus` instance with the `success` flag set appropriately.
    &#34;&#34;&#34;
    if self.find_group(name=name).success:
        self.database.execute(&#34;DELETE FROM blackhat_group WHERE computer_id=? and name=?&#34;, (self.id, name))
        self.connection.commit()
        return SysCallStatus(success=True)

    return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.delete_user"><code class="name flex">
<span>def <span class="ident">delete_user</span></span>(<span>self, username:str) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a user from the system (by username)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>username</code></strong> :&ensp;<code>str</code></dt>
<dd>The username of the user to delete</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> instance with the <code>success</code> flag set appropriately.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_user(self, username: str) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Deletes a user from the system (by username)

    Args:
        username (str): The username of the user to delete

    Returns:
        SysCallStatus: A `SysCallStatus` instance with the `success` flag set appropriately.
    &#34;&#34;&#34;
    if self.find_user(username=username).success:
        self.database.execute(&#34;DELETE FROM blackhat_user WHERE computer_id=? and username=?&#34;, (self.id, username))
        self.connection.commit()
        return SysCallStatus(success=True)

    return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.find_group"><code class="name flex">
<span>def <span class="ident">find_group</span></span>(<span>self, gid:Optional[int]=None, name:Optional[str]=None) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Find a group in the database by GID or name or both</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gid</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The GID of the group to find</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the group to find</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> with the <code>success</code> flag set accordingly. The <code>data</code> flag contains the group dict if found</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_group(self, gid: Optional[int] = None, name: Optional[str] = None) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Find a group in the database by GID or name or both
    Args:
        gid (int, optional): The GID of the group to find
        name (str, optional): The name of the group to find

    Returns:
        SysCallStatus: A `SysCallStatus` with the `success` flag set accordingly. The `data` flag contains the group dict if found
    &#34;&#34;&#34;
    if gid is None and name is None:
        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)
    # We&#39;re looking by name AND gid
    elif gid is not None and name is not None:
        result = self.database.execute(&#34;SELECT * FROM blackhat_group WHERE (gid=? AND name=?) AND computer_id=?&#34;,
                                       (gid, name, self.id)).fetchone()
    else:
        result = self.database.execute(&#34;SELECT * FROM blackhat_group WHERE (gid=? OR name=?) AND computer_id=?&#34;,
                                       (gid, name, self.id)).fetchone()

    if not result:
        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    return SysCallStatus(success=True, data=Group(gid=result[1], name=result[2]))</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.find_user"><code class="name flex">
<span>def <span class="ident">find_user</span></span>(<span>self, uid:Optional[int]=None, username:Optional[str]=None) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Find a user in the database by UID or username</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>uid</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The UID of the user to find</dd>
<dt><strong><code>username</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The username of the user to find</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> with the <code>success</code> flag set accordingly. The <code>data</code> flag contains the user dict if found</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_user(self, uid: Optional[int] = None, username: Optional[str] = None) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Find a user in the database by UID or username
    Args:
        uid (int, optional): The UID of the user to find
        username (str, optional): The username of the user to find

    Returns:
        SysCallStatus: A `SysCallStatus` with the `success` flag set accordingly. The `data` flag contains the user dict if found
    &#34;&#34;&#34;
    if uid is None and username is None:
        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)
    else:
        result = self.database.execute(&#34;SELECT * FROM blackhat_user WHERE (uid=? OR username=?) AND computer_id=?&#34;,
                                       (uid, username, self.id)).fetchone()
        if not result:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

        return SysCallStatus(success=True,
                             data=User(uid=result[1], username=result[2], password=result[3], full_name=result[4],
                                       room_number=result[5],
                                       work_phone=result[6], home_phone=result[7], other=result[8]))</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.find_user_groups"><code class="name flex">
<span>def <span class="ident">find_user_groups</span></span>(<span>self, uid:int) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get the list of <code>Group</code> GID's that the <code>User</code> belongs to (by UID)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>uid</code></strong> :&ensp;<code>int</code></dt>
<dd>The UID of the user to lookup</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> with the <code>data</code> flag containing a list of GIDs</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_user_groups(self, uid: int) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Get the list of `Group` GID&#39;s that the `User` belongs to (by UID)

    Args:
        uid (int): The UID of the user to lookup

    Returns:
        SysCallStatus: A `SysCallStatus` with the `data` flag containing a list of GIDs
    &#34;&#34;&#34;
    # Double check if the user exists
    if not self.find_user(uid=uid).success:
        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)
    else:
        # Ask the database for the GIDs
        result = self.database.execute(&#34;SELECT group_gid FROM group_membership WHERE computer_id=? and user_uid=?;&#34;,
                                       (self.id, uid)).fetchall()
        return SysCallStatus(success=True, data=[x[0] for x in result])</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.get_all_groups"><code class="name flex">
<span>def <span class="ident">get_all_groups</span></span>(<span>self) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get all groups that exist in the given system in the given format:</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> with the <code>data</code> flag containing the array of <code>Group</code>s</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_groups(self) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Get all groups that exist in the given system in the given format:

    Returns:
        SysCallStatus: A `SysCallStatus` with the `data` flag containing the array of `Group`s
    &#34;&#34;&#34;
    all_groups = self.database.execute(&#34;SELECT * FROM blackhat_group WHERE computer_id=?&#34;,
                                       (self.id,)).fetchall()

    clean_groups = []

    for group in all_groups:
        clean_groups.append(Group(gid=group[1], name=group[2]))
    return SysCallStatus(success=True, data=clean_groups)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.get_all_users"><code class="name flex">
<span>def <span class="ident">get_all_users</span></span>(<span>self) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get all users that exist in the given system in the given format:</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> with the <code>data</code> flag containing the array of <code>User</code>s</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_users(self) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Get all users that exist in the given system in the given format:

    Returns:
        SysCallStatus: A `SysCallStatus` with the `data` flag containing the array of `User`s
    &#34;&#34;&#34;
    all_users = self.database.execute(&#34;SELECT * FROM blackhat_user WHERE computer_id=?&#34;,
                                      (self.id,)).fetchall()

    clean_users = []

    for user in all_users:
        clean_users.append(
            User(uid=user[1], username=user[2], password=user[3], full_name=user[4], room_number=user[5],
                 work_phone=user[6], home_phone=user[7], other=user[8]))
    return SysCallStatus(success=True, data=clean_users)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.get_gid"><code class="name flex">
<span>def <span class="ident">get_gid</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the (primary) GID of the <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code>'s current user</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>(primary) GID of the <code>Computers</code>'s current user (from most recent session)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gid(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the (primary) GID of the `Computer`&#39;s current user
    Returns:
        int: (primary) GID of the `Computers`&#39;s current user (from most recent session)
    &#34;&#34;&#34;
    current_uid = self.get_uid()
    result = self.database.execute(
        &#34;SELECT group_gid FROM group_membership WHERE computer_id=? AND user_uid=? AND membership_type=?&#34;,
        (self.id, current_uid, &#34;primary&#34;)).fetchone()

    if result:
        return result[0]
    else:
        # NOTE: possible exploit, but maybe we leave it here on purpose?
        # TODO: Write proof of concept exploit to exploit this exploit
        return 0</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.get_uid"><code class="name flex">
<span>def <span class="ident">get_uid</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the UID of the <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code>'s current user</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>UID of the <code>Computers</code>'s current user (from most recent session)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_uid(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the UID of the `Computer`&#39;s current user
    Returns:
        int: UID of the `Computers`&#39;s current user (from most recent session)
    &#34;&#34;&#34;
    return self.sessions[-1].effective_uid</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.handle_tcp_connection"><code class="name flex">
<span>def <span class="ident">handle_tcp_connection</span></span>(<span>self, host:str, port:int, args:dict) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Route network traffic to a <code>Service</code> on the local <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong> :&ensp;<code>str</code></dt>
<dd>The IP of the <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code></dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>The port the given <code>Service</code> in running on</dd>
<dt><strong><code>args</code></strong> :&ensp;<code>dict</code></dt>
<dd>A map of arguments to pass to the given <code>Service</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallMessage</code></dt>
<dd>A response generate by the <code>Service</code> or an error if no such <code>Service</code> exists.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_tcp_connection(self, host: str, port: int, args: dict) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Route network traffic to a `Service` on the local `Computer`

    Args:
        host (str): The IP of the `Computer`
        port (int): The port the given `Service` in running on
        args (dict): A map of arguments to pass to the given `Service`

    Returns:
        SysCallMessage: A response generate by the `Service` or an error if no such `Service` exists.
    &#34;&#34;&#34;
    if port in self.services.keys():
        return self.services[port].main(args)

    return SysCallStatus(success=False, message=SysCallMessages.GENERIC_NETWORK)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Functions ran when a computer is booted (pre file-system setup/pre root user creation)</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init(self) -&gt; None:
    &#34;&#34;&#34;
    Functions ran when a computer is booted (pre file-system setup/pre root user creation)

    Returns:
        None
    &#34;&#34;&#34;
    # Try to setup the user, group, and group membership tables
    init_tables = open(&#34;blackhat/database/init_tables.sql&#34;).read()
    self.database.executescript(init_tables)

    # Check if the computer we&#39;re initializing already exists in the database (we&#39;re loading an existing save)
    result = self.database.execute(&#34;SELECT * FROM computer WHERE id=?&#34;, (self.id,)).fetchall()

    if len(result) == 0:
        # We&#39;re starting a new save, lets save a copy of this computers id in the database, along with create the root user
        self.database.execute(&#34;INSERT INTO computer VALUES (?)&#34;, (self.id,))
        self.create_root_user()
        self.connection.commit()</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.post_fs_init"><code class="name flex">
<span>def <span class="ident">post_fs_init</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Function ran after the file system and root user were initialized</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_fs_init(self) -&gt; None:
    &#34;&#34;&#34;
    Function ran after the file system and root user were initialized

    Returns:
        None
    &#34;&#34;&#34;
    self.update_hostname()
    self.update_passwd()
    self.update_groups()</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.remove_user_from_group"><code class="name flex">
<span>def <span class="ident">remove_user_from_group</span></span>(<span>self, uid:int, gid:int) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Remove a user from a group (by uid and gid)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>uid</code></strong> :&ensp;<code>int</code></dt>
<dd>The UID of the user</dd>
<dt><strong><code>gid</code></strong> :&ensp;<code>int</code></dt>
<dd>The GID of the group to remove the user from</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> object with the <code>success</code> flag set accordingly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_user_from_group(self, uid: int, gid: int) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Remove a user from a group (by uid and gid)

    Args:
        uid (int): The UID of the user
        gid (int): The GID of the group to remove the user from

    Returns:
        SysCallStatus: A `SysCallStatus` object with the `success` flag set accordingly
    &#34;&#34;&#34;
    # Confirm that both user and group exists
    if self.find_user(uid=uid).success and self.find_group(gid=gid).success:
        self.database.execute(&#34;DELETE FROM group_membership WHERE computer_id=? AND user_uid=? and group_gid=?&#34;,
                              (self.id, uid, gid))
        self.connection.commit()
        return SysCallStatus(success=True)
    else:
        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.run_command"><code class="name flex">
<span>def <span class="ident">run_command</span></span>(<span>self, command:str, args:Union[str,List[str],NoneType], pipe:bool) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Runs a system binary or an external binary</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong> :&ensp;<code>str</code></dt>
<dd>The command or binary to run</dd>
<dt><strong><code>args</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of arguments passed to the command or binary</dd>
<dt><strong><code>pipe</code></strong> :&ensp;<code>bool</code></dt>
<dd>If a pipe was used (used for routing input/output)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> object that contains a success status and some response data (changed on a case-by-case basis)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_command(self, command: str, args: Union[str, List[str], None], pipe: bool) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Runs a system binary or an external binary

    Args:
        command (str): The command or binary to run
        args (list): A list of arguments passed to the command or binary
        pipe (bool): If a pipe was used (used for routing input/output)

    Returns:
        SysCallStatus: A `SysCallStatus` object that contains a success status and some response data (changed on a case-by-case basis)
    &#34;&#34;&#34;
    # TODO: Instead of checking the bin_dir, check the `PATH` environment var (split by :) (do the same in `run_binary`)
    # The way that the path works is that if there are 2 binaries with the same name in 2 different directories,
    # The one that matches first in the path gets run
    # For example, if ls is in /etc/ and in /bin/ and the path is PATH=/home:/bin:/etc, the one in bin will run
    # For example, if ls is in /etc/ and in /bin/ and the path is PATH=/home:/etc:/bin, the one in etc will run
    bin_dir = self.fs.files.find(&#34;bin&#34;)
    if not bin_dir:
        print(f&#34;{command}: command not found&#34;)
        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    if command not in list(bin_dir.files.keys()):
        print(f&#34;{command}: command not found&#34;)
        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    try:
        module = importlib.import_module(f&#34;blackhat.bin.{command}&#34;)
        response = module.main(self, args, pipe)
        if os.getenv(&#34;DEBUGMODE&#34;) == &#34;false&#34;:
            self.save()

        return response
    except ImportError as e:
        print(f&#34;There was an error when running command: {command}&#34;)
        return SysCallStatus(success=False, message=SysCallMessages.GENERIC)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.run_current_user_shellrc"><code class="name flex">
<span>def <span class="ident">run_current_user_shellrc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the .shellrc file in the current user's home folder (/home/<USERNAME>/.shellrc)
The ".shellrc" file is replicating the behavior of .bashrc/.bash_profile/.zshrc (since we're not replicating one specific piece of software)</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_current_user_shellrc(self):
    &#34;&#34;&#34;
    Run the .shellrc file in the current user&#39;s home folder (/home/&lt;USERNAME&gt;/.shellrc)
    The &#34;.shellrc&#34; file is replicating the behavior of .bashrc/.bash_profile/.zshrc (since we&#39;re not replicating one specific piece of software)

    Returns:
        None
    &#34;&#34;&#34;
    current_username = self.find_user(self.get_uid()).data.username

    # Don&#39;t check /home/username, check /root for .shellrc
    if self.get_uid() == 0:
        shellrc_loc = &#34;/root/.shellrc&#34;
    else:
        shellrc_loc = f&#34;/home/{current_username}/.shellrc&#34;

    shellrc_lookup = self.fs.find(shellrc_loc)

    if shellrc_lookup.success:
        shellrc_lines = shellrc_lookup.data.read(self.get_uid(), self)

        if shellrc_lines.success:
            for line in shellrc_lines.data.split(&#34;\n&#34;):
                if line != &#34;&#34;:
                    line = line.split()
                    result = self.run_command(line[0], line[1:], pipe=False)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, output_file:str='blackhat.save') >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize and dump the current <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> (and everything that's connected to it (<code>StandardFS</code>, <code>File</code>s, etc)) to a file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>output_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The file to dump the contents to</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if the dump/save was successful, otherwise <code>False</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, output_file: str = &#34;blackhat.save&#34;) -&gt; bool:
    &#34;&#34;&#34;
    Serialize and dump the current `Computer` (and everything that&#39;s connected to it (`StandardFS`, `File`s, etc)) to a file
    Args:
        output_file (str, optional): The file to dump the contents to

    Returns:
        bool: `True` if the dump/save was successful, otherwise `False`
    &#34;&#34;&#34;
    if os.getenv(&#34;DEBUGMODE&#34;) == &#34;false&#34;:
        try:
            with open(output_file, &#34;wb&#34;) as f:
                pickle.dump(self, f, pickle.HIGHEST_PROTOCOL)
            return True
        except Exception as e:
            # TODO: Fix save bug (can&#39;t pickle `self.connection` and `self.database`)
            return False
    else:
        return True</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.send_tcp"><code class="name flex">
<span>def <span class="ident">send_tcp</span></span>(<span>self, host:str, port:int, args:dict) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Pass a network connection to the router to route (either within the LAN or to an external LAN)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong> :&ensp;<code>str</code></dt>
<dd>The IP address of the host to send the given <code>args</code> to</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>The port on the given <code>host</code> in which the <code>Service</code> runs on</dd>
<dt><strong><code>args</code></strong> :&ensp;<code>dict</code></dt>
<dd>The data to send to the given <code>host</code> (processed by the <code>Service</code> on the other end)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallMessage</code></dt>
<dd>A response generate by the <code>Service</code> or an error if no such <code>Service</code> exists.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_tcp(self, host: str, port: int, args: dict) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Pass a network connection to the router to route (either within the LAN or to an external LAN)

    Args:
        host (str): The IP address of the host to send the given `args` to
        port (int): The port on the given `host` in which the `Service` runs on
        args (dict): The data to send to the given `host` (processed by the `Service` on the other end)

    Returns:
        SysCallMessage: A response generate by the `Service` or an error if no such `Service` exists.
    &#34;&#34;&#34;
    return self.parent.handle_tcp_connection(host, port, args)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.update_groups"><code class="name flex">
<span>def <span class="ident">update_groups</span></span>(<span>self) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Makes sure that /etc/group matches our internal groups map</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_groups(self) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Makes sure that /etc/group matches our internal groups map

    Returns:
        None
    &#34;&#34;&#34;
    etc_dir: Directory = self.fs.files.find(&#34;etc&#34;)

    if not etc_dir:
        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    group_file: File = etc_dir.find(&#34;group&#34;)

    group_content = &#34;&#34;

    for group in self.get_all_groups().data:
        group_content += f&#34;{group.name}:x:{group.gid}\n&#34;

    if not group_file:
        # Create the /etc/groups
        etc_dir.add_file(File(&#34;group&#34;, group_content, etc_dir, 0, 0))
    else:
        group_file.content = group_content

    return SysCallStatus(success=True)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.update_hostname"><code class="name flex">
<span>def <span class="ident">update_hostname</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Reads /etc/hostname and sets the system hostname accordingly
If /etc/hostname doesn't exist, the hostname is set to "localhost"</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_hostname(self) -&gt; None:
    &#34;&#34;&#34;
    Reads /etc/hostname and sets the system hostname accordingly
    If /etc/hostname doesn&#39;t exist, the hostname is set to &#34;localhost&#34;

    Returns:
        None
    &#34;&#34;&#34;
    etc_dir: Directory = self.fs.files.find(&#34;etc&#34;)

    if not etc_dir:
        self.hostname = &#34;localhost&#34;

    else:
        hostname_file: File = etc_dir.find(&#34;hostname&#34;)

        if not hostname_file:
            self.hostname = &#34;localhost&#34;
        else:
            self.hostname = hostname_file.content.split(&#34;\n&#34;)[0]</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Computer.update_passwd"><code class="name flex">
<span>def <span class="ident">update_passwd</span></span>(<span>self) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Makes sure that /etc/passwd matches our internal user map</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_passwd(self) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Makes sure that /etc/passwd matches our internal user map

    Returns:
        None
    &#34;&#34;&#34;
    etc_dir: Directory = self.fs.files.find(&#34;etc&#34;)

    if not etc_dir:
        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    passwd_file: File = etc_dir.find(&#34;passwd&#34;)

    passwd_content = &#34;&#34;

    for user in self.get_all_users().data:
        # Find the &#34;primary&#34; group
        passwd_content += f&#34;{user.username}:{user.password}:{user.uid}\n&#34;

    if not passwd_file:
        # Create the /etc/passwd
        etc_dir.add_file(File(&#34;passwd&#34;, passwd_content, etc_dir, 0, 0))
    else:
        passwd_file.content = passwd_content

    return SysCallStatus(success=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="client.blackhat.computer.ISPRouter"><code class="flex name class">
<span>class <span class="ident">ISPRouter</span></span>
</code></dt>
<dd>
<div class="desc"><p>An ISP router is just a router of routers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ISPRouter(Router):
    def __init__(self):
        &#34;&#34;&#34;
        An ISP router is just a router of routers
        &#34;&#34;&#34;
        super().__init__()
        # We&#39;re 1.1.1.1
        self.used_ips = [&#34;1.1.1.1&#34;]
        self.dns_records = {}

    def dhcp(self, **kwargs) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Distributes IP addresses to clients on the network

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the IP to assign to a given client.
        &#34;&#34;&#34;
        while True:
            ip = &#34;.&#34;.join([str(randint(1, 256)) for _ in range(4)])
            if ip not in self.used_ips:
                self.used_ips.append(ip)
                return SysCallStatus(success=True, data=ip)

    def find_client(self, ip: str, port: Optional[int] = None) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Finds a client `Computer` in connected to the given `ISPRouter`

        Args:
            ip (str): The IP of the client `Computer` to find
            port (int, optional): The open port on the given client (find `Computer` behind another `Router` in an external LAN)

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the `Computer` object if found.
        &#34;&#34;&#34;
        # Check if the computer we&#39;re looking for is ourselves (isp)
        if ip == self.lan:
            return SysCallStatus(success=True, data=self)

        # Check if the client is an IP or a domain
        try:
            is_ipv4 = ipaddress.ip_address(ip)
        except ValueError:
            is_ipv4 = False

        if not is_ipv4:
            # Try to resolve the given dns record
            dns_result = self.resolve_dns(ip)

            if not dns_result.success:
                return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)
            else:
                ip = dns_result.data

        find_client = next((x for x in self.clients.values() if x.wan == ip), None)
        if find_client:
            return SysCallStatus(success=True, data=find_client)

        # Client not found
        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    def add_new_client(self, client: Router, **kwargs) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Connect a given `Computer` to the given `ISPRouter`
        Also, assign an IP address using the `dhcp()` function.

        Args:
            client (Computer): The `Computer` instance to connect to the `ISPRouter`

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the `client`&#39;s newly assigned IP address if successful.
        &#34;&#34;&#34;
        dhcp_result = self.dhcp()
        if dhcp_result.success:
            client.wan = dhcp_result.data
            client.parent = self
            self.clients[client.wan] = client
            return SysCallStatus(success=True, data=client.wan)
        else:
            # Failed for some reason (DHCP will give us our error)
            return dhcp_result

    def add_dns_record(self, domain_name: str, ip: str) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Add a new record to the given `ISPRouters` DNS records table

        Args:
            domain_name (str): The domain name of the record
            ip (str): The IP address that the given `domain_name` should resolve to

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately.
        &#34;&#34;&#34;
        if domain_name in self.dns_records.keys():
            return SysCallStatus(success=False, message=SysCallMessages.ALREADY_EXISTS)

        self.dns_records[domain_name] = ip
        return SysCallStatus(success=True)

    def remove_dns_record(self, domain_name):
        &#34;&#34;&#34;
        Remove an existing record from the given `ISPRouters` DNS records table

        Args:
            domain_name (str): The domain name of the record to be removed

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately.
        &#34;&#34;&#34;
        if domain_name in self.dns_records.keys():
            del self.dns_records[domain_name]
            return SysCallStatus(success=True)

        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    def resolve_dns(self, domain_name: str) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Find the IP address linked to the given `domain_name`

        Args:
            domain_name (str): The domain name to resolve

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the resolved IP address if found.
        &#34;&#34;&#34;
        dns_record = self.dns_records.get(domain_name, None)
        if dns_record:
            return SysCallStatus(success=True, data=dns_record)

        # Failed to find
        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="client.blackhat.computer.Router" href="#client.blackhat.computer.Router">Router</a></li>
<li><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="client.blackhat.computer.ISPRouter.add_dns_record"><code class="name flex">
<span>def <span class="ident">add_dns_record</span></span>(<span>self, domain_name:str, ip:str) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Add a new record to the given <code>ISPRouters</code> DNS records table</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>domain_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The domain name of the record</dd>
<dt><strong><code>ip</code></strong> :&ensp;<code>str</code></dt>
<dd>The IP address that the given <code>domain_name</code> should resolve to</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> with the <code>success</code> flag set appropriately.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_dns_record(self, domain_name: str, ip: str) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Add a new record to the given `ISPRouters` DNS records table

    Args:
        domain_name (str): The domain name of the record
        ip (str): The IP address that the given `domain_name` should resolve to

    Returns:
        SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately.
    &#34;&#34;&#34;
    if domain_name in self.dns_records.keys():
        return SysCallStatus(success=False, message=SysCallMessages.ALREADY_EXISTS)

    self.dns_records[domain_name] = ip
    return SysCallStatus(success=True)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.ISPRouter.add_new_client"><code class="name flex">
<span>def <span class="ident">add_new_client</span></span>(<span>self, client:<a title="client.blackhat.computer.Router" href="#client.blackhat.computer.Router">Router</a>, **kwargs) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Connect a given <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> to the given <code><a title="client.blackhat.computer.ISPRouter" href="#client.blackhat.computer.ISPRouter">ISPRouter</a></code>
Also, assign an IP address using the <code>dhcp()</code> function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code></dt>
<dd>The <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> instance to connect to the <code><a title="client.blackhat.computer.ISPRouter" href="#client.blackhat.computer.ISPRouter">ISPRouter</a></code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> with the <code>success</code> flag set appropriately. The <code>data</code> flag contains the <code>client</code>'s newly assigned IP address if successful.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_new_client(self, client: Router, **kwargs) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Connect a given `Computer` to the given `ISPRouter`
    Also, assign an IP address using the `dhcp()` function.

    Args:
        client (Computer): The `Computer` instance to connect to the `ISPRouter`

    Returns:
        SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the `client`&#39;s newly assigned IP address if successful.
    &#34;&#34;&#34;
    dhcp_result = self.dhcp()
    if dhcp_result.success:
        client.wan = dhcp_result.data
        client.parent = self
        self.clients[client.wan] = client
        return SysCallStatus(success=True, data=client.wan)
    else:
        # Failed for some reason (DHCP will give us our error)
        return dhcp_result</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.ISPRouter.dhcp"><code class="name flex">
<span>def <span class="ident">dhcp</span></span>(<span>self, **kwargs) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Distributes IP addresses to clients on the network</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> with the <code>success</code> flag set appropriately. The <code>data</code> flag contains the IP to assign to a given client.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dhcp(self, **kwargs) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Distributes IP addresses to clients on the network

    Returns:
        SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the IP to assign to a given client.
    &#34;&#34;&#34;
    while True:
        ip = &#34;.&#34;.join([str(randint(1, 256)) for _ in range(4)])
        if ip not in self.used_ips:
            self.used_ips.append(ip)
            return SysCallStatus(success=True, data=ip)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.ISPRouter.find_client"><code class="name flex">
<span>def <span class="ident">find_client</span></span>(<span>self, ip:str, port:Optional[int]=None) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Finds a client <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> in connected to the given <code><a title="client.blackhat.computer.ISPRouter" href="#client.blackhat.computer.ISPRouter">ISPRouter</a></code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ip</code></strong> :&ensp;<code>str</code></dt>
<dd>The IP of the client <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> to find</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The open port on the given client (find <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> behind another <code><a title="client.blackhat.computer.Router" href="#client.blackhat.computer.Router">Router</a></code> in an external LAN)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> with the <code>success</code> flag set appropriately. The <code>data</code> flag contains the <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> object if found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_client(self, ip: str, port: Optional[int] = None) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Finds a client `Computer` in connected to the given `ISPRouter`

    Args:
        ip (str): The IP of the client `Computer` to find
        port (int, optional): The open port on the given client (find `Computer` behind another `Router` in an external LAN)

    Returns:
        SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the `Computer` object if found.
    &#34;&#34;&#34;
    # Check if the computer we&#39;re looking for is ourselves (isp)
    if ip == self.lan:
        return SysCallStatus(success=True, data=self)

    # Check if the client is an IP or a domain
    try:
        is_ipv4 = ipaddress.ip_address(ip)
    except ValueError:
        is_ipv4 = False

    if not is_ipv4:
        # Try to resolve the given dns record
        dns_result = self.resolve_dns(ip)

        if not dns_result.success:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)
        else:
            ip = dns_result.data

    find_client = next((x for x in self.clients.values() if x.wan == ip), None)
    if find_client:
        return SysCallStatus(success=True, data=find_client)

    # Client not found
    return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.ISPRouter.remove_dns_record"><code class="name flex">
<span>def <span class="ident">remove_dns_record</span></span>(<span>self, domain_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove an existing record from the given <code>ISPRouters</code> DNS records table</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>domain_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The domain name of the record to be removed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> with the <code>success</code> flag set appropriately.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_dns_record(self, domain_name):
    &#34;&#34;&#34;
    Remove an existing record from the given `ISPRouters` DNS records table

    Args:
        domain_name (str): The domain name of the record to be removed

    Returns:
        SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately.
    &#34;&#34;&#34;
    if domain_name in self.dns_records.keys():
        del self.dns_records[domain_name]
        return SysCallStatus(success=True)

    return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.ISPRouter.resolve_dns"><code class="name flex">
<span>def <span class="ident">resolve_dns</span></span>(<span>self, domain_name:str) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Find the IP address linked to the given <code>domain_name</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>domain_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The domain name to resolve</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> with the <code>success</code> flag set appropriately. The <code>data</code> flag contains the resolved IP address if found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_dns(self, domain_name: str) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Find the IP address linked to the given `domain_name`

    Args:
        domain_name (str): The domain name to resolve

    Returns:
        SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the resolved IP address if found.
    &#34;&#34;&#34;
    dns_record = self.dns_records.get(domain_name, None)
    if dns_record:
        return SysCallStatus(success=True, data=dns_record)

    # Failed to find
    return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="client.blackhat.computer.Router" href="#client.blackhat.computer.Router">Router</a></b></code>:
<ul class="hlist">
<li><code><a title="client.blackhat.computer.Router.add_group" href="#client.blackhat.computer.Computer.add_group">add_group</a></code></li>
<li><code><a title="client.blackhat.computer.Router.add_user" href="#client.blackhat.computer.Computer.add_user">add_user</a></code></li>
<li><code><a title="client.blackhat.computer.Router.add_user_to_group" href="#client.blackhat.computer.Computer.add_user_to_group">add_user_to_group</a></code></li>
<li><code><a title="client.blackhat.computer.Router.change_user_password" href="#client.blackhat.computer.Computer.change_user_password">change_user_password</a></code></li>
<li><code><a title="client.blackhat.computer.Router.create_root_user" href="#client.blackhat.computer.Computer.create_root_user">create_root_user</a></code></li>
<li><code><a title="client.blackhat.computer.Router.delete_group" href="#client.blackhat.computer.Computer.delete_group">delete_group</a></code></li>
<li><code><a title="client.blackhat.computer.Router.delete_user" href="#client.blackhat.computer.Computer.delete_user">delete_user</a></code></li>
<li><code><a title="client.blackhat.computer.Router.find_client_by_port" href="#client.blackhat.computer.Router.find_client_by_port">find_client_by_port</a></code></li>
<li><code><a title="client.blackhat.computer.Router.find_group" href="#client.blackhat.computer.Computer.find_group">find_group</a></code></li>
<li><code><a title="client.blackhat.computer.Router.find_local_client" href="#client.blackhat.computer.Router.find_local_client">find_local_client</a></code></li>
<li><code><a title="client.blackhat.computer.Router.find_user" href="#client.blackhat.computer.Computer.find_user">find_user</a></code></li>
<li><code><a title="client.blackhat.computer.Router.find_user_groups" href="#client.blackhat.computer.Computer.find_user_groups">find_user_groups</a></code></li>
<li><code><a title="client.blackhat.computer.Router.get_all_groups" href="#client.blackhat.computer.Computer.get_all_groups">get_all_groups</a></code></li>
<li><code><a title="client.blackhat.computer.Router.get_all_users" href="#client.blackhat.computer.Computer.get_all_users">get_all_users</a></code></li>
<li><code><a title="client.blackhat.computer.Router.get_gid" href="#client.blackhat.computer.Computer.get_gid">get_gid</a></code></li>
<li><code><a title="client.blackhat.computer.Router.get_uid" href="#client.blackhat.computer.Computer.get_uid">get_uid</a></code></li>
<li><code><a title="client.blackhat.computer.Router.handle_tcp_connection" href="#client.blackhat.computer.Router.handle_tcp_connection">handle_tcp_connection</a></code></li>
<li><code><a title="client.blackhat.computer.Router.init" href="#client.blackhat.computer.Computer.init">init</a></code></li>
<li><code><a title="client.blackhat.computer.Router.post_fs_init" href="#client.blackhat.computer.Computer.post_fs_init">post_fs_init</a></code></li>
<li><code><a title="client.blackhat.computer.Router.remove_user_from_group" href="#client.blackhat.computer.Computer.remove_user_from_group">remove_user_from_group</a></code></li>
<li><code><a title="client.blackhat.computer.Router.run_command" href="#client.blackhat.computer.Computer.run_command">run_command</a></code></li>
<li><code><a title="client.blackhat.computer.Router.run_current_user_shellrc" href="#client.blackhat.computer.Computer.run_current_user_shellrc">run_current_user_shellrc</a></code></li>
<li><code><a title="client.blackhat.computer.Router.save" href="#client.blackhat.computer.Computer.save">save</a></code></li>
<li><code><a title="client.blackhat.computer.Router.send_tcp" href="#client.blackhat.computer.Computer.send_tcp">send_tcp</a></code></li>
<li><code><a title="client.blackhat.computer.Router.update_groups" href="#client.blackhat.computer.Computer.update_groups">update_groups</a></code></li>
<li><code><a title="client.blackhat.computer.Router.update_hostname" href="#client.blackhat.computer.Computer.update_hostname">update_hostname</a></code></li>
<li><code><a title="client.blackhat.computer.Router.update_passwd" href="#client.blackhat.computer.Computer.update_passwd">update_passwd</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="client.blackhat.computer.Router"><code class="flex name class">
<span>class <span class="ident">Router</span></span>
</code></dt>
<dd>
<div class="desc"><p>This special type of <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> is made for handling network traffic between computers in a LAN
This class represents what a real router would be in real life</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Router(Computer):
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        This special type of `Computer` is made for handling network traffic between computers in a LAN
        This class represents what a real router would be in real life
        &#34;&#34;&#34;
        super().__init__()
        self.clients = {}  # Format of clients: sorted by VLAN then ID [1][2] (VLAN 1 - ID 2)
        self.ip_pool: dict[int, list[str]] = {}
        self.wan = None
        self.lan = &#34;192.168.1.1&#34;
        self.port_forwarding = {}

    def dhcp(self, vlan: int) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Distributes IP addresses to clients on the network

        Args:
            vlan (int): VLAN id to assign the client to

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the IP to assign to a given client.
        &#34;&#34;&#34;
        # Split the router&#39;s IP to get the first 16 bits
        ip_split = self.lan.split(&#34;.&#34;)
        network_prefix = f&#34;{ip_split[0]}.{ip_split[1]}.{vlan}&#34;

        # Check if the IP pool for that VLAN was generated already
        try:
            len(self.ip_pool[vlan])
        # If `self.ip_pool[&lt;VLAN&gt;]` returns a key error, it was never created before
        except KeyError:
            # Generate a list of ips that are &lt;NETWORK_PREFIX&gt;.&lt;VLAN&gt;.1-256
            self.ip_pool[vlan] = [f&#34;{network_prefix}.{x}&#34; for x in range(1, 257)]

        # Check if we have IP&#39;s left
        if len(self.ip_pool[vlan]) == 0:
            return SysCallStatus(success=False, message=SysCallMessages.EMPTY)

        # Choose a random ip from the pool
        ip = choice(self.ip_pool[vlan])

        # Remove the IP from the pool since it&#39;s in use
        self.ip_pool[vlan].remove(ip)
        return SysCallStatus(success=True, data=ip)

    def find_local_client(self, ip: str) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Finds a client (`Computer` object) in the local network by IP address

        Args:
            ip (str): The &#34;private&#34; IP of the client `Computer` to find

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the `Computer` object if found.
        &#34;&#34;&#34;
        vlan = ip.split(&#34;.&#34;)[2]
        for client in self.clients[int(vlan)].values():
            if client.lan == ip:
                return SysCallStatus(success=True, data=client)

        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    def find_client(self, ip: str, port: Optional[int] = None) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        A more &#34;general&#34; version of the `find_local_client()` function. This function determines if the given router will
        ask the `ISPRouter` for the given IP address or if the client is within the `Router`&#39;s LAN

        Args:
            ip (str): The IP of the client `Computer` to find
            port (int, optional): The open port on the given client (find `Computer` behind another `Router` in an external LAN)

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the `Computer` object if found.
        &#34;&#34;&#34;
        # Check if the client belongs to ourselves (don&#39;t ask isp)
        ip_split = self.lan.split(&#34;.&#34;)
        network_prefix = f&#34;{ip_split[0]}.{ip_split[1]}&#34;

        # First check if we&#39;re looking for one of our own hosts
        if ip.startswith(network_prefix):
            # We&#39;re looking for ourselves
            if ip == self.lan:
                return SysCallStatus(success=True, data=self)
            else:
                client_ip_split = ip.split(&#34;.&#34;)
                vlan = client_ip_split[2]
                vlan_result = self.clients.get(vlan)
                if vlan_result:
                    client_result = vlan_result.get(ip)

                    if client_result:
                        return SysCallStatus(success=True, data=client_result)

                return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)
        else:

            # If the given ip is our wan address, another router is asking for a client
            if ip == self.wan:
                # If there is no port, we want the router (ourselves)
                if not port:
                    return SysCallStatus(success=True, data=self)
                else:
                    # We want a host at a specific open port
                    return self.find_client_by_port(port)
            # We&#39;re trying to find a client on another router, we do this by asking our router (the isp)
            else:
                # Ask the ISP for the router
                wan_client = self.parent.find_client(ip, port)
                if wan_client.success:
                    # We found the other router
                    # If there&#39;s no port, we&#39;re done (we wanted the router not a host behind the router)
                    if not port:
                        return SysCallStatus(success=True, data=wan_client)
                    else:
                        # If there is a port, we want to ask the external router for the client behind that port
                        # We can ask that router directly
                        return wan_client.data.find_client_by_port(port)
                else:
                    # Even the ISP couldn&#39;t find that router, it must not exist
                    return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)

    def find_client_by_port(self, port: int) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Find a client in the given `Router`&#39;s LAN by open port.
        Primarily used for finding the `Computer` hosting a given `Service` through an open port in the given `Router`

        Args:
            port (int): The port number (1-65535) of the given `Computer`

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the `Computer` object if found.
        &#34;&#34;&#34;

        ip_to_find = self.port_forwarding.get(port, None)
        if not ip_to_find:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)
        else:
            return SysCallStatus(success=True, data=ip_to_find)

    def add_new_client(self, client: Computer, vlan: int = 1) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Connect a given `Computer` to the given `Router`&#39;s LAN.
        Also, assign an IP address using the `dhcp()` function.

        Args:
            client (Computer): The `Computer` instance to connect to the `Router`&#39;s LAN
            vlan (int, optional): The VLAN id to assign the given `Computer` to

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the `client`&#39;s newly assigned IP address if successful.
        &#34;&#34;&#34;
        # Generate an IP for the client
        generate_ip_status = self.dhcp(vlan)
        # We we&#39;re unable to generate an IP for the given client
        if not generate_ip_status:
            return generate_ip_status

        # Assign the IP
        client.lan = generate_ip_status.data

        # Append to client to our client list
        try:
            last_id = list(self.clients[vlan].keys())[-1]
        except KeyError:
            last_id = 0

        # Check if the client vlan exists
        try:
            len(self.clients[vlan])
        except KeyError:
            # Init the vlan (empty)
            self.clients[vlan] = {}

        self.clients[vlan][last_id + 1] = client

        client.parent = self

        return SysCallStatus(success=True, data=client.lan)

    def resolve_dns(self, domain_name: str) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Ask the ISP to resolve a dns domain name to an IP address

        Args:
            domain_name (str): The domain name to resolve

        Returns:
            SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the IP of the given `domain_name` if found.
        &#34;&#34;&#34;
        # Ask our parent (ISP router) to resolve a dns record
        return self.parent.resolve_dns(domain_name)

    def handle_tcp_connection(self, host: str, port: int, args: dict) -&gt; SysCallStatus:
        &#34;&#34;&#34;
        Handle network traffic routing within the `Router`&#39;s LAN and between LANs

        Args:
            host (str): The IP address of the host to send the given `args` to
            port (int): The port on the given `host` in which the `Service` runs on
            args (dict): The data to send to the given `host` (processed by the `Service` on the other end)

        Returns:
            SysCallStatus: A `SysCallStatus` instance containing results about the connection (successful or not) and a response from the `Service` (if successful)
        &#34;&#34;&#34;
        # If we don&#39;t manually check for our own ip, we end up in an infinite loop of trying to handle tcp connections
        if host == self.lan:
            if port in self.services.keys():
                return self.services[port].main(args)
            else:
                return SysCallStatus(success=False, message=SysCallMessages.GENERIC_NETWORK)
        client = self.find_client(host, port)
        if not client.success:
            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)
        else:
            return client.data.handle_tcp_connection(host, port, args)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="client.blackhat.computer.ISPRouter" href="#client.blackhat.computer.ISPRouter">ISPRouter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="client.blackhat.computer.Router.add_new_client"><code class="name flex">
<span>def <span class="ident">add_new_client</span></span>(<span>self, client:<a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a>, vlan:int=1) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Connect a given <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> to the given <code><a title="client.blackhat.computer.Router" href="#client.blackhat.computer.Router">Router</a></code>'s LAN.
Also, assign an IP address using the <code>dhcp()</code> function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code></dt>
<dd>The <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> instance to connect to the <code><a title="client.blackhat.computer.Router" href="#client.blackhat.computer.Router">Router</a></code>'s LAN</dd>
<dt><strong><code>vlan</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The VLAN id to assign the given <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> to</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> with the <code>success</code> flag set appropriately. The <code>data</code> flag contains the <code>client</code>'s newly assigned IP address if successful.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_new_client(self, client: Computer, vlan: int = 1) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Connect a given `Computer` to the given `Router`&#39;s LAN.
    Also, assign an IP address using the `dhcp()` function.

    Args:
        client (Computer): The `Computer` instance to connect to the `Router`&#39;s LAN
        vlan (int, optional): The VLAN id to assign the given `Computer` to

    Returns:
        SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the `client`&#39;s newly assigned IP address if successful.
    &#34;&#34;&#34;
    # Generate an IP for the client
    generate_ip_status = self.dhcp(vlan)
    # We we&#39;re unable to generate an IP for the given client
    if not generate_ip_status:
        return generate_ip_status

    # Assign the IP
    client.lan = generate_ip_status.data

    # Append to client to our client list
    try:
        last_id = list(self.clients[vlan].keys())[-1]
    except KeyError:
        last_id = 0

    # Check if the client vlan exists
    try:
        len(self.clients[vlan])
    except KeyError:
        # Init the vlan (empty)
        self.clients[vlan] = {}

    self.clients[vlan][last_id + 1] = client

    client.parent = self

    return SysCallStatus(success=True, data=client.lan)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Router.dhcp"><code class="name flex">
<span>def <span class="ident">dhcp</span></span>(<span>self, vlan:int) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Distributes IP addresses to clients on the network</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vlan</code></strong> :&ensp;<code>int</code></dt>
<dd>VLAN id to assign the client to</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> with the <code>success</code> flag set appropriately. The <code>data</code> flag contains the IP to assign to a given client.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dhcp(self, vlan: int) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Distributes IP addresses to clients on the network

    Args:
        vlan (int): VLAN id to assign the client to

    Returns:
        SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the IP to assign to a given client.
    &#34;&#34;&#34;
    # Split the router&#39;s IP to get the first 16 bits
    ip_split = self.lan.split(&#34;.&#34;)
    network_prefix = f&#34;{ip_split[0]}.{ip_split[1]}.{vlan}&#34;

    # Check if the IP pool for that VLAN was generated already
    try:
        len(self.ip_pool[vlan])
    # If `self.ip_pool[&lt;VLAN&gt;]` returns a key error, it was never created before
    except KeyError:
        # Generate a list of ips that are &lt;NETWORK_PREFIX&gt;.&lt;VLAN&gt;.1-256
        self.ip_pool[vlan] = [f&#34;{network_prefix}.{x}&#34; for x in range(1, 257)]

    # Check if we have IP&#39;s left
    if len(self.ip_pool[vlan]) == 0:
        return SysCallStatus(success=False, message=SysCallMessages.EMPTY)

    # Choose a random ip from the pool
    ip = choice(self.ip_pool[vlan])

    # Remove the IP from the pool since it&#39;s in use
    self.ip_pool[vlan].remove(ip)
    return SysCallStatus(success=True, data=ip)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Router.find_client"><code class="name flex">
<span>def <span class="ident">find_client</span></span>(<span>self, ip:str, port:Optional[int]=None) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>A more "general" version of the <code>find_local_client()</code> function. This function determines if the given router will
ask the <code><a title="client.blackhat.computer.ISPRouter" href="#client.blackhat.computer.ISPRouter">ISPRouter</a></code> for the given IP address or if the client is within the <code><a title="client.blackhat.computer.Router" href="#client.blackhat.computer.Router">Router</a></code>'s LAN</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ip</code></strong> :&ensp;<code>str</code></dt>
<dd>The IP of the client <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> to find</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The open port on the given client (find <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> behind another <code><a title="client.blackhat.computer.Router" href="#client.blackhat.computer.Router">Router</a></code> in an external LAN)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> with the <code>success</code> flag set appropriately. The <code>data</code> flag contains the <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> object if found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_client(self, ip: str, port: Optional[int] = None) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    A more &#34;general&#34; version of the `find_local_client()` function. This function determines if the given router will
    ask the `ISPRouter` for the given IP address or if the client is within the `Router`&#39;s LAN

    Args:
        ip (str): The IP of the client `Computer` to find
        port (int, optional): The open port on the given client (find `Computer` behind another `Router` in an external LAN)

    Returns:
        SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the `Computer` object if found.
    &#34;&#34;&#34;
    # Check if the client belongs to ourselves (don&#39;t ask isp)
    ip_split = self.lan.split(&#34;.&#34;)
    network_prefix = f&#34;{ip_split[0]}.{ip_split[1]}&#34;

    # First check if we&#39;re looking for one of our own hosts
    if ip.startswith(network_prefix):
        # We&#39;re looking for ourselves
        if ip == self.lan:
            return SysCallStatus(success=True, data=self)
        else:
            client_ip_split = ip.split(&#34;.&#34;)
            vlan = client_ip_split[2]
            vlan_result = self.clients.get(vlan)
            if vlan_result:
                client_result = vlan_result.get(ip)

                if client_result:
                    return SysCallStatus(success=True, data=client_result)

            return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)
    else:

        # If the given ip is our wan address, another router is asking for a client
        if ip == self.wan:
            # If there is no port, we want the router (ourselves)
            if not port:
                return SysCallStatus(success=True, data=self)
            else:
                # We want a host at a specific open port
                return self.find_client_by_port(port)
        # We&#39;re trying to find a client on another router, we do this by asking our router (the isp)
        else:
            # Ask the ISP for the router
            wan_client = self.parent.find_client(ip, port)
            if wan_client.success:
                # We found the other router
                # If there&#39;s no port, we&#39;re done (we wanted the router not a host behind the router)
                if not port:
                    return SysCallStatus(success=True, data=wan_client)
                else:
                    # If there is a port, we want to ask the external router for the client behind that port
                    # We can ask that router directly
                    return wan_client.data.find_client_by_port(port)
            else:
                # Even the ISP couldn&#39;t find that router, it must not exist
                return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Router.find_client_by_port"><code class="name flex">
<span>def <span class="ident">find_client_by_port</span></span>(<span>self, port:int) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Find a client in the given <code><a title="client.blackhat.computer.Router" href="#client.blackhat.computer.Router">Router</a></code>'s LAN by open port.
Primarily used for finding the <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> hosting a given <code>Service</code> through an open port in the given <code><a title="client.blackhat.computer.Router" href="#client.blackhat.computer.Router">Router</a></code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>The port number (1-65535) of the given <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> with the <code>success</code> flag set appropriately. The <code>data</code> flag contains the <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> object if found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_client_by_port(self, port: int) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Find a client in the given `Router`&#39;s LAN by open port.
    Primarily used for finding the `Computer` hosting a given `Service` through an open port in the given `Router`

    Args:
        port (int): The port number (1-65535) of the given `Computer`

    Returns:
        SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the `Computer` object if found.
    &#34;&#34;&#34;

    ip_to_find = self.port_forwarding.get(port, None)
    if not ip_to_find:
        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)
    else:
        return SysCallStatus(success=True, data=ip_to_find)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Router.find_local_client"><code class="name flex">
<span>def <span class="ident">find_local_client</span></span>(<span>self, ip:str) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Finds a client (<code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> object) in the local network by IP address</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ip</code></strong> :&ensp;<code>str</code></dt>
<dd>The "private" IP of the client <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> to find</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> with the <code>success</code> flag set appropriately. The <code>data</code> flag contains the <code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code> object if found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_local_client(self, ip: str) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Finds a client (`Computer` object) in the local network by IP address

    Args:
        ip (str): The &#34;private&#34; IP of the client `Computer` to find

    Returns:
        SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the `Computer` object if found.
    &#34;&#34;&#34;
    vlan = ip.split(&#34;.&#34;)[2]
    for client in self.clients[int(vlan)].values():
        if client.lan == ip:
            return SysCallStatus(success=True, data=client)

    return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Router.handle_tcp_connection"><code class="name flex">
<span>def <span class="ident">handle_tcp_connection</span></span>(<span>self, host:str, port:int, args:dict) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Handle network traffic routing within the <code><a title="client.blackhat.computer.Router" href="#client.blackhat.computer.Router">Router</a></code>'s LAN and between LANs</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong> :&ensp;<code>str</code></dt>
<dd>The IP address of the host to send the given <code>args</code> to</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>The port on the given <code>host</code> in which the <code>Service</code> runs on</dd>
<dt><strong><code>args</code></strong> :&ensp;<code>dict</code></dt>
<dd>The data to send to the given <code>host</code> (processed by the <code>Service</code> on the other end)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> instance containing results about the connection (successful or not) and a response from the <code>Service</code> (if successful)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_tcp_connection(self, host: str, port: int, args: dict) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Handle network traffic routing within the `Router`&#39;s LAN and between LANs

    Args:
        host (str): The IP address of the host to send the given `args` to
        port (int): The port on the given `host` in which the `Service` runs on
        args (dict): The data to send to the given `host` (processed by the `Service` on the other end)

    Returns:
        SysCallStatus: A `SysCallStatus` instance containing results about the connection (successful or not) and a response from the `Service` (if successful)
    &#34;&#34;&#34;
    # If we don&#39;t manually check for our own ip, we end up in an infinite loop of trying to handle tcp connections
    if host == self.lan:
        if port in self.services.keys():
            return self.services[port].main(args)
        else:
            return SysCallStatus(success=False, message=SysCallMessages.GENERIC_NETWORK)
    client = self.find_client(host, port)
    if not client.success:
        return SysCallStatus(success=False, message=SysCallMessages.NOT_FOUND)
    else:
        return client.data.handle_tcp_connection(host, port, args)</code></pre>
</details>
</dd>
<dt id="client.blackhat.computer.Router.resolve_dns"><code class="name flex">
<span>def <span class="ident">resolve_dns</span></span>(<span>self, domain_name:str) ><a title="client.blackhat.helpers.SysCallStatus" href="helpers.html#client.blackhat.helpers.SysCallStatus">SysCallStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Ask the ISP to resolve a dns domain name to an IP address</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>domain_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The domain name to resolve</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SysCallStatus</code></dt>
<dd>A <code>SysCallStatus</code> with the <code>success</code> flag set appropriately. The <code>data</code> flag contains the IP of the given <code>domain_name</code> if found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_dns(self, domain_name: str) -&gt; SysCallStatus:
    &#34;&#34;&#34;
    Ask the ISP to resolve a dns domain name to an IP address

    Args:
        domain_name (str): The domain name to resolve

    Returns:
        SysCallStatus: A `SysCallStatus` with the `success` flag set appropriately. The `data` flag contains the IP of the given `domain_name` if found.
    &#34;&#34;&#34;
    # Ask our parent (ISP router) to resolve a dns record
    return self.parent.resolve_dns(domain_name)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></b></code>:
<ul class="hlist">
<li><code><a title="client.blackhat.computer.Computer.add_group" href="#client.blackhat.computer.Computer.add_group">add_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.add_user" href="#client.blackhat.computer.Computer.add_user">add_user</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.add_user_to_group" href="#client.blackhat.computer.Computer.add_user_to_group">add_user_to_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.change_user_password" href="#client.blackhat.computer.Computer.change_user_password">change_user_password</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.create_root_user" href="#client.blackhat.computer.Computer.create_root_user">create_root_user</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.delete_group" href="#client.blackhat.computer.Computer.delete_group">delete_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.delete_user" href="#client.blackhat.computer.Computer.delete_user">delete_user</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.find_group" href="#client.blackhat.computer.Computer.find_group">find_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.find_user" href="#client.blackhat.computer.Computer.find_user">find_user</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.find_user_groups" href="#client.blackhat.computer.Computer.find_user_groups">find_user_groups</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_all_groups" href="#client.blackhat.computer.Computer.get_all_groups">get_all_groups</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_all_users" href="#client.blackhat.computer.Computer.get_all_users">get_all_users</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_gid" href="#client.blackhat.computer.Computer.get_gid">get_gid</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_uid" href="#client.blackhat.computer.Computer.get_uid">get_uid</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.init" href="#client.blackhat.computer.Computer.init">init</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.post_fs_init" href="#client.blackhat.computer.Computer.post_fs_init">post_fs_init</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.remove_user_from_group" href="#client.blackhat.computer.Computer.remove_user_from_group">remove_user_from_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.run_command" href="#client.blackhat.computer.Computer.run_command">run_command</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.run_current_user_shellrc" href="#client.blackhat.computer.Computer.run_current_user_shellrc">run_current_user_shellrc</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.save" href="#client.blackhat.computer.Computer.save">save</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.send_tcp" href="#client.blackhat.computer.Computer.send_tcp">send_tcp</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.update_groups" href="#client.blackhat.computer.Computer.update_groups">update_groups</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.update_hostname" href="#client.blackhat.computer.Computer.update_hostname">update_hostname</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.update_passwd" href="#client.blackhat.computer.Computer.update_passwd">update_passwd</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="client.blackhat" href="index.html">client.blackhat</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="client.blackhat.computer.Computer" href="#client.blackhat.computer.Computer">Computer</a></code></h4>
<ul class="">
<li><code><a title="client.blackhat.computer.Computer.add_group" href="#client.blackhat.computer.Computer.add_group">add_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.add_user" href="#client.blackhat.computer.Computer.add_user">add_user</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.add_user_to_group" href="#client.blackhat.computer.Computer.add_user_to_group">add_user_to_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.change_user_password" href="#client.blackhat.computer.Computer.change_user_password">change_user_password</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.create_root_user" href="#client.blackhat.computer.Computer.create_root_user">create_root_user</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.delete_group" href="#client.blackhat.computer.Computer.delete_group">delete_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.delete_user" href="#client.blackhat.computer.Computer.delete_user">delete_user</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.find_group" href="#client.blackhat.computer.Computer.find_group">find_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.find_user" href="#client.blackhat.computer.Computer.find_user">find_user</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.find_user_groups" href="#client.blackhat.computer.Computer.find_user_groups">find_user_groups</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_all_groups" href="#client.blackhat.computer.Computer.get_all_groups">get_all_groups</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_all_users" href="#client.blackhat.computer.Computer.get_all_users">get_all_users</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_gid" href="#client.blackhat.computer.Computer.get_gid">get_gid</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.get_uid" href="#client.blackhat.computer.Computer.get_uid">get_uid</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.handle_tcp_connection" href="#client.blackhat.computer.Computer.handle_tcp_connection">handle_tcp_connection</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.init" href="#client.blackhat.computer.Computer.init">init</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.post_fs_init" href="#client.blackhat.computer.Computer.post_fs_init">post_fs_init</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.remove_user_from_group" href="#client.blackhat.computer.Computer.remove_user_from_group">remove_user_from_group</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.run_command" href="#client.blackhat.computer.Computer.run_command">run_command</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.run_current_user_shellrc" href="#client.blackhat.computer.Computer.run_current_user_shellrc">run_current_user_shellrc</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.save" href="#client.blackhat.computer.Computer.save">save</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.send_tcp" href="#client.blackhat.computer.Computer.send_tcp">send_tcp</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.update_groups" href="#client.blackhat.computer.Computer.update_groups">update_groups</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.update_hostname" href="#client.blackhat.computer.Computer.update_hostname">update_hostname</a></code></li>
<li><code><a title="client.blackhat.computer.Computer.update_passwd" href="#client.blackhat.computer.Computer.update_passwd">update_passwd</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="client.blackhat.computer.ISPRouter" href="#client.blackhat.computer.ISPRouter">ISPRouter</a></code></h4>
<ul class="two-column">
<li><code><a title="client.blackhat.computer.ISPRouter.add_dns_record" href="#client.blackhat.computer.ISPRouter.add_dns_record">add_dns_record</a></code></li>
<li><code><a title="client.blackhat.computer.ISPRouter.add_new_client" href="#client.blackhat.computer.ISPRouter.add_new_client">add_new_client</a></code></li>
<li><code><a title="client.blackhat.computer.ISPRouter.dhcp" href="#client.blackhat.computer.ISPRouter.dhcp">dhcp</a></code></li>
<li><code><a title="client.blackhat.computer.ISPRouter.find_client" href="#client.blackhat.computer.ISPRouter.find_client">find_client</a></code></li>
<li><code><a title="client.blackhat.computer.ISPRouter.remove_dns_record" href="#client.blackhat.computer.ISPRouter.remove_dns_record">remove_dns_record</a></code></li>
<li><code><a title="client.blackhat.computer.ISPRouter.resolve_dns" href="#client.blackhat.computer.ISPRouter.resolve_dns">resolve_dns</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="client.blackhat.computer.Router" href="#client.blackhat.computer.Router">Router</a></code></h4>
<ul class="">
<li><code><a title="client.blackhat.computer.Router.add_new_client" href="#client.blackhat.computer.Router.add_new_client">add_new_client</a></code></li>
<li><code><a title="client.blackhat.computer.Router.dhcp" href="#client.blackhat.computer.Router.dhcp">dhcp</a></code></li>
<li><code><a title="client.blackhat.computer.Router.find_client" href="#client.blackhat.computer.Router.find_client">find_client</a></code></li>
<li><code><a title="client.blackhat.computer.Router.find_client_by_port" href="#client.blackhat.computer.Router.find_client_by_port">find_client_by_port</a></code></li>
<li><code><a title="client.blackhat.computer.Router.find_local_client" href="#client.blackhat.computer.Router.find_local_client">find_local_client</a></code></li>
<li><code><a title="client.blackhat.computer.Router.handle_tcp_connection" href="#client.blackhat.computer.Router.handle_tcp_connection">handle_tcp_connection</a></code></li>
<li><code><a title="client.blackhat.computer.Router.resolve_dns" href="#client.blackhat.computer.Router.resolve_dns">resolve_dns</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>